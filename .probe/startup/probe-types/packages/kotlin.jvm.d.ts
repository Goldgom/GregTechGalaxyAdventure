declare module "packages/kotlin/jvm/functions/$Function4" {
import {$Function, $Function$Type} from "packages/kotlin/$Function"

export interface $Function4<P1, P2, P3, P4, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2, arg2: P3, arg3: P4): R

(arg0: P1, arg1: P2, arg2: P3, arg3: P4): R
}

export namespace $Function4 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function4$Type<P1, P2, P3, P4, R> = ($Function4<(P1), (P2), (P3), (P4), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function4_<P1, P2, P3, P4, R> = $Function4$Type<(P1), (P2), (P3), (P4), (R)>;
}}
declare module "packages/kotlin/jvm/functions/$Function2" {
import {$Function, $Function$Type} from "packages/kotlin/$Function"

export interface $Function2<P1, P2, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2): R

(arg0: P1, arg1: P2): R
}

export namespace $Function2 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function2$Type<P1, P2, R> = ($Function2<(P1), (P2), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function2_<P1, P2, R> = $Function2$Type<(P1), (P2), (R)>;
}}
declare module "packages/kotlin/jvm/functions/$Function3" {
import {$Function, $Function$Type} from "packages/kotlin/$Function"

export interface $Function3<P1, P2, P3, R> extends $Function<(R)> {

 "invoke"(arg0: P1, arg1: P2, arg2: P3): R

(arg0: P1, arg1: P2, arg2: P3): R
}

export namespace $Function3 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function3$Type<P1, P2, P3, R> = ($Function3<(P1), (P2), (P3), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function3_<P1, P2, P3, R> = $Function3$Type<(P1), (P2), (P3), (R)>;
}}
declare module "packages/kotlin/jvm/functions/$Function0" {
import {$Function, $Function$Type} from "packages/kotlin/$Function"

export interface $Function0<R> extends $Function<(R)> {

 "invoke"(): R

(): R
}

export namespace $Function0 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function0$Type<R> = ($Function0<(R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function0_<R> = $Function0$Type<(R)>;
}}
declare module "packages/kotlin/jvm/functions/$Function1" {
import {$Function, $Function$Type} from "packages/kotlin/$Function"

export interface $Function1<P1, R> extends $Function<(R)> {

 "invoke"(arg0: P1): R

(arg0: P1): R
}

export namespace $Function1 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function1$Type<P1, R> = ($Function1<(P1), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function1_<P1, R> = $Function1$Type<(P1), (R)>;
}}
declare module "packages/kotlin/jvm/internal/$DefaultConstructorMarker" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $DefaultConstructorMarker {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DefaultConstructorMarker$Type = ($DefaultConstructorMarker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DefaultConstructorMarker_ = $DefaultConstructorMarker$Type;
}}
declare module "packages/kotlin/jvm/internal/markers/$KMappedMarker" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $KMappedMarker {

}

export namespace $KMappedMarker {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KMappedMarker$Type = ($KMappedMarker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KMappedMarker_ = $KMappedMarker$Type;
}}
