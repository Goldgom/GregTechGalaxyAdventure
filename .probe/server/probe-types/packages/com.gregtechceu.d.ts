declare module "packages/com/gregtechceu/gtceu/common/data/$GTMachines" {
import {$GTRecipeType, $GTRecipeType$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipeType"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BoilerFireboxType, $BoilerFireboxType$Type} from "packages/com/gregtechceu/gtceu/common/block/$BoilerFireboxType"
import {$MultiblockControllerMachine, $MultiblockControllerMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/multiblock/$MultiblockControllerMachine"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$MedicalCondition, $MedicalCondition$Type} from "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$MedicalCondition"
import {$IO, $IO$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IO"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$PartAbility, $PartAbility$Type} from "packages/com/gregtechceu/gtceu/api/machine/multiblock/$PartAbility"
import {$MachineDefinition, $MachineDefinition$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MachineDefinition"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$MultiblockMachineBuilder, $MultiblockMachineBuilder$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$MultiblockMachineBuilder"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$Pair, $Pair$Type} from "packages/it/unimi/dsi/fastutil/$Pair"
import {$MultiblockMachineDefinition, $MultiblockMachineDefinition$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MultiblockMachineDefinition"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IMachineBlockEntity, $IMachineBlockEntity$Type} from "packages/com/gregtechceu/gtceu/api/machine/$IMachineBlockEntity"
import {$MetaMachine, $MetaMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MetaMachine"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$MachineBuilder, $MachineBuilder$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$MachineBuilder"
import {$Object2IntMap, $Object2IntMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntMap"

export class $GTMachines {
static readonly "ALL_TIERS": (integer)[]
static readonly "ELECTRIC_TIERS": (integer)[]
static readonly "LOW_TIERS": (integer)[]
static readonly "HIGH_TIERS": (integer)[]
static readonly "MULTI_HATCH_TIERS": (integer)[]
static readonly "defaultTankSizeFunction": $Int2LongFunction
static readonly "hvCappedTankSizeFunction": $Int2LongFunction
static readonly "largeTankSizeFunction": $Int2LongFunction
static readonly "steamGeneratorTankSizeFunction": $Int2LongFunction
static readonly "genericGeneratorTankSizeFunction": $Int2LongFunction
static "DRUM_CAPACITY": $Object2IntMap<($MachineDefinition)>
static readonly "STEAM_SOLID_BOILER": $Pair<($MachineDefinition), ($MachineDefinition)>
static readonly "STEAM_LIQUID_BOILER": $Pair<($MachineDefinition), ($MachineDefinition)>
static readonly "STEAM_SOLAR_BOILER": $Pair<($MachineDefinition), ($MachineDefinition)>
static readonly "STEAM_EXTRACTOR": $Pair<($MachineDefinition), ($MachineDefinition)>
static readonly "STEAM_MACERATOR": $Pair<($MachineDefinition), ($MachineDefinition)>
static readonly "STEAM_COMPRESSOR": $Pair<($MachineDefinition), ($MachineDefinition)>
static readonly "STEAM_HAMMER": $Pair<($MachineDefinition), ($MachineDefinition)>
static readonly "STEAM_FURNACE": $Pair<($MachineDefinition), ($MachineDefinition)>
static readonly "STEAM_ALLOY_SMELTER": $Pair<($MachineDefinition), ($MachineDefinition)>
static readonly "STEAM_ROCK_CRUSHER": $Pair<($MachineDefinition), ($MachineDefinition)>
static readonly "STEAM_MINER": $MachineDefinition
static readonly "HULL": ($MachineDefinition)[]
static readonly "ELECTRIC_FURNACE": ($MachineDefinition)[]
static readonly "ALLOY_SMELTER": ($MachineDefinition)[]
static readonly "ARC_FURNACE": ($MachineDefinition)[]
static readonly "ASSEMBLER": ($MachineDefinition)[]
static readonly "AUTOCLAVE": ($MachineDefinition)[]
static readonly "BENDER": ($MachineDefinition)[]
static readonly "BREWERY": ($MachineDefinition)[]
static readonly "CANNER": ($MachineDefinition)[]
static readonly "CENTRIFUGE": ($MachineDefinition)[]
static readonly "CHEMICAL_BATH": ($MachineDefinition)[]
static readonly "CHEMICAL_REACTOR": ($MachineDefinition)[]
static readonly "COMPRESSOR": ($MachineDefinition)[]
static readonly "CUTTER": ($MachineDefinition)[]
static readonly "DISTILLERY": ($MachineDefinition)[]
static readonly "ELECTROLYZER": ($MachineDefinition)[]
static readonly "ELECTROMAGNETIC_SEPARATOR": ($MachineDefinition)[]
static readonly "EXTRACTOR": ($MachineDefinition)[]
static readonly "EXTRUDER": ($MachineDefinition)[]
static readonly "FERMENTER": ($MachineDefinition)[]
static readonly "FLUID_HEATER": ($MachineDefinition)[]
static readonly "FLUID_SOLIDIFIER": ($MachineDefinition)[]
static readonly "FORGE_HAMMER": ($MachineDefinition)[]
static readonly "FORMING_PRESS": ($MachineDefinition)[]
static readonly "LATHE": ($MachineDefinition)[]
static readonly "SCANNER": ($MachineDefinition)[]
static readonly "MIXER": ($MachineDefinition)[]
static readonly "ORE_WASHER": ($MachineDefinition)[]
static readonly "PACKER": ($MachineDefinition)[]
static readonly "POLARIZER": ($MachineDefinition)[]
static readonly "LASER_ENGRAVER": ($MachineDefinition)[]
static readonly "SIFTER": ($MachineDefinition)[]
static readonly "THERMAL_CENTRIFUGE": ($MachineDefinition)[]
static readonly "WIREMILL": ($MachineDefinition)[]
static readonly "CIRCUIT_ASSEMBLER": ($MachineDefinition)[]
static readonly "MACERATOR": ($MachineDefinition)[]
static readonly "GAS_COLLECTOR": ($MachineDefinition)[]
static readonly "ROCK_CRUSHER": ($MachineDefinition)[]
static readonly "AIR_SCRUBBER": ($MachineDefinition)[]
static readonly "COMBUSTION": ($MachineDefinition)[]
static readonly "STEAM_TURBINE": ($MachineDefinition)[]
static readonly "GAS_TURBINE": ($MachineDefinition)[]
static readonly "TRANSFORMER": ($MachineDefinition)[]
static readonly "HI_AMP_TRANSFORMER_2A": ($MachineDefinition)[]
static readonly "HI_AMP_TRANSFORMER_4A": ($MachineDefinition)[]
static readonly "POWER_TRANSFORMER": ($MachineDefinition)[]
static readonly "ENERGY_CONVERTER_1A": ($MachineDefinition)[]
static readonly "ENERGY_CONVERTER_4A": ($MachineDefinition)[]
static readonly "ENERGY_CONVERTER_8A": ($MachineDefinition)[]
static readonly "ENERGY_CONVERTER_16A": ($MachineDefinition)[]
static readonly "LONG_DIST_ITEM_ENDPOINT": $MachineDefinition
static readonly "LONG_DIST_FLUID_ENDPOINT": $MachineDefinition
static readonly "BATTERY_BUFFER_4": ($MachineDefinition)[]
static readonly "BATTERY_BUFFER_8": ($MachineDefinition)[]
static readonly "BATTERY_BUFFER_16": ($MachineDefinition)[]
static readonly "CHARGER_4": ($MachineDefinition)[]
static readonly "PUMP": ($MachineDefinition)[]
static readonly "FISHER": ($MachineDefinition)[]
static readonly "BLOCK_BREAKER": ($MachineDefinition)[]
static readonly "MINER": ($MachineDefinition)[]
static readonly "WORLD_ACCELERATOR": ($MachineDefinition)[]
static readonly "ITEM_COLLECTOR": ($MachineDefinition)[]
static readonly "CREATIVE_TOOLTIPS": $BiConsumer<($ItemStack), ($List<($Component)>)>
static readonly "CREATIVE_ENERGY": $MachineDefinition
static readonly "CREATIVE_FLUID": $MachineDefinition
static readonly "CREATIVE_ITEM": $MachineDefinition
static "CHEST_TOOLTIPS": $BiConsumer<($ItemStack), ($List<($Component)>)>
static readonly "SUPER_CHEST": ($MachineDefinition)[]
static readonly "QUANTUM_CHEST": ($MachineDefinition)[]
static readonly "SUPER_TANK": ($MachineDefinition)[]
static readonly "QUANTUM_TANK": ($MachineDefinition)[]
static readonly "WOODEN_TANK_VALVE": $MachineDefinition
static readonly "WOODEN_MULTIBLOCK_TANK": $MultiblockMachineDefinition
static readonly "STEEL_TANK_VALVE": $MachineDefinition
static readonly "STEEL_MULTIBLOCK_TANK": $MultiblockMachineDefinition
static "WOODEN_CRATE": $MachineDefinition
static "BRONZE_CRATE": $MachineDefinition
static "STEEL_CRATE": $MachineDefinition
static "ALUMINIUM_CRATE": $MachineDefinition
static "STAINLESS_STEEL_CRATE": $MachineDefinition
static "TITANIUM_CRATE": $MachineDefinition
static "TUNGSTENSTEEL_CRATE": $MachineDefinition
static "WOODEN_DRUM": $MachineDefinition
static "BRONZE_DRUM": $MachineDefinition
static "STEEL_DRUM": $MachineDefinition
static "ALUMINIUM_DRUM": $MachineDefinition
static "STAINLESS_STEEL_DRUM": $MachineDefinition
static "GOLD_DRUM": $MachineDefinition
static "TITANIUM_DRUM": $MachineDefinition
static "TUNGSTENSTEEL_DRUM": $MachineDefinition
static readonly "ITEM_IMPORT_BUS": ($MachineDefinition)[]
static readonly "ITEM_EXPORT_BUS": ($MachineDefinition)[]
static readonly "FLUID_IMPORT_HATCH": ($MachineDefinition)[]
static readonly "FLUID_IMPORT_HATCH_4X": ($MachineDefinition)[]
static readonly "FLUID_IMPORT_HATCH_9X": ($MachineDefinition)[]
static readonly "FLUID_EXPORT_HATCH": ($MachineDefinition)[]
static readonly "FLUID_EXPORT_HATCH_4X": ($MachineDefinition)[]
static readonly "FLUID_EXPORT_HATCH_9X": ($MachineDefinition)[]
static readonly "ENERGY_INPUT_HATCH": ($MachineDefinition)[]
static readonly "ENERGY_OUTPUT_HATCH": ($MachineDefinition)[]
static readonly "ENERGY_INPUT_HATCH_4A": ($MachineDefinition)[]
static readonly "ENERGY_OUTPUT_HATCH_4A": ($MachineDefinition)[]
static readonly "ENERGY_INPUT_HATCH_16A": ($MachineDefinition)[]
static readonly "ENERGY_OUTPUT_HATCH_16A": ($MachineDefinition)[]
static readonly "SUBSTATION_ENERGY_INPUT_HATCH": ($MachineDefinition)[]
static readonly "SUBSTATION_ENERGY_OUTPUT_HATCH": ($MachineDefinition)[]
static readonly "MUFFLER_HATCH": ($MachineDefinition)[]
static readonly "STEAM_IMPORT_BUS": $MachineDefinition
static readonly "STEAM_EXPORT_BUS": $MachineDefinition
static readonly "STEAM_HATCH": $MachineDefinition
static readonly "COKE_OVEN_HATCH": $MachineDefinition
static readonly "PUMP_HATCH": $MachineDefinition
static readonly "MAINTENANCE_HATCH": $MachineDefinition
static readonly "CONFIGURABLE_MAINTENANCE_HATCH": $MachineDefinition
static readonly "CLEANING_MAINTENANCE_HATCH": $MachineDefinition
static readonly "AUTO_MAINTENANCE_HATCH": $MachineDefinition
static readonly "ITEM_PASSTHROUGH_HATCH": ($MachineDefinition)[]
static readonly "FLUID_PASSTHROUGH_HATCH": ($MachineDefinition)[]
static readonly "DIODE": ($MachineDefinition)[]
static readonly "ROTOR_HOLDER": ($MachineDefinition)[]
static readonly "LASER_INPUT_HATCH_256": ($MachineDefinition)[]
static readonly "LASER_OUTPUT_HATCH_256": ($MachineDefinition)[]
static readonly "LASER_INPUT_HATCH_1024": ($MachineDefinition)[]
static readonly "LASER_OUTPUT_HATCH_1024": ($MachineDefinition)[]
static readonly "LASER_INPUT_HATCH_4096": ($MachineDefinition)[]
static readonly "LASER_OUTPUT_HATCH_4096": ($MachineDefinition)[]
static readonly "LARGE_BOILER_BRONZE": $MultiblockMachineDefinition
static readonly "LARGE_BOILER_STEEL": $MultiblockMachineDefinition
static readonly "LARGE_BOILER_TITANIUM": $MultiblockMachineDefinition
static readonly "LARGE_BOILER_TUNGSTENSTEEL": $MultiblockMachineDefinition
static readonly "COKE_OVEN": $MultiblockMachineDefinition
static readonly "PRIMITIVE_BLAST_FURNACE": $MultiblockMachineDefinition
static readonly "ELECTRIC_BLAST_FURNACE": $MultiblockMachineDefinition
static readonly "LARGE_CHEMICAL_REACTOR": $MultiblockMachineDefinition
static readonly "IMPLOSION_COMPRESSOR": $MultiblockMachineDefinition
static readonly "PYROLYSE_OVEN": $MultiblockMachineDefinition
static readonly "MULTI_SMELTER": $MultiblockMachineDefinition
static readonly "CRACKER": $MultiblockMachineDefinition
static readonly "DISTILLATION_TOWER": $MultiblockMachineDefinition
static readonly "EVAPORATION_PLANT": $MachineDefinition
static readonly "VACUUM_FREEZER": $MultiblockMachineDefinition
static readonly "ASSEMBLY_LINE": $MultiblockMachineDefinition
static readonly "PRIMITIVE_PUMP": $MultiblockMachineDefinition
static readonly "STEAM_GRINDER": $MultiblockMachineDefinition
static readonly "STEAM_OVEN": $MultiblockMachineDefinition
static readonly "FUSION_REACTOR": ($MultiblockMachineDefinition)[]
static readonly "FLUID_DRILLING_RIG": ($MultiblockMachineDefinition)[]
static readonly "LARGE_MINER": ($MultiblockMachineDefinition)[]
static "BEDROCK_ORE_MINER": ($MultiblockMachineDefinition)[]
static readonly "CLEANROOM": $MultiblockMachineDefinition
static readonly "LARGE_COMBUSTION_ENGINE": $MultiblockMachineDefinition
static readonly "EXTREME_COMBUSTION_ENGINE": $MultiblockMachineDefinition
static readonly "LARGE_STEAM_TURBINE": $MultiblockMachineDefinition
static readonly "LARGE_GAS_TURBINE": $MultiblockMachineDefinition
static readonly "LARGE_PLASMA_TURBINE": $MultiblockMachineDefinition
static readonly "PROCESSING_ARRAY": ($MultiblockMachineDefinition)[]
static readonly "ACTIVE_TRANSFORMER": $MultiblockMachineDefinition
static readonly "POWER_SUBSTATION": $MultiblockMachineDefinition

constructor()

public static "get"(name: string): $MachineDefinition
public static "init"(): void
public static "registerConverter"(amperage: integer): ($MachineDefinition)[]
public static "explosion"(): $Component
public static "registerTieredMachines"(name: string, factory: $BiFunction$Type<($IMachineBlockEntity$Type), (integer), ($MetaMachine$Type)>, builder: $BiFunction$Type<(integer), ($MachineBuilder$Type<($MachineDefinition$Type)>), ($MachineDefinition$Type)>, ...tiers: (integer)[]): ($MachineDefinition)[]
public static "registerSimpleGenerator"(name: string, recipeType: $GTRecipeType$Type, tankScalingFunction: $Int2LongFunction$Type, hazardStrengthPerOperation: float, ...tiers: (integer)[]): ($MachineDefinition)[]
public static "registerLargeBoiler"(name: string, casing: $Supplier$Type<(any)>, pipe: $Supplier$Type<(any)>, fireBox: $Supplier$Type<(any)>, texture: $ResourceLocation$Type, firebox: $BoilerFireboxType$Type, maxTemperature: integer, heatSpeed: integer): $MultiblockMachineDefinition
public static "registerBatteryBuffer"(batterySlotSize: integer): ($MachineDefinition)[]
public static "registerSimpleSteamMachines"(name: string, recipeType: $GTRecipeType$Type): $Pair<($MachineDefinition), ($MachineDefinition)>
public static "createCreativeTooltips"(share: boolean): $BiConsumer<($ItemStack), ($List<($Component)>)>
public static "registerSteamMachines"(name: string, factory: $BiFunction$Type<($IMachineBlockEntity$Type), (boolean), ($MetaMachine$Type)>, builder: $BiFunction$Type<(boolean), ($MachineBuilder$Type<($MachineDefinition$Type)>), ($MachineDefinition$Type)>): $Pair<($MachineDefinition), ($MachineDefinition)>
public static "registerSimpleMachines"(name: string, recipeType: $GTRecipeType$Type): ($MachineDefinition)[]
public static "registerSimpleMachines"(name: string, recipeType: $GTRecipeType$Type, tankScalingFunction: $Int2LongFunction$Type): ($MachineDefinition)[]
public static "registerSimpleMachines"(name: string, recipeType: $GTRecipeType$Type, tankScalingFunction: $Int2LongFunction$Type, hasPollutionDebuff: boolean): ($MachineDefinition)[]
public static "registerSimpleMachines"(name: string, recipeType: $GTRecipeType$Type, tankScalingFunction: $Int2LongFunction$Type, hasPollutionDebuff: boolean, ...tiers: (integer)[]): ($MachineDefinition)[]
public static "registerTieredMultis"(name: string, factory: $BiFunction$Type<($IMachineBlockEntity$Type), (integer), ($MultiblockControllerMachine$Type)>, builder: $BiFunction$Type<(integer), ($MultiblockMachineBuilder$Type), ($MultiblockMachineDefinition$Type)>, ...tiers: (integer)[]): ($MultiblockMachineDefinition)[]
public static "registerTransformerMachines"(langName: string, baseAmp: integer): ($MachineDefinition)[]
public static "registerLargeCombustionEngine"(name: string, tier: integer, casing: $Supplier$Type<(any)>, gear: $Supplier$Type<(any)>, intake: $Supplier$Type<(any)>, casingTexture: $ResourceLocation$Type, overlayModel: $ResourceLocation$Type): $MultiblockMachineDefinition
public static "registerLargeTurbine"(name: string, tier: integer, recipeType: $GTRecipeType$Type, casing: $Supplier$Type<(any)>, gear: $Supplier$Type<(any)>, casingTexture: $ResourceLocation$Type, overlayModel: $ResourceLocation$Type): $MultiblockMachineDefinition
public static "defaultEnvironmentRequirement"(): $Component
public static "environmentRequirement"(condition: $MedicalCondition$Type): $Component
public static "createTankTooltips"(nbtName: string): $BiConsumer<($ItemStack), ($List<($Component)>)>
public static "registerCharger"(itemSlotSize: integer): ($MachineDefinition)[]
public static "registerLaserHatch"(io: $IO$Type, amperage: integer, ability: $PartAbility$Type): ($MachineDefinition)[]
public static "registerDrum"(material: $Material$Type, capacity: integer, lang: string): $MachineDefinition
public static "registerCrate"(material: $Material$Type, capacity: integer, lang: string): $MachineDefinition
public static "workableTiered"(tier: integer, voltage: long, energyCapacity: long, recipeType: $GTRecipeType$Type, tankCapacity: long, input: boolean): ($Component)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTMachines$Type = ($GTMachines);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTMachines_ = $GTMachines$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pattern/$MultiblockShapeInfo" {
import {$BlockInfo, $BlockInfo$Type} from "packages/com/lowdragmc/lowdraglib/utils/$BlockInfo"
import {$MultiblockShapeInfo$ShapeInfoBuilder, $MultiblockShapeInfo$ShapeInfoBuilder$Type} from "packages/com/gregtechceu/gtceu/api/pattern/$MultiblockShapeInfo$ShapeInfoBuilder"

export class $MultiblockShapeInfo {

constructor(blocks: ((($BlockInfo$Type)[])[])[])

public static "builder"(): $MultiblockShapeInfo$ShapeInfoBuilder
public "getBlocks"(): ((($BlockInfo)[])[])[]
get "blocks"(): ((($BlockInfo)[])[])[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiblockShapeInfo$Type = ($MultiblockShapeInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiblockShapeInfo_ = $MultiblockShapeInfo$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/$MaterialBlockItem" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$IRenderer, $IRenderer$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IRenderer"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$ItemColor, $ItemColor$Type} from "packages/net/minecraft/client/color/item/$ItemColor"
import {$FoodProperties, $FoodProperties$Type} from "packages/net/minecraft/world/food/$FoodProperties"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$BlockItem, $BlockItem$Type} from "packages/net/minecraft/world/item/$BlockItem"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$Type} from "packages/net/mehvahdjukaar/moonlight/api/item/additional_placements/$AdditionalItemPlacement"
import {$IItemRendererProvider, $IItemRendererProvider$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IItemRendererProvider"
import {$MaterialBlock, $MaterialBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$MaterialBlock"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MaterialBlockItem extends $BlockItem implements $IItemRendererProvider {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "descriptionId": string
 "foodProperties": $FoodProperties
readonly "canRepair": boolean
 "renderProperties": any
 "moonlight$clientAnimationProvider": any


public static "create"(block: $MaterialBlock$Type, properties: $Item$Properties$Type): $MaterialBlockItem
public "getBlock"(): $MaterialBlock
public "getItemBurnTime"(): integer
public "getName"(stack: $ItemStack$Type): $Component
public static "tintColor"(): $ItemColor
public "onRegister"(): void
public "getDescriptionId"(stack: $ItemStack$Type): string
public "getDescription"(): $Component
public "getBurnTime"(itemStack: $ItemStack$Type, recipeType: $RecipeType$Type<(any)>): integer
public "getRenderer"(stack: $ItemStack$Type): $IRenderer
public "getDescriptionId"(): string
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public "moonlight$addAdditionalBehavior"(arg0: $AdditionalItemPlacement$Type): void
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
get "block"(): $MaterialBlock
get "itemBurnTime"(): integer
get "description"(): $Component
get "descriptionId"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialBlockItem$Type = ($MaterialBlockItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialBlockItem_ = $MaterialBlockItem$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/$MachineCoverContainer" {
import {$ICoverable, $ICoverable$Type} from "packages/com/gregtechceu/gtceu/api/capability/$ICoverable"
import {$IFieldUpdateListener, $IFieldUpdateListener$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$IFieldUpdateListener"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CoverDefinition, $CoverDefinition$Type} from "packages/com/gregtechceu/gtceu/api/cover/$CoverDefinition"
import {$CoverBehavior, $CoverBehavior$Type} from "packages/com/gregtechceu/gtceu/api/cover/$CoverBehavior"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IFluidTransfer, $IFluidTransfer$Type} from "packages/com/lowdragmc/lowdraglib/side/fluid/$IFluidTransfer"
import {$TickableSubscription, $TickableSubscription$Type} from "packages/com/gregtechceu/gtceu/api/machine/$TickableSubscription"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MetaMachine, $MetaMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MetaMachine"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$FieldManagedStorage, $FieldManagedStorage$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/field/$FieldManagedStorage"
import {$ISubscription, $ISubscription$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$ISubscription"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$IItemTransfer, $IItemTransfer$Type} from "packages/com/lowdragmc/lowdraglib/side/item/$IItemTransfer"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IRef, $IRef$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/managed/$IRef"
import {$ManagedFieldHolder, $ManagedFieldHolder$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/field/$ManagedFieldHolder"
import {$IEnhancedManaged, $IEnhancedManaged$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$IEnhancedManaged"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export class $MachineCoverContainer implements $ICoverable, $IEnhancedManaged {
static readonly "MANAGED_FIELD_HOLDER": $ManagedFieldHolder

constructor(machine: $MetaMachine$Type)

public "getLevel"(): $Level
public "unsubscribe"(current: $TickableSubscription$Type): void
public "getPos"(): $BlockPos
public "markDirty"(): void
public "getSyncStorage"(): $FieldManagedStorage
public "onChanged"(): void
public "notifyBlockUpdate"(): void
public "canPlaceCoverOnSide"(definition: $CoverDefinition$Type, side: $Direction$Type): boolean
public "shouldRenderBackSide"(): boolean
public "getCoverPlateThickness"(): double
public "getCoverAtSide"(side: $Direction$Type): $CoverBehavior
public "setCoverAtSide"(coverBehavior: $CoverBehavior$Type, side: $Direction$Type): void
public "scheduleRenderUpdate"(): void
public "scheduleNeighborShapeUpdate"(): void
public "subscribeServerTick"(runnable: $Runnable$Type): $TickableSubscription
public "getFrontFacing"(): $Direction
public "getOffsetTimer"(): long
public "getFieldHolder"(): $ManagedFieldHolder
public "isInValid"(): boolean
public "getItemTransferCap"(side: $Direction$Type, useCoverCapability: boolean): $IItemTransfer
public "getFluidTransferCap"(side: $Direction$Type, useCoverCapability: boolean): $IFluidTransfer
public "onLoad"(): void
public "onNeighborChanged"(block: $Block$Type, fromPos: $BlockPos$Type, isMoving: boolean): void
public "isRemote"(): boolean
public "onUnload"(): void
public static "rayTraceCoverableSide"(coverable: $ICoverable$Type, player: $Player$Type): $Direction
public static "getCoverPlateBox"(side: $Direction$Type, plateThickness: double): $VoxelShape
public "hasCover"(facing: $Direction$Type): boolean
public "placeCoverOnSide"(side: $Direction$Type, itemStack: $ItemStack$Type, coverDefinition: $CoverDefinition$Type, player: $ServerPlayer$Type): boolean
public static "traceCoverSide"(result: $BlockHitResult$Type): $Direction
public static "doesCoverCollide"(side: $Direction$Type, collisionBox: $List$Type<($VoxelShape$Type)>, plateThickness: double): boolean
public "getBlockAppearance"(state: $BlockState$Type, level: $BlockAndTintGetter$Type, pos: $BlockPos$Type, side: $Direction$Type, sourceState: $BlockState$Type, sourcePos: $BlockPos$Type): $BlockState
public static "determineGridSideHit"(result: $BlockHitResult$Type): $Direction
public "addCoverCollisionBoundingBox"(): ($VoxelShape)[]
public "dropAllCovers"(): void
public static "canPlaceCover"(coverDef: $CoverDefinition$Type, coverable: $ICoverable$Type): boolean
public "hasAnyCover"(): boolean
public "removeCover"(side: $Direction$Type, player: $Player$Type): boolean
public "removeCover"(dropItself: boolean, side: $Direction$Type, player: $Player$Type): boolean
public "getCovers"(): $List<($CoverBehavior)>
public "scheduleRender"(fieldName: string, newValue: any, oldValue: any): void
public "subscribeServerTick"(last: $TickableSubscription$Type, runnable: $Runnable$Type): $TickableSubscription
public "markDirty"(name: string): void
public "onPersistedChanged"(ref: $IRef$Type, isDirty: boolean): void
public "onSyncChanged"(ref: $IRef$Type, isDirty: boolean): void
public "addSyncUpdateListener"<T>(name: string, listener: $IFieldUpdateListener$Type<(T)>): $ISubscription
get "level"(): $Level
get "pos"(): $BlockPos
get "syncStorage"(): $FieldManagedStorage
get "coverPlateThickness"(): double
get "frontFacing"(): $Direction
get "offsetTimer"(): long
get "fieldHolder"(): $ManagedFieldHolder
get "inValid"(): boolean
get "remote"(): boolean
get "covers"(): $List<($CoverBehavior)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineCoverContainer$Type = ($MachineCoverContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineCoverContainer_ = $MachineCoverContainer$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/capability/$IOpticalDataAccessHatch" {
import {$IDataAccessHatch, $IDataAccessHatch$Type} from "packages/com/gregtechceu/gtceu/api/capability/$IDataAccessHatch"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$GTRecipe, $GTRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe"

export interface $IOpticalDataAccessHatch extends $IDataAccessHatch {

 "isTransmitter"(): boolean
 "isCreative"(): boolean
 "isRecipeAvailable"(recipe: $GTRecipe$Type): boolean
 "isRecipeAvailable"(arg0: $GTRecipe$Type, arg1: $Collection$Type<($IDataAccessHatch$Type)>): boolean
 "modifyRecipe"(recipe: $GTRecipe$Type): $GTRecipe
}

export namespace $IOpticalDataAccessHatch {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IOpticalDataAccessHatch$Type = ($IOpticalDataAccessHatch);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IOpticalDataAccessHatch_ = $IOpticalDataAccessHatch$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/capability/$IOpticalComputationProvider" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"

export interface $IOpticalComputationProvider {

 "canBridge"(arg0: $Collection$Type<($IOpticalComputationProvider$Type)>): boolean
 "canBridge"(): boolean
 "getMaxCWUt"(arg0: $Collection$Type<($IOpticalComputationProvider$Type)>): integer
 "getMaxCWUt"(): integer
 "requestCWUt"(arg0: integer, arg1: boolean, arg2: $Collection$Type<($IOpticalComputationProvider$Type)>): integer
 "requestCWUt"(cwut: integer, simulate: boolean): integer
}

export namespace $IOpticalComputationProvider {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IOpticalComputationProvider$Type = ($IOpticalComputationProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IOpticalComputationProvider_ = $IOpticalComputationProvider$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/bedrockore/$BedrockOreDefinition$Builder" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$HolderSet, $HolderSet$Type} from "packages/net/minecraft/core/$HolderSet"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Biome, $Biome$Type} from "packages/net/minecraft/world/level/biome/$Biome"
import {$BedrockOreDefinition, $BedrockOreDefinition$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/bedrockore/$BedrockOreDefinition"
import {$IntProvider, $IntProvider$Type} from "packages/net/minecraft/util/valueproviders/$IntProvider"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export class $BedrockOreDefinition$Builder {


public "size"(size: integer): $BedrockOreDefinition$Builder
public "dimensions"(...dimensions: (string)[]): $BedrockOreDefinition$Builder
public "register"(): $BedrockOreDefinition
public "yield"(arg0: $IntProvider$Type): $BedrockOreDefinition$Builder
public "yield"(min: integer, max: integer): $BedrockOreDefinition$Builder
public "copy"(name: $ResourceLocation$Type): $BedrockOreDefinition$Builder
public "weight"(weight: integer): $BedrockOreDefinition$Builder
public "materials"(materials: $List$Type<($Pair$Type<($Material$Type), (integer)>)>): $BedrockOreDefinition$Builder
public "material"(material: $Material$Type, amount: integer): $BedrockOreDefinition$Builder
public "biomes"(weight: integer, biomes: $HolderSet$Type<($Biome$Type)>): $BedrockOreDefinition$Builder
public "biomes"(weight: integer, ...biomes: ($ResourceKey$Type<($Biome$Type)>)[]): $BedrockOreDefinition$Builder
public "biomes"(weight: integer, biomes: $TagKey$Type<($Biome$Type)>): $BedrockOreDefinition$Builder
public "depletedYield"(depletedYield: integer): $BedrockOreDefinition$Builder
public "depletionAmount"(depletionAmount: integer): $BedrockOreDefinition$Builder
public "depletionChance"(depletionChance: integer): $BedrockOreDefinition$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BedrockOreDefinition$Builder$Type = ($BedrockOreDefinition$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BedrockOreDefinition$Builder_ = $BedrockOreDefinition$Builder$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/$ResearchRecipeBuilder" {
import {$GTRecipeBuilder$ResearchRecipeEntry, $GTRecipeBuilder$ResearchRecipeEntry$Type} from "packages/com/gregtechceu/gtceu/data/recipe/builder/$GTRecipeBuilder$ResearchRecipeEntry"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ResearchRecipeBuilder<T extends $ResearchRecipeBuilder<(T)>> {

constructor()

public "build"(): $GTRecipeBuilder$ResearchRecipeEntry
public "getDefaultDataItem"(): $ItemStack
public "dataStack"(dataStack: $ItemStack$Type): T
public "researchId"(researchId: string): T
public "researchStack"(researchStack: $ItemStack$Type): T
public "EUt"(eut: integer): T
get "defaultDataItem"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResearchRecipeBuilder$Type<T> = ($ResearchRecipeBuilder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResearchRecipeBuilder_<T> = $ResearchRecipeBuilder$Type<(T)>;
}}
declare module "packages/com/gregtechceu/gtceu/api/capability/$IPropertyFluidFilter" {
import {$FluidStack, $FluidStack$Type} from "packages/com/lowdragmc/lowdraglib/side/fluid/$FluidStack"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$FluidAttribute, $FluidAttribute$Type} from "packages/com/gregtechceu/gtceu/api/fluids/attribute/$FluidAttribute"
import {$FluidState, $FluidState$Type} from "packages/com/gregtechceu/gtceu/api/fluids/$FluidState"

export interface $IPropertyFluidFilter extends $Predicate<($FluidStack)> {

 "test"(stack: $FluidStack$Type): boolean
 "appendTooltips"(tooltip: $List$Type<($Component$Type)>, showToolsInfo: boolean, showTemperatureInfo: boolean): void
 "getContainedAttributes"(): $Collection<($FluidAttribute)>
 "getMaxFluidTemperature"(): integer
 "setCanContain"(arg0: $FluidAttribute$Type, arg1: boolean): void
 "canContain"(arg0: $FluidAttribute$Type): boolean
 "canContain"(arg0: $FluidState$Type): boolean
 "isPlasmaProof"(): boolean
 "isGasProof"(): boolean
 "isCryoProof"(): boolean
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<($FluidStack)>
 "negate"(): $Predicate<($FluidStack)>
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<($FluidStack)>
}

export namespace $IPropertyFluidFilter {
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<($FluidStack)>
function isEqual<T>(arg0: any): $Predicate<($FluidStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IPropertyFluidFilter$Type = ($IPropertyFluidFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IPropertyFluidFilter_ = $IPropertyFluidFilter$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/gui/fancy/$TitleBarWidget" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IConfigurableWidget, $IConfigurableWidget$Type} from "packages/com/lowdragmc/lowdraglib/gui/editor/configurator/$IConfigurableWidget"
import {$ClickData, $ClickData$Type} from "packages/com/lowdragmc/lowdraglib/gui/util/$ClickData"
import {$List, $List$Type} from "packages/java/util/$List"
import {$WidgetGroup, $WidgetGroup$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$WidgetGroup"
import {$Widget, $Widget$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$Widget"
import {$IFancyUIProvider, $IFancyUIProvider$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$IFancyUIProvider"
import {$Resources, $Resources$Type} from "packages/com/lowdragmc/lowdraglib/gui/editor/data/$Resources"

export class $TitleBarWidget extends $WidgetGroup {
readonly "widgets": $List<($Widget)>

constructor(parentWidth: integer, onBackClicked: $Consumer$Type<($ClickData$Type)>, onMenuClicked: $Consumer$Type<($ClickData$Type)>)

public "updateState"(currentPage: $IFancyUIProvider$Type, showBackButton: boolean, showMenuButton: boolean): void
public static "deserializeNBT"(widget: $IConfigurableWidget$Type, tag: $CompoundTag$Type, resources: $Resources$Type, isProject: boolean): void
public static "serializeNBT"(widget: $IConfigurableWidget$Type, resources: $Resources$Type, isProject: boolean): $CompoundTag
public static "deserializeWrapper"(tag: $CompoundTag$Type): $IConfigurableWidget
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TitleBarWidget$Type = ($TitleBarWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TitleBarWidget_ = $TitleBarWidget$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/data/$GTMedicalConditions" {
import {$MedicalCondition, $MedicalCondition$Type} from "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$MedicalCondition"

export class $GTMedicalConditions {
static readonly "NONE": $MedicalCondition
static readonly "CHEMICAL_BURNS": $MedicalCondition
static readonly "POISON": $MedicalCondition
static readonly "WEAK_POISON": $MedicalCondition
static readonly "IRRITANT": $MedicalCondition
static readonly "NAUSEA": $MedicalCondition
static readonly "CARCINOGEN": $MedicalCondition
static readonly "ASBESTOSIS": $MedicalCondition
static readonly "ARSENICOSIS": $MedicalCondition
static readonly "SILICOSIS": $MedicalCondition
static readonly "BERYLLIOSIS": $MedicalCondition
static readonly "METHANOL_POISONING": $MedicalCondition
static readonly "CARBON_MONOXIDE_POISONING": $MedicalCondition

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTMedicalConditions$Type = ($GTMedicalConditions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTMedicalConditions_ = $GTMedicalConditions$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/blockentity/$IPaintable" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IPaintable {

 "getDefaultPaintingColor"(): integer
 "isPainted"(): boolean
 "getRealColor"(): integer
 "getPaintingColor"(): integer
 "setPaintingColor"(arg0: integer): void
}

export namespace $IPaintable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IPaintable$Type = ($IPaintable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IPaintable_ = $IPaintable$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/$ResearchRecipeBuilder$ScannerRecipeBuilder" {
import {$GTRecipeBuilder$ResearchRecipeEntry, $GTRecipeBuilder$ResearchRecipeEntry$Type} from "packages/com/gregtechceu/gtceu/data/recipe/builder/$GTRecipeBuilder$ResearchRecipeEntry"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResearchRecipeBuilder, $ResearchRecipeBuilder$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$ResearchRecipeBuilder"

export class $ResearchRecipeBuilder$ScannerRecipeBuilder extends $ResearchRecipeBuilder<($ResearchRecipeBuilder$ScannerRecipeBuilder)> {
static readonly "DEFAULT_SCANNER_DURATION": integer
static readonly "DEFAULT_SCANNER_EUT": integer

constructor()

public "build"(): $GTRecipeBuilder$ResearchRecipeEntry
public "duration"(duration: integer): $ResearchRecipeBuilder$ScannerRecipeBuilder
public "getDefaultDataItem"(): $ItemStack
get "defaultDataItem"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResearchRecipeBuilder$ScannerRecipeBuilder$Type = ($ResearchRecipeBuilder$ScannerRecipeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResearchRecipeBuilder$ScannerRecipeBuilder_ = $ResearchRecipeBuilder$ScannerRecipeBuilder$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/capability/$ILaserContainer" {
import {$IEnergyContainer, $IEnergyContainer$Type} from "packages/com/gregtechceu/gtceu/api/capability/$IEnergyContainer"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IEnergyInfoProvider$EnergyInfo, $IEnergyInfoProvider$EnergyInfo$Type} from "packages/com/gregtechceu/gtceu/api/capability/$IEnergyInfoProvider$EnergyInfo"

export interface $ILaserContainer extends $IEnergyContainer {

 "getEnergyStored"(): long
 "getEnergyInfo"(): $IEnergyInfoProvider$EnergyInfo
 "supportsBigIntEnergyValues"(): boolean
 "getEnergyCanBeInserted"(): long
 "getEnergyCapacity"(): long
 "getInputAmperage"(): long
 "getOutputAmperage"(): long
 "changeEnergy"(arg0: long): long
 "addEnergy"(energyToAdd: long): long
 "inputsEnergy"(arg0: $Direction$Type): boolean
 "isOneProbeHidden"(): boolean
 "getInputPerSec"(): long
 "getOutputPerSec"(): long
 "outputsEnergy"(side: $Direction$Type): boolean
 "removeEnergy"(energyToRemove: long): long
 "getOutputVoltage"(): long
 "getInputVoltage"(): long
 "acceptEnergyFromNetwork"(arg0: $Direction$Type, arg1: long, arg2: long): long
}

export namespace $ILaserContainer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ILaserContainer$Type = ($ILaserContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ILaserContainer_ = $ILaserContainer$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/fluids/forge/$GTFluidImpl" {
import {$IntegerProperty, $IntegerProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$IntegerProperty"
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$IForgeFluid, $IForgeFluid$Type} from "packages/net/minecraftforge/common/extensions/$IForgeFluid"
import {$GTFluid, $GTFluid$Type} from "packages/com/gregtechceu/gtceu/api/fluids/$GTFluid"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$FluidType, $FluidType$Type} from "packages/net/minecraftforge/fluids/$FluidType"
import {$FluidState as $FluidState$0, $FluidState$Type as $FluidState$0$Type} from "packages/com/gregtechceu/gtceu/api/fluids/$FluidState"

export class $GTFluidImpl extends $GTFluid implements $IForgeFluid {
static readonly "FALLING": $BooleanProperty
static readonly "LEVEL": $IntegerProperty
static readonly "FLUID_STATE_REGISTRY": $IdMapper<($FluidState)>
readonly "stateDefinition": $StateDefinition<($Fluid), ($FluidState)>

constructor(state: $FluidState$0$Type, stillFluid: $Supplier$Type<(any)>, flowingFluid: $Supplier$Type<(any)>, block: $Supplier$Type<(any)>, bucket: $Supplier$Type<(any)>, burnTime: integer, fluidType: $Supplier$Type<($FluidType$Type)>)

public "getFluidType"(): $FluidType
public "canConvertToSource"(arg0: $FluidState$Type, arg1: $Level$Type, arg2: $BlockPos$Type): boolean
get "fluidType"(): $FluidType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTFluidImpl$Type = ($GTFluidImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTFluidImpl_ = $GTFluidImpl$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/cover/$ConveyorCover" {
import {$DistributionMode, $DistributionMode$Type} from "packages/com/gregtechceu/gtceu/common/cover/data/$DistributionMode"
import {$ICoverable, $ICoverable$Type} from "packages/com/gregtechceu/gtceu/api/capability/$ICoverable"
import {$IUICover, $IUICover$Type} from "packages/com/gregtechceu/gtceu/api/cover/$IUICover"
import {$IItemTransfer, $IItemTransfer$Type} from "packages/com/lowdragmc/lowdraglib/side/item/$IItemTransfer"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CoverDefinition, $CoverDefinition$Type} from "packages/com/gregtechceu/gtceu/api/cover/$CoverDefinition"
import {$FilterHandler, $FilterHandler$Type} from "packages/com/gregtechceu/gtceu/api/cover/filter/$FilterHandler"
import {$Widget, $Widget$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$Widget"
import {$CoverBehavior, $CoverBehavior$Type} from "packages/com/gregtechceu/gtceu/api/cover/$CoverBehavior"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IO, $IO$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IO"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$IControllable, $IControllable$Type} from "packages/com/gregtechceu/gtceu/api/capability/$IControllable"
import {$ManagedFieldHolder, $ManagedFieldHolder$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/field/$ManagedFieldHolder"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemFilter, $ItemFilter$Type} from "packages/com/gregtechceu/gtceu/api/cover/filter/$ItemFilter"
import {$ManualIOMode, $ManualIOMode$Type} from "packages/com/gregtechceu/gtceu/common/cover/data/$ManualIOMode"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ModularUI, $ModularUI$Type} from "packages/com/lowdragmc/lowdraglib/gui/modular/$ModularUI"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $ConveyorCover extends $CoverBehavior implements $IUICover, $IControllable {
static readonly "MANAGED_FIELD_HOLDER": $ManagedFieldHolder
readonly "tier": integer
readonly "maxItemTransferRate": integer
readonly "coverDefinition": $CoverDefinition
readonly "coverHolder": $ICoverable
readonly "attachedSide": $Direction

constructor(definition: $CoverDefinition$Type, coverHolder: $ICoverable$Type, attachedSide: $Direction$Type, tier: integer)

public "onLoad"(): void
public "onNeighborChanged"(block: $Block$Type, fromPos: $BlockPos$Type, isMoving: boolean): void
public "onRemoved"(): void
public "canAttach"(): boolean
public "getFilterHandler"(): $FilterHandler<($ItemStack), ($ItemFilter)>
public "setIo"(io: $IO$Type): void
public "getIo"(): $IO
public "getManualIOMode"(): $ManualIOMode
public "getAdditionalDrops"(): $List<($ItemStack)>
public "setTransferRate"(transferRate: integer): void
public "getTransferRate"(): integer
public "getFieldHolder"(): $ManagedFieldHolder
public "setWorkingEnabled"(isWorkingAllowed: boolean): void
public "isWorkingEnabled"(): boolean
public "getItemTransferCap"(defaultValue: $IItemTransfer$Type): $IItemTransfer
public "createUIWidget"(): $Widget
public "setDistributionMode"(distributionMode: $DistributionMode$Type): void
public "getDistributionMode"(): $DistributionMode
public "isInvalid"(): boolean
public "self"(): $CoverBehavior
public "createUI"(entityPlayer: $Player$Type): $ModularUI
public "markAsDirty"(): void
public "isRemote"(): boolean
get "filterHandler"(): $FilterHandler<($ItemStack), ($ItemFilter)>
set "io"(value: $IO$Type)
get "io"(): $IO
get "manualIOMode"(): $ManualIOMode
get "additionalDrops"(): $List<($ItemStack)>
set "transferRate"(value: integer)
get "transferRate"(): integer
get "fieldHolder"(): $ManagedFieldHolder
set "workingEnabled"(value: boolean)
get "workingEnabled"(): boolean
set "distributionMode"(value: $DistributionMode$Type)
get "distributionMode"(): $DistributionMode
get "invalid"(): boolean
get "remote"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConveyorCover$Type = ($ConveyorCover);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConveyorCover_ = $ConveyorCover$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$PropertyKey$EmptyProperty" {
import {$IMaterialProperty, $IMaterialProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IMaterialProperty"
import {$MaterialProperties, $MaterialProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$MaterialProperties"

export class $PropertyKey$EmptyProperty implements $IMaterialProperty<($PropertyKey$EmptyProperty)> {


public "verifyProperty"(properties: $MaterialProperties$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PropertyKey$EmptyProperty$Type = ($PropertyKey$EmptyProperty);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PropertyKey$EmptyProperty_ = $PropertyKey$EmptyProperty$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pipenet/longdistance/$ILDNetworkPart" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$LongDistancePipeType, $LongDistancePipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/longdistance/$LongDistancePipeType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $ILDNetworkPart {

 "getPipeType"(): $LongDistancePipeType

(world: $LevelAccessor$Type, pos: $BlockPos$Type): $ILDNetworkPart
}

export namespace $ILDNetworkPart {
function tryGet(world: $LevelAccessor$Type, pos: $BlockPos$Type): $ILDNetworkPart
function tryGet(world: $LevelAccessor$Type, pos: $BlockPos$Type, blockState: $BlockState$Type): $ILDNetworkPart
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ILDNetworkPart$Type = ($ILDNetworkPart);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ILDNetworkPart_ = $ILDNetworkPart$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pattern/$MultiblockState" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IO, $IO$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IO"
import {$PatternMatchContext, $PatternMatchContext$Type} from "packages/com/gregtechceu/gtceu/api/pattern/util/$PatternMatchContext"
import {$SimplePredicate, $SimplePredicate$Type} from "packages/com/gregtechceu/gtceu/api/pattern/predicates/$SimplePredicate"
import {$IMultiController, $IMultiController$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/multiblock/$IMultiController"
import {$LongOpenHashSet, $LongOpenHashSet$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongOpenHashSet"
import {$TraceabilityPredicate, $TraceabilityPredicate$Type} from "packages/com/gregtechceu/gtceu/api/pattern/$TraceabilityPredicate"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$PatternError, $PatternError$Type} from "packages/com/gregtechceu/gtceu/api/pattern/error/$PatternError"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MultiblockState {
static readonly "UNLOAD_ERROR": $PatternError
static readonly "UNINIT_ERROR": $PatternError
 "predicate": $TraceabilityPredicate
 "io": $IO
 "error": $PatternError
readonly "world": $Level
readonly "controllerPos": $BlockPos
 "lastController": $IMultiController
 "cache": $LongOpenHashSet

constructor(world: $Level$Type, controllerPos: $BlockPos$Type)

public "setError"(error: $PatternError$Type): void
public "getCache"(): $Collection<($BlockPos)>
public "hasError"(): boolean
public "getPos"(): $BlockPos
public "onBlockStateChanged"(pos: $BlockPos$Type, state: $BlockState$Type): void
public "getBlockState"(): $BlockState
public "getController"(): $IMultiController
public "getWorld"(): $Level
public "isPosInCache"(pos: $BlockPos$Type): boolean
public "getTileEntity"(): $BlockEntity
public "getLayerCount"(): $Map<($SimplePredicate), (integer)>
public "getGlobalCount"(): $Map<($SimplePredicate), (integer)>
public "addPosCache"(pos: $BlockPos$Type): void
public "setNeededFlip"(neededFlip: boolean): void
public "getOffsetState"(face: $Direction$Type): $BlockState
public "getMatchContext"(): $PatternMatchContext
public "isNeededFlip"(): boolean
set "error"(value: $PatternError$Type)
get "cache"(): $Collection<($BlockPos)>
get "pos"(): $BlockPos
get "blockState"(): $BlockState
get "controller"(): $IMultiController
get "world"(): $Level
get "tileEntity"(): $BlockEntity
get "layerCount"(): $Map<($SimplePredicate), (integer)>
get "globalCount"(): $Map<($SimplePredicate), (integer)>
set "neededFlip"(value: boolean)
get "matchContext"(): $PatternMatchContext
get "neededFlip"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiblockState$Type = ($MultiblockState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiblockState_ = $MultiblockState$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/$KineticMachineBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$KineticMachineDefinition, $KineticMachineDefinition$Type} from "packages/com/gregtechceu/gtceu/common/machine/$KineticMachineDefinition"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$IRotate$SpeedLevel, $IRotate$SpeedLevel$Type} from "packages/com/simibubi/create/content/kinetics/base/$IRotate$SpeedLevel"
import {$MachineDefinition, $MachineDefinition$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MachineDefinition"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$RotationState, $RotationState$Type} from "packages/com/gregtechceu/gtceu/api/data/$RotationState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IRotate, $IRotate$Type} from "packages/com/simibubi/create/content/kinetics/base/$IRotate"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$MetaMachineBlock, $MetaMachineBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$MetaMachineBlock"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$Direction$Axis, $Direction$Axis$Type} from "packages/net/minecraft/core/$Direction$Axis"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export class $KineticMachineBlock extends $MetaMachineBlock implements $IRotate {
readonly "definition": $MachineDefinition
readonly "rotationState": $RotationState
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, definition: $KineticMachineDefinition$Type)

public "hasShaftTowards"(world: $LevelReader$Type, pos: $BlockPos$Type, state: $BlockState$Type, face: $Direction$Type): boolean
public "getTicker"<T extends $BlockEntity>(level: $Level$Type, state: $BlockState$Type, blockEntityType: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "updateIndirectNeighbourShapes"(stateIn: $BlockState$Type, worldIn: $LevelAccessor$Type, pos: $BlockPos$Type, flags: integer, count: integer): void
public "onPlace"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, oldState: $BlockState$Type, isMoving: boolean): void
public "rotate"(pState: $BlockState$Type, pRotation: $Rotation$Type): $BlockState
public "areStatesKineticallyEquivalent"(oldState: $BlockState$Type, newState: $BlockState$Type): boolean
public "getRotationAxis"(state: $BlockState$Type): $Direction$Axis
public "getRotationFacing"(state: $BlockState$Type): $Direction
public "hideStressImpact"(): boolean
public "showCapacityWithAnnotation"(): boolean
public "getMinimumRequiredSpeedLevel"(): $IRotate$SpeedLevel
public "onWrenched"(arg0: $BlockState$Type, arg1: $UseOnContext$Type): $InteractionResult
public "onSneakWrenched"(arg0: $BlockState$Type, arg1: $UseOnContext$Type): $InteractionResult
public "playRemoveSound"(arg0: $Level$Type, arg1: $BlockPos$Type): void
public "playRotateSound"(arg0: $Level$Type, arg1: $BlockPos$Type): void
public "getRotatedBlockState"(arg0: $BlockState$Type, arg1: $Direction$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$Type, arg1: $UseOnContext$Type): $BlockState
public static "colorTinted"(blockState: $BlockState$Type, level: $BlockAndTintGetter$Type, pos: $BlockPos$Type, index: integer): integer
get "minimumRequiredSpeedLevel"(): $IRotate$SpeedLevel
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KineticMachineBlock$Type = ($KineticMachineBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KineticMachineBlock_ = $KineticMachineBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/core/mixins/$ShapedRecipeAccessor" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $ShapedRecipeAccessor {

 "getResult"(): $ItemStack

(): $ItemStack
}

export namespace $ShapedRecipeAccessor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapedRecipeAccessor$Type = ($ShapedRecipeAccessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShapedRecipeAccessor_ = $ShapedRecipeAccessor$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$Symptom$ConfiguredSymptom" {
import {$Symptom, $Symptom$Type} from "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$Symptom"

export class $Symptom$ConfiguredSymptom {
readonly "symptom": $Symptom
readonly "stages": integer
readonly "progressionThreshold": float
readonly "relativeHarshness": float

constructor(symptom: $Symptom$Type, progressionThreshold: float)
constructor(symptom: $Symptom$Type, stages: integer)
constructor(symptom: $Symptom$Type)
constructor(symptom: $Symptom$Type, stages: integer, progressionThreshold: float)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Symptom$ConfiguredSymptom$Type = ($Symptom$ConfiguredSymptom);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Symptom$ConfiguredSymptom_ = $Symptom$ConfiguredSymptom$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/gui/fancy/$TabsWidget" {
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Widget, $Widget$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$Widget"
import {$IFancyUIProvider, $IFancyUIProvider$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$IFancyUIProvider"
import {$IGuiTexture, $IGuiTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$IGuiTexture"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $TabsWidget extends $Widget {

constructor(onTabClick: $Consumer$Type<($IFancyUIProvider$Type)>)
constructor(onTabClick: $Consumer$Type<($IFancyUIProvider$Type)>, x: integer, y: integer, width: integer, height: integer)

public "getOffset"(): integer
public "mouseClicked"(mouseX: double, mouseY: double, button: integer): boolean
public "handleClientAction"(id: integer, buffer: $FriendlyByteBuf$Type): void
public "drawInForeground"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
public "drawInBackground"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
public "mouseWheelMove"(mouseX: double, mouseY: double, wheelDelta: double): boolean
public "drawTab"(tab: $IFancyUIProvider$Type, graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, x: integer, y: integer, width: integer, height: integer, hoveredTab: $IFancyUIProvider$Type): void
public "selectTab"(selectedTab: $IFancyUIProvider$Type): void
public "clearSubTabs"(): void
public "setMainTab"(mainTab: $IFancyUIProvider$Type): void
public "attachSubTab"(subTab: $IFancyUIProvider$Type): void
public "getSubTabs"(): $List<($IFancyUIProvider)>
public "setTabPressedTexture"(tabPressedTexture: $IGuiTexture$Type): void
public "getRightButtonHoverTexture"(): $IGuiTexture
public "getRightButtonTexture"(): $IGuiTexture
public "getTabPressedTexture"(): $IGuiTexture
public "setLeftButtonHoverTexture"(leftButtonHoverTexture: $IGuiTexture$Type): void
public "getLeftButtonTexture"(): $IGuiTexture
public "getLeftButtonHoverTexture"(): $IGuiTexture
public "setLeftButtonTexture"(leftButtonTexture: $IGuiTexture$Type): void
public "setRightButtonHoverTexture"(rightButtonHoverTexture: $IGuiTexture$Type): void
public "setRightButtonTexture"(rightButtonTexture: $IGuiTexture$Type): void
public "hasButton"(): boolean
public "getSubTabsWidth"(): integer
public "getHoveredTab"(mouseX: double, mouseY: double): $IFancyUIProvider
public "isHoverLeftButton"(mouseX: double, mouseY: double): boolean
public "getTabHoverTexture"(): $IGuiTexture
public "isHoverRightButton"(mouseX: double, mouseY: double): boolean
public "getTabTexture"(): $IGuiTexture
public "setOnTabSwitch"(onTabSwitch: $BiConsumer$Type<($IFancyUIProvider$Type), ($IFancyUIProvider$Type)>): void
public "setTabHoverTexture"(tabHoverTexture: $IGuiTexture$Type): void
public "getMainTab"(): $IFancyUIProvider
public "getOnTabClick"(): $Consumer<($IFancyUIProvider)>
public "getSelectedTab"(): $IFancyUIProvider
public "setTabTexture"(tabTexture: $IGuiTexture$Type): void
public "getOnTabSwitch"(): $BiConsumer<($IFancyUIProvider), ($IFancyUIProvider)>
get "offset"(): integer
set "mainTab"(value: $IFancyUIProvider$Type)
get "subTabs"(): $List<($IFancyUIProvider)>
set "tabPressedTexture"(value: $IGuiTexture$Type)
get "rightButtonHoverTexture"(): $IGuiTexture
get "rightButtonTexture"(): $IGuiTexture
get "tabPressedTexture"(): $IGuiTexture
set "leftButtonHoverTexture"(value: $IGuiTexture$Type)
get "leftButtonTexture"(): $IGuiTexture
get "leftButtonHoverTexture"(): $IGuiTexture
set "leftButtonTexture"(value: $IGuiTexture$Type)
set "rightButtonHoverTexture"(value: $IGuiTexture$Type)
set "rightButtonTexture"(value: $IGuiTexture$Type)
get "subTabsWidth"(): integer
get "tabHoverTexture"(): $IGuiTexture
get "tabTexture"(): $IGuiTexture
set "onTabSwitch"(value: $BiConsumer$Type<($IFancyUIProvider$Type), ($IFancyUIProvider$Type)>)
set "tabHoverTexture"(value: $IGuiTexture$Type)
get "mainTab"(): $IFancyUIProvider
get "onTabClick"(): $Consumer<($IFancyUIProvider)>
get "selectedTab"(): $IFancyUIProvider
set "tabTexture"(value: $IGuiTexture$Type)
get "onTabSwitch"(): $BiConsumer<($IFancyUIProvider), ($IFancyUIProvider)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TabsWidget$Type = ($TabsWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TabsWidget_ = $TabsWidget$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/fluids/attribute/$FluidAttributes" {
import {$FluidAttribute, $FluidAttribute$Type} from "packages/com/gregtechceu/gtceu/api/fluids/attribute/$FluidAttribute"

export class $FluidAttributes {
static readonly "ACID": $FluidAttribute


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidAttributes$Type = ($FluidAttributes);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidAttributes_ = $FluidAttributes$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/$MaterialPipeBlockItem" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$IRenderer, $IRenderer$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IRenderer"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$ItemColor, $ItemColor$Type} from "packages/net/minecraft/client/color/item/$ItemColor"
import {$FoodProperties, $FoodProperties$Type} from "packages/net/minecraft/world/food/$FoodProperties"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$MaterialPipeBlock, $MaterialPipeBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$MaterialPipeBlock"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$Type} from "packages/net/mehvahdjukaar/moonlight/api/item/additional_placements/$AdditionalItemPlacement"
import {$IItemRendererProvider, $IItemRendererProvider$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IItemRendererProvider"
import {$PipeBlockItem, $PipeBlockItem$Type} from "packages/com/gregtechceu/gtceu/api/item/$PipeBlockItem"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MaterialPipeBlockItem extends $PipeBlockItem implements $IItemRendererProvider {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "descriptionId": string
 "foodProperties": $FoodProperties
readonly "canRepair": boolean
 "renderProperties": any
 "moonlight$clientAnimationProvider": any

constructor(block: $MaterialPipeBlock$Type<(any), (any), (any)>, properties: $Item$Properties$Type)

public "getBlock"(): $MaterialPipeBlock<(any), (any), (any)>
public "getName"(stack: $ItemStack$Type): $Component
public static "tintColor"(): $ItemColor
public "getDescription"(): $Component
public "getRenderer"(stack: $ItemStack$Type): $IRenderer
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public "moonlight$addAdditionalBehavior"(arg0: $AdditionalItemPlacement$Type): void
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
get "block"(): $MaterialPipeBlock<(any), (any), (any)>
get "description"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialPipeBlockItem$Type = ($MaterialPipeBlockItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialPipeBlockItem_ = $MaterialPipeBlockItem$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$BlastProperty$GasTier" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $BlastProperty$GasTier extends $Enum<($BlastProperty$GasTier)> {
static readonly "LOW": $BlastProperty$GasTier
static readonly "MID": $BlastProperty$GasTier
static readonly "HIGH": $BlastProperty$GasTier
static readonly "HIGHER": $BlastProperty$GasTier
static readonly "HIGHEST": $BlastProperty$GasTier
static readonly "VALUES": ($BlastProperty$GasTier)[]


public static "values"(): ($BlastProperty$GasTier)[]
public static "valueOf"(name: string): $BlastProperty$GasTier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlastProperty$GasTier$Type = (("high") | ("low") | ("highest") | ("mid") | ("higher")) | ($BlastProperty$GasTier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlastProperty$GasTier_ = $BlastProperty$GasTier$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$Symptom" {
import {$Symptom$Effect, $Symptom$Effect$Type} from "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$Symptom$Effect"
import {$MedicalConditionTracker, $MedicalConditionTracker$Type} from "packages/com/gregtechceu/gtceu/common/capability/$MedicalConditionTracker"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$Symptom$ConfiguredSymptom, $Symptom$ConfiguredSymptom$Type} from "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$Symptom$ConfiguredSymptom"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$MedicalCondition, $MedicalCondition$Type} from "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$MedicalCondition"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $Symptom {
static readonly "SYMPTOM_HEALTH_DEBUFF_UUID": $UUID
static readonly "SYMPTOM_ATTACK_SPEED_DEBUFF_UUID": $UUID
static readonly "SYMPTOM_WEAKNESS_UUID": $UUID
static readonly "SYMPTOM_SLOWNESS_UUID": $UUID
static readonly "DEATH": $Symptom
static readonly "RANDOM_DAMAGE": $Symptom
static readonly "HEALTH_DEBUFF": $Symptom
static readonly "ATTACK_SPEED_DEBUFF": $Symptom
static readonly "WEAKNESS": $Symptom
static readonly "SLOWNESS": $Symptom
static readonly "AIR_SUPPLY_DEBUFF": $Symptom
static readonly "BLINDNESS": $Symptom
static readonly "NAUSEA": $Symptom
static readonly "MINING_FATIGUE": $Symptom
static readonly "WITHER": $Symptom
static readonly "WEAK_POISONING": $Symptom
static readonly "POISONING": $Symptom
static readonly "HUNGER": $Symptom
readonly "name": string
readonly "defaultStages": integer
readonly "defaultProgressionThreshold": float

constructor(name: string, defaultStages: integer, defaultProgressionThreshold: float, mobEffect: $MobEffect$Type, amplifierMultiplier: integer)
constructor(name: string, defaultStages: integer, defaultProgressionThreshold: float, mobEffect: $Supplier$Type<($MobEffect$Type)>, amplifierMultiplier: integer)
constructor(name: string, defaultStages: integer, defaultProgressionThreshold: float, mobEffect: $MobEffect$Type)
constructor(name: string, defaultStages: integer, defaultProgressionThreshold: float, mobEffect: $Supplier$Type<($MobEffect$Type)>)
constructor(name: string, defaultStages: integer, defaultProgressionThreshold: float, progressionEffect: $Symptom$Effect$Type, tickEffect: $Symptom$Effect$Type)
constructor(name: string, defaultStages: integer, defaultProgressionThreshold: float, progressionEffect: $Symptom$Effect$Type)
constructor(name: string, defaultStages: integer, defaultProgressionThreshold: float, multiplier: float, attribute: $Attribute$Type, uuid: $UUID$Type)

public "tick"(subject: $MedicalConditionTracker$Type, condition: $MedicalCondition$Type, symptom: $Symptom$ConfiguredSymptom$Type, modifier: integer): void
public "applyProgression"(subject: $MedicalConditionTracker$Type, condition: $MedicalCondition$Type, symptom: $Symptom$ConfiguredSymptom$Type, modifier: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Symptom$Type = ($Symptom);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Symptom_ = $Symptom$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/fluids/forge/$GTFluidImpl$Flowing" {
import {$IntegerProperty, $IntegerProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$IntegerProperty"
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$GTFluidImpl, $GTFluidImpl$Type} from "packages/com/gregtechceu/gtceu/api/fluids/forge/$GTFluidImpl"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$FluidType, $FluidType$Type} from "packages/net/minecraftforge/fluids/$FluidType"
import {$FluidState as $FluidState$0, $FluidState$Type as $FluidState$0$Type} from "packages/com/gregtechceu/gtceu/api/fluids/$FluidState"

export class $GTFluidImpl$Flowing extends $GTFluidImpl {
static readonly "FALLING": $BooleanProperty
static readonly "LEVEL": $IntegerProperty
static readonly "FLUID_STATE_REGISTRY": $IdMapper<($FluidState)>
readonly "stateDefinition": $StateDefinition<($Fluid), ($FluidState)>

constructor(state: $FluidState$0$Type, stillFluid: $Supplier$Type<(any)>, flowingFluid: $Supplier$Type<(any)>, block: $Supplier$Type<(any)>, bucket: $Supplier$Type<(any)>, burnTime: integer, fluidType: $Supplier$Type<($FluidType$Type)>)

public "isSource"(state: $FluidState$Type): boolean
public "getAmount"(state: $FluidState$Type): integer
public "canConvertToSource"(arg0: $FluidState$Type, arg1: $Level$Type, arg2: $BlockPos$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTFluidImpl$Flowing$Type = ($GTFluidImpl$Flowing);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTFluidImpl$Flowing_ = $GTFluidImpl$Flowing$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/fluids/$GTFluid" {
import {$IntegerProperty, $IntegerProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$IntegerProperty"
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FluidAttribute, $FluidAttribute$Type} from "packages/com/gregtechceu/gtceu/api/fluids/attribute/$FluidAttribute"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$FlowingFluid, $FlowingFluid$Type} from "packages/net/minecraft/world/level/material/$FlowingFluid"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$IAttributedFluid, $IAttributedFluid$Type} from "packages/com/gregtechceu/gtceu/api/fluids/attribute/$IAttributedFluid"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$FluidState as $FluidState$0, $FluidState$Type as $FluidState$0$Type} from "packages/com/gregtechceu/gtceu/api/fluids/$FluidState"

export class $GTFluid extends $FlowingFluid implements $IAttributedFluid {
static readonly "FALLING": $BooleanProperty
static readonly "LEVEL": $IntegerProperty
static readonly "FLUID_STATE_REGISTRY": $IdMapper<($FluidState)>
readonly "stateDefinition": $StateDefinition<($Fluid), ($FluidState)>

constructor(state: $FluidState$0$Type, stillFluid: $Supplier$Type<(any)>, flowingFluid: $Supplier$Type<(any)>, block: $Supplier$Type<(any)>, bucket: $Supplier$Type<(any)>, burnTime: integer)

public "getState"(): $FluidState$0
public "getAttributes"(): $Collection<($FluidAttribute)>
public "addAttribute"(attribute: $FluidAttribute$Type): void
public "getBurnTime"(): integer
public "getBucket"(): $Item
public "getTickDelay"(level: $LevelReader$Type): integer
public "isSame"(fluid: $Fluid$Type): boolean
public "getFlowing"(): $Fluid
public "getSource"(): $Fluid
get "state"(): $FluidState$0
get "attributes"(): $Collection<($FluidAttribute)>
get "burnTime"(): integer
get "bucket"(): $Item
get "flowing"(): $Fluid
get "source"(): $Fluid
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTFluid$Type = ($GTFluid);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTFluid_ = $GTFluid$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/$LampBlock" {
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$DyeColor, $DyeColor$Type} from "packages/net/minecraft/world/item/$DyeColor"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IRenderer, $IRenderer$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IRenderer"
import {$IBlockRendererProvider, $IBlockRendererProvider$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IBlockRendererProvider"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$LootParams$Builder, $LootParams$Builder$Type} from "packages/net/minecraft/world/level/storage/loot/$LootParams$Builder"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export class $LampBlock extends $Block implements $IBlockRendererProvider {
static readonly "BLOOM": $BooleanProperty
static readonly "LIGHT": $BooleanProperty
static readonly "INVERTED": $BooleanProperty
static readonly "POWERED": $BooleanProperty
static readonly "TAG_INVERTED": string
static readonly "TAG_BLOOM": string
static readonly "TAG_LIT": string
static readonly "BLOOM_FLAG": integer
static readonly "LIGHT_FLAG": integer
static readonly "INVERTED_FLAG": integer
static readonly "POWERED_FLAG": integer
readonly "color": $DyeColor
readonly "bordered": boolean
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, color: $DyeColor$Type, bordered: boolean)

public "appendHoverText"(stack: $ItemStack$Type, level: $BlockGetter$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "neighborChanged"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, neighborBlock: $Block$Type, neighborPos: $BlockPos$Type, movedByPiston: boolean): void
public "onPlace"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, oldState: $BlockState$Type, movedByPiston: boolean): void
public "getDrops"(state: $BlockState$Type, params: $LootParams$Builder$Type): $List<($ItemStack)>
public "tick"(state: $BlockState$Type, level: $ServerLevel$Type, pos: $BlockPos$Type, random: $RandomSource$Type): void
public "isInverted"(state: $BlockState$Type): boolean
public "getRenderer"(state: $BlockState$Type): $IRenderer
public "getCloneItemStack"(state: $BlockState$Type, target: $HitResult$Type, level: $BlockGetter$Type, pos: $BlockPos$Type, player: $Player$Type): $ItemStack
public "getLightEmission"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type): integer
public "isLightEnabled"(state: $BlockState$Type): boolean
public "isBloomEnabled"(state: $BlockState$Type): boolean
public "getTagFromState"(state: $BlockState$Type): $CompoundTag
public "getStackFromIndex"(i: integer): $ItemStack
public static "isLightActive"(state: $BlockState$Type): boolean
public "getLightMap"(world: $BlockAndTintGetter$Type, state: $BlockState$Type, pos: $BlockPos$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LampBlock$Type = ($LampBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LampBlock_ = $LampBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/core/mixins/$IHolderReferenceAccessor" {
import {$Holder$Kind, $Holder$Kind$Type} from "packages/net/minecraft/core/$Holder$Kind"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$ITag, $ITag$Type} from "packages/net/minecraftforge/registries/tags/$ITag"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$HolderOwner, $HolderOwner$Type} from "packages/net/minecraft/core/$HolderOwner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export interface $IHolderReferenceAccessor<T> extends $Holder<(T)> {

 "get"(): T
 "canSerializeIn"(arg0: $HolderOwner$Type<(T)>): boolean
 "isBound"(): boolean
 "kind"(): $Holder$Kind
 "tags"(): $Stream<($TagKey<(T)>)>
 "getTagKeys"(): $Stream<($TagKey<(T)>)>
 "unwrap"(): $Either<($ResourceKey<(T)>), (T)>
 "is"(arg0: $ResourceLocation$Type): boolean
 "is"(arg0: $ResourceKey$Type<(T)>): boolean
 "is"(arg0: $Predicate$Type<($ResourceKey$Type<(T)>)>): boolean
 "containsTag"(arg0: $TagKey$Type<(T)>): boolean
 "is"(arg0: $TagKey$Type<(T)>): boolean
 "value"(): T
 "unwrapKey"(): $Optional<($ResourceKey<(T)>)>
 "containsTag"(arg0: $ITag$Type<(T)>): boolean
}

export namespace $IHolderReferenceAccessor {
function direct<T>(arg0: T): $Holder<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IHolderReferenceAccessor$Type<T> = ($IHolderReferenceAccessor<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IHolderReferenceAccessor_<T> = $IHolderReferenceAccessor$Type<(T)>;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/info/$MaterialIconType" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$MaterialIconSet, $MaterialIconSet$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/info/$MaterialIconSet"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MaterialIconType extends $Record {
static readonly "ICON_TYPES": $Map<(string), ($MaterialIconType)>
static readonly "dustTiny": $MaterialIconType
static readonly "dustSmall": $MaterialIconType
static readonly "dust": $MaterialIconType
static readonly "dustImpure": $MaterialIconType
static readonly "dustPure": $MaterialIconType
static readonly "rawOre": $MaterialIconType
static readonly "rawOreBlock": $MaterialIconType
static readonly "crushed": $MaterialIconType
static readonly "crushedPurified": $MaterialIconType
static readonly "crushedRefined": $MaterialIconType
static readonly "gem": $MaterialIconType
static readonly "gemChipped": $MaterialIconType
static readonly "gemFlawed": $MaterialIconType
static readonly "gemFlawless": $MaterialIconType
static readonly "gemExquisite": $MaterialIconType
static readonly "nugget": $MaterialIconType
static readonly "ingot": $MaterialIconType
static readonly "ingotHot": $MaterialIconType
static readonly "ingotDouble": $MaterialIconType
static readonly "ingotTriple": $MaterialIconType
static readonly "ingotQuadruple": $MaterialIconType
static readonly "ingotQuintuple": $MaterialIconType
static readonly "plate": $MaterialIconType
static readonly "plateDouble": $MaterialIconType
static readonly "plateTriple": $MaterialIconType
static readonly "plateQuadruple": $MaterialIconType
static readonly "plateQuintuple": $MaterialIconType
static readonly "plateDense": $MaterialIconType
static readonly "stick": $MaterialIconType
static readonly "lens": $MaterialIconType
static readonly "round": $MaterialIconType
static readonly "bolt": $MaterialIconType
static readonly "screw": $MaterialIconType
static readonly "ring": $MaterialIconType
static readonly "wireFine": $MaterialIconType
static readonly "gearSmall": $MaterialIconType
static readonly "rotor": $MaterialIconType
static readonly "stickLong": $MaterialIconType
static readonly "springSmall": $MaterialIconType
static readonly "spring": $MaterialIconType
static readonly "gear": $MaterialIconType
static readonly "foil": $MaterialIconType
static readonly "toolHeadSword": $MaterialIconType
static readonly "toolHeadPickaxe": $MaterialIconType
static readonly "toolHeadShovel": $MaterialIconType
static readonly "toolHeadAxe": $MaterialIconType
static readonly "toolHeadHoe": $MaterialIconType
static readonly "toolHeadHammer": $MaterialIconType
static readonly "toolHeadFile": $MaterialIconType
static readonly "toolHeadSaw": $MaterialIconType
static readonly "toolHeadBuzzSaw": $MaterialIconType
static readonly "toolHeadDrill": $MaterialIconType
static readonly "toolHeadChainsaw": $MaterialIconType
static readonly "toolHeadScythe": $MaterialIconType
static readonly "toolHeadScrewdriver": $MaterialIconType
static readonly "toolHeadWrench": $MaterialIconType
static readonly "turbineBlade": $MaterialIconType
static readonly "liquid": $MaterialIconType
static readonly "gas": $MaterialIconType
static readonly "plasma": $MaterialIconType
static readonly "molten": $MaterialIconType
static readonly "block": $MaterialIconType
static readonly "ore": $MaterialIconType
static readonly "oreSmall": $MaterialIconType
static readonly "frameGt": $MaterialIconType
static readonly "wire": $MaterialIconType
static readonly "seed": $MaterialIconType
static readonly "crop": $MaterialIconType
static readonly "essence": $MaterialIconType

constructor(name: string)

public "name"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "init"(): void
public static "getByName"(name: string): $MaterialIconType
public "getBlockTexturePath"(materialIconSet: $MaterialIconSet$Type, doReadCache: boolean): $ResourceLocation
public "getBlockTexturePath"(materialIconSet: $MaterialIconSet$Type, suffix: string, doReadCache: boolean): $ResourceLocation
public "getItemModelPath"(materialIconSet: $MaterialIconSet$Type, doReadCache: boolean): $ResourceLocation
public "getItemTexturePath"(materialIconSet: $MaterialIconSet$Type, doReadCache: boolean): $ResourceLocation
public "getBlockModelPath"(materialIconSet: $MaterialIconSet$Type, doReadCache: boolean): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialIconType$Type = ($MaterialIconType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialIconType_ = $MaterialIconType$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/cable/$LevelEnergyNet" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$WireProperties, $WireProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$WireProperties"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$EnergyNet, $EnergyNet$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/cable/$EnergyNet"
import {$LevelPipeNet, $LevelPipeNet$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$LevelPipeNet"

export class $LevelEnergyNet extends $LevelPipeNet<($WireProperties), ($EnergyNet)> {

constructor(serverLevel: $ServerLevel$Type, tag: $CompoundTag$Type)
constructor(serverLevel: $ServerLevel$Type)

public static "getOrCreate"(serverLevel: $ServerLevel$Type): $LevelEnergyNet
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelEnergyNet$Type = ($LevelEnergyNet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LevelEnergyNet_ = $LevelEnergyNet$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/forge/$GTBucketItem" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BucketItem, $BucketItem$Type} from "packages/net/minecraft/world/item/$BucketItem"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$FoodProperties, $FoodProperties$Type} from "packages/net/minecraft/world/food/$FoodProperties"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GTBucketItem extends $BucketItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "descriptionId": string
 "foodProperties": $FoodProperties
readonly "canRepair": boolean
 "renderProperties": any
 "moonlight$clientAnimationProvider": any

constructor(fluid: $Supplier$Type<(any)>, properties: $Item$Properties$Type, material: $Material$Type, langKey: string)

public static "color"(itemStack: $ItemStack$Type, index: integer): integer
public "getName"(stack: $ItemStack$Type): $Component
public "getDescription"(): $Component
public "getBurnTime"(itemStack: $ItemStack$Type, recipeType: $RecipeType$Type<(any)>): integer
public "emptyContents"(pPlayer: $Player$Type, pLevel: $Level$Type, pPos: $BlockPos$Type, pResult: $BlockHitResult$Type, container: $ItemStack$Type): boolean
public "getDescriptionId"(): string
public "initCapabilities"(stack: $ItemStack$Type, nbt: $CompoundTag$Type): $ICapabilityProvider
get "description"(): $Component
get "descriptionId"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTBucketItem$Type = ($GTBucketItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTBucketItem_ = $GTBucketItem$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/block/$IFilterType" {
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$Type} from "packages/net/minecraft/util/$StringRepresentable$EnumCodec"
import {$CleanroomType, $CleanroomType$Type} from "packages/com/gregtechceu/gtceu/api/machine/multiblock/$CleanroomType"
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export interface $IFilterType extends $StringRepresentable {

 "getCleanroomType"(): $CleanroomType
 "getSerializedName"(): string
}

export namespace $IFilterType {
function fromEnum<E>(arg0: $Supplier$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
function fromEnumWithMapping<E>(arg0: $Supplier$Type<((E)[])>, arg1: $Function$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
function keys(arg0: ($StringRepresentable$Type)[]): $Keyable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFilterType$Type = ($IFilterType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFilterType_ = $IFilterType$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/bedrockfluid/$BedrockFluidDefinition$Builder" {
import {$HolderSet, $HolderSet$Type} from "packages/net/minecraft/core/$HolderSet"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BedrockFluidDefinition, $BedrockFluidDefinition$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/bedrockfluid/$BedrockFluidDefinition"
import {$Biome, $Biome$Type} from "packages/net/minecraft/world/level/biome/$Biome"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export class $BedrockFluidDefinition$Builder {


public "dimensions"(...dimensions: (string)[]): $BedrockFluidDefinition$Builder
public "register"(): $BedrockFluidDefinition
public "yield"(min: integer, max: integer): $BedrockFluidDefinition$Builder
public "copy"(name: $ResourceLocation$Type): $BedrockFluidDefinition$Builder
public "weight"(weight: integer): $BedrockFluidDefinition$Builder
public "fluid"(fluid: $Supplier$Type<($Fluid$Type)>): $BedrockFluidDefinition$Builder
public "biomes"(weight: integer, biomes: $TagKey$Type<($Biome$Type)>): $BedrockFluidDefinition$Builder
public "biomes"(weight: integer, ...biomes: ($ResourceKey$Type<($Biome$Type)>)[]): $BedrockFluidDefinition$Builder
public "biomes"(weight: integer, biomes: $HolderSet$Type<($Biome$Type)>): $BedrockFluidDefinition$Builder
public "depletedYield"(depletedYield: integer): $BedrockFluidDefinition$Builder
public "minimumYield"(minimumYield: integer): $BedrockFluidDefinition$Builder
public "maximumYield"(maximumYield: integer): $BedrockFluidDefinition$Builder
public "depletionAmount"(depletionAmount: integer): $BedrockFluidDefinition$Builder
public "depletionChance"(depletionChance: integer): $BedrockFluidDefinition$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BedrockFluidDefinition$Builder$Type = ($BedrockFluidDefinition$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BedrockFluidDefinition$Builder_ = $BedrockFluidDefinition$Builder$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/gui/fancy/$ConfiguratorPanel$Tab" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IConfigurableWidget, $IConfigurableWidget$Type} from "packages/com/lowdragmc/lowdraglib/gui/editor/configurator/$IConfigurableWidget"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$IFancyConfigurator, $IFancyConfigurator$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$IFancyConfigurator"
import {$Size, $Size$Type} from "packages/com/lowdragmc/lowdraglib/utils/$Size"
import {$List, $List$Type} from "packages/java/util/$List"
import {$WidgetGroup, $WidgetGroup$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$WidgetGroup"
import {$Widget, $Widget$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$Widget"
import {$ConfiguratorPanel, $ConfiguratorPanel$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$ConfiguratorPanel"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$Resources, $Resources$Type} from "packages/com/lowdragmc/lowdraglib/gui/editor/data/$Resources"

export class $ConfiguratorPanel$Tab extends $WidgetGroup {
readonly "widgets": $List<($Widget)>

constructor(this$0: $ConfiguratorPanel$Type, configurator: $IFancyConfigurator$Type)

public "setSize"(size: $Size$Type): void
public "detectAndSendChanges"(): void
public "writeInitialData"(buffer: $FriendlyByteBuf$Type): void
public "readInitialData"(buffer: $FriendlyByteBuf$Type): void
public "mouseClicked"(mouseX: double, mouseY: double, button: integer): boolean
public "mouseReleased"(mouseX: double, mouseY: double, button: integer): boolean
public "mouseMoved"(mouseX: double, mouseY: double): boolean
public "mouseDragged"(mouseX: double, mouseY: double, button: integer, dragX: double, dragY: double): boolean
public "drawInForeground"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
public "readUpdateInfo"(id: integer, buffer: $FriendlyByteBuf$Type): void
public "drawInBackground"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
public "mouseWheelMove"(mouseX: double, mouseY: double, wheelDelta: double): boolean
public static "deserializeNBT"(widget: $IConfigurableWidget$Type, tag: $CompoundTag$Type, resources: $Resources$Type, isProject: boolean): void
public static "serializeNBT"(widget: $IConfigurableWidget$Type, resources: $Resources$Type, isProject: boolean): $CompoundTag
public static "deserializeWrapper"(tag: $CompoundTag$Type): $IConfigurableWidget
set "size"(value: $Size$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfiguratorPanel$Tab$Type = ($ConfiguratorPanel$Tab);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfiguratorPanel$Tab_ = $ConfiguratorPanel$Tab$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/$GTCeilingHangingSignBlock" {
import {$IntegerProperty, $IntegerProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$IntegerProperty"
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$WoodType, $WoodType$Type} from "packages/net/minecraft/world/level/block/state/properties/$WoodType"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$CeilingHangingSignBlock, $CeilingHangingSignBlock$Type} from "packages/net/minecraft/world/level/block/$CeilingHangingSignBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $GTCeilingHangingSignBlock extends $CeilingHangingSignBlock {
static readonly "ROTATION": $IntegerProperty
static readonly "ATTACHED": $BooleanProperty
static readonly "AABB_OFFSET": float
static readonly "SHAPE": $VoxelShape
static readonly "WATERLOGGED": $BooleanProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, type: $WoodType$Type)

public "getTicker"<T extends $BlockEntity>(level: $Level$Type, state: $BlockState$Type, blockEntityType: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(pos: $BlockPos$Type, state: $BlockState$Type): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTCeilingHangingSignBlock$Type = ($GTCeilingHangingSignBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTCeilingHangingSignBlock_ = $GTCeilingHangingSignBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/duct/$DuctRoutePath" {
import {$DuctPipeProperties, $DuctPipeProperties$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/duct/$DuctPipeProperties"
import {$IHazardParticleContainer, $IHazardParticleContainer$Type} from "packages/com/gregtechceu/gtceu/api/capability/$IHazardParticleContainer"
import {$DuctPipeBlockEntity, $DuctPipeBlockEntity$Type} from "packages/com/gregtechceu/gtceu/common/blockentity/$DuctPipeBlockEntity"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$IRoutePath, $IRoutePath$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IRoutePath"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$FacingPos, $FacingPos$Type} from "packages/com/gregtechceu/gtceu/utils/$FacingPos"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $DuctRoutePath implements $IRoutePath<($IHazardParticleContainer)> {

constructor(targetPipe: $DuctPipeBlockEntity$Type, facing: $Direction$Type, distance: integer, properties: $DuctPipeProperties$Type)

public "getProperties"(): $DuctPipeProperties
public "getDistance"(): integer
public "getTargetPipePos"(): $BlockPos
public "getTargetFacing"(): $Direction
public "getTargetPipe"(): $DuctPipeBlockEntity
public "toFacingPos"(): $FacingPos
public "getTargetBlockEntity"(level: $Level$Type): $BlockEntity
public "getTargetCapability"<I>(capability: $Capability$Type<(I)>, level: $Level$Type): I
get "properties"(): $DuctPipeProperties
get "distance"(): integer
get "targetPipePos"(): $BlockPos
get "targetFacing"(): $Direction
get "targetPipe"(): $DuctPipeBlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DuctRoutePath$Type = ($DuctRoutePath);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DuctRoutePath_ = $DuctRoutePath$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/$IMaterialRegistryManager$Phase" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $IMaterialRegistryManager$Phase extends $Enum<($IMaterialRegistryManager$Phase)> {
static readonly "PRE": $IMaterialRegistryManager$Phase
static readonly "OPEN": $IMaterialRegistryManager$Phase
static readonly "CLOSED": $IMaterialRegistryManager$Phase
static readonly "FROZEN": $IMaterialRegistryManager$Phase


public static "values"(): ($IMaterialRegistryManager$Phase)[]
public static "valueOf"(name: string): $IMaterialRegistryManager$Phase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMaterialRegistryManager$Phase$Type = (("pre") | ("closed") | ("frozen") | ("open")) | ($IMaterialRegistryManager$Phase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMaterialRegistryManager$Phase_ = $IMaterialRegistryManager$Phase$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/$MarkerMaterial" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $MarkerMaterial extends $Material {

constructor(resourceLocation: $ResourceLocation$Type)

public "toString"(): string
public "verifyMaterial"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MarkerMaterial$Type = ($MarkerMaterial);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MarkerMaterial_ = $MarkerMaterial$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipeType$ICustomRecipeLogic" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$GTRecipe, $GTRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe"
import {$IRecipeCapabilityHolder, $IRecipeCapabilityHolder$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IRecipeCapabilityHolder"

export interface $GTRecipeType$ICustomRecipeLogic {

 "createCustomRecipe"(arg0: $IRecipeCapabilityHolder$Type): $GTRecipe
 "getRepresentativeRecipes"(): $List<($GTRecipe)>

(arg0: $IRecipeCapabilityHolder$Type): $GTRecipe
}

export namespace $GTRecipeType$ICustomRecipeLogic {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTRecipeType$ICustomRecipeLogic$Type = ($GTRecipeType$ICustomRecipeLogic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTRecipeType$ICustomRecipeLogic_ = $GTRecipeType$ICustomRecipeLogic$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/fluids/store/$FluidStorageKeys" {
import {$FluidStorageKey, $FluidStorageKey$Type} from "packages/com/gregtechceu/gtceu/api/fluids/store/$FluidStorageKey"

export class $FluidStorageKeys {
static readonly "LIQUID": $FluidStorageKey
static readonly "GAS": $FluidStorageKey
static readonly "PLASMA": $FluidStorageKey
static readonly "MOLTEN": $FluidStorageKey


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidStorageKeys$Type = ($FluidStorageKeys);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidStorageKeys_ = $FluidStorageKeys$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/fluids/store/$FluidStorage" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$GTRegistrate, $GTRegistrate$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$GTRegistrate"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$FluidStorageKey, $FluidStorageKey$Type} from "packages/com/gregtechceu/gtceu/api/fluids/store/$FluidStorageKey"
import {$FluidBuilder, $FluidBuilder$Type} from "packages/com/gregtechceu/gtceu/api/fluids/$FluidBuilder"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$FluidStorage$FluidEntry, $FluidStorage$FluidEntry$Type} from "packages/com/gregtechceu/gtceu/api/fluids/store/$FluidStorage$FluidEntry"

export class $FluidStorage {

constructor()

public "get"(key: $FluidStorageKey$Type): $Fluid
public "store"(key: $FluidStorageKey$Type, fluid: $Supplier$Type<(any)>, builder: $FluidBuilder$Type): void
public "getEntry"(key: $FluidStorageKey$Type): $FluidStorage$FluidEntry
public "registerFluids"(material: $Material$Type, registrate: $GTRegistrate$Type): void
public "getQueuedBuilder"(key: $FluidStorageKey$Type): $FluidBuilder
public "enqueueRegistration"(key: $FluidStorageKey$Type, builder: $FluidBuilder$Type): void
public "storeNoOverwrites"(key: $FluidStorageKey$Type, fluid: $Supplier$Type<(any)>, builder: $FluidBuilder$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidStorage$Type = ($FluidStorage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidStorage_ = $FluidStorage$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$BlastProperty" {
import {$IMaterialProperty, $IMaterialProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IMaterialProperty"
import {$MaterialProperties, $MaterialProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$MaterialProperties"
import {$BlastProperty$GasTier, $BlastProperty$GasTier$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$BlastProperty$GasTier"

export class $BlastProperty implements $IMaterialProperty<($BlastProperty)> {

constructor()
constructor(blastTemperature: integer, gasTier: $BlastProperty$GasTier$Type, eutOverride: integer, durationOverride: integer)
constructor(blastTemperature: integer)

public "setGasTier"(tier: $BlastProperty$GasTier$Type): void
public "getGasTier"(): $BlastProperty$GasTier
public "getEUtOverride"(): integer
public "verifyProperty"(properties: $MaterialProperties$Type): void
public "getBlastTemperature"(): integer
public "getDurationOverride"(): integer
public static "validateGasTier"(gasTierName: string): $BlastProperty$GasTier
public "setEutOverride"(eut: integer): void
public "setBlastTemperature"(blastTemp: integer): void
public "setDurationOverride"(duration: integer): void
set "gasTier"(value: $BlastProperty$GasTier$Type)
get "gasTier"(): $BlastProperty$GasTier
get "eUtOverride"(): integer
get "blastTemperature"(): integer
get "durationOverride"(): integer
set "eutOverride"(value: integer)
set "blastTemperature"(value: integer)
set "durationOverride"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlastProperty$Type = ($BlastProperty);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlastProperty_ = $BlastProperty$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/registry/registrate/$CompassSection" {
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$IGuiTexture, $IGuiTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$IGuiTexture"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $CompassSection {


public "priority"(priority: integer): $CompassSection
public "register"(): $CompassSection
public static "create"(section: string): $CompassSection
public "lang"(): string
public "lang"(lang: string): $CompassSection
public "background"(background: $Supplier$Type<($IGuiTexture$Type)>): $CompassSection
public "icon"(icon: $Supplier$Type<($IGuiTexture$Type)>): $CompassSection
public "sectionID"(): $ResourceLocation
public "getUnlocalizedKey"(): string
get "unlocalizedKey"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompassSection$Type = ($CompassSection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompassSection_ = $CompassSection$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/$MetaMachineItem" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$IRenderer, $IRenderer$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IRenderer"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$FoodProperties, $FoodProperties$Type} from "packages/net/minecraft/world/food/$FoodProperties"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$MachineDefinition, $MachineDefinition$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MachineDefinition"
import {$BlockItem, $BlockItem$Type} from "packages/net/minecraft/world/item/$BlockItem"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$Type} from "packages/net/mehvahdjukaar/moonlight/api/item/additional_placements/$AdditionalItemPlacement"
import {$IItemRendererProvider, $IItemRendererProvider$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IItemRendererProvider"
import {$IMachineBlock, $IMachineBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$IMachineBlock"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MetaMachineItem extends $BlockItem implements $IItemRendererProvider {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "descriptionId": string
 "foodProperties": $FoodProperties
readonly "canRepair": boolean
 "renderProperties": any
 "moonlight$clientAnimationProvider": any

constructor(block: $IMachineBlock$Type, properties: $Item$Properties$Type)

public "getDefinition"(): $MachineDefinition
public "getRenderer"(stack: $ItemStack$Type): $IRenderer
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public "moonlight$addAdditionalBehavior"(arg0: $AdditionalItemPlacement$Type): void
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
get "definition"(): $MachineDefinition
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MetaMachineItem$Type = ($MetaMachineItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MetaMachineItem_ = $MetaMachineItem$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/gui/editor/$IEditableUI" {
import {$WidgetGroup, $WidgetGroup$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$WidgetGroup"
import {$Widget, $Widget$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$Widget"

export interface $IEditableUI<W extends $Widget, T> {

 "createDefault"(): W
 "setupUI"(arg0: $WidgetGroup$Type, arg1: T): void
}

export namespace $IEditableUI {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEditableUI$Type<W, T> = ($IEditableUI<(W), (T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IEditableUI_<W, T> = $IEditableUI$Type<(W), (T)>;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/duct/$DuctPipeNet" {
import {$DuctPipeProperties, $DuctPipeProperties$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/duct/$DuctPipeProperties"
import {$PipeNet, $PipeNet$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$PipeNet"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$DuctRoutePath, $DuctRoutePath$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/duct/$DuctRoutePath"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$LevelPipeNet, $LevelPipeNet$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$LevelPipeNet"

export class $DuctPipeNet extends $PipeNet<($DuctPipeProperties)> {

constructor(world: $LevelPipeNet$Type<($DuctPipeProperties$Type), (any)>)

public "getNetData"(pipePos: $BlockPos$Type, facing: $Direction$Type): $List<($DuctRoutePath)>
public "onPipeConnectionsUpdate"(): void
public "onNeighbourUpdate"(fromPos: $BlockPos$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DuctPipeNet$Type = ($DuctPipeNet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DuctPipeNet_ = $DuctPipeNet$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/capability/$IMedicalConditionTracker" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$MedicalCondition, $MedicalCondition$Type} from "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$MedicalCondition"
import {$Object2FloatMap, $Object2FloatMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatMap"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export interface $IMedicalConditionTracker {

 "tick"(): void
 "getMaxAirSupply"(): integer
 "heal"(arg0: $MedicalCondition$Type, arg1: integer): void
 "progressRelatedCondition"(material: $Material$Type): void
 "getMedicalConditions"(): $Object2FloatMap<($MedicalCondition)>
 "removeMedicalCondition"(arg0: $MedicalCondition$Type): void
 "progressCondition"(arg0: $MedicalCondition$Type, arg1: float): void
 "setMobEffect"(arg0: $MobEffect$Type, arg1: integer): void
}

export namespace $IMedicalConditionTracker {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMedicalConditionTracker$Type = ($IMedicalConditionTracker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMedicalConditionTracker_ = $IMedicalConditionTracker$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/$GTCEuAPI" {
import {$ICoilType, $ICoilType$Type} from "packages/com/gregtechceu/gtceu/api/block/$ICoilType"
import {$BatteryBlock, $BatteryBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/$BatteryBlock"
import {$GTCEu, $GTCEu$Type} from "packages/com/gregtechceu/gtceu/$GTCEu"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$IBatteryData, $IBatteryData$Type} from "packages/com/gregtechceu/gtceu/api/machine/multiblock/$IBatteryData"
import {$IMaterialRegistryManager, $IMaterialRegistryManager$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$IMaterialRegistryManager"
import {$IFilterType, $IFilterType$Type} from "packages/com/gregtechceu/gtceu/api/block/$IFilterType"
import {$CoilBlock, $CoilBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/$CoilBlock"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GTCEuAPI {
static "instance": $GTCEu
static "materialManager": $IMaterialRegistryManager
static readonly "HEATING_COILS": $Map<($ICoilType), ($Supplier<($CoilBlock)>)>
static readonly "CLEANROOM_FILTERS": $Map<($IFilterType), ($Supplier<($Block)>)>
static readonly "PSS_BATTERIES": $Map<($IBatteryData), ($Supplier<($BatteryBlock)>)>

constructor()

public static "isHighTier"(): boolean
public static "initializeHighTier"(): void
get "highTier"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTCEuAPI$Type = ($GTCEuAPI);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTCEuAPI_ = $GTCEuAPI$Type;
}}
declare module "packages/com/gregtechceu/gtceu/data/recipe/misc/alloyblast/$AlloyBlastRecipeProducer" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$BlastProperty, $BlastProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$BlastProperty"
import {$FinishedRecipe, $FinishedRecipe$Type} from "packages/net/minecraft/data/recipes/$FinishedRecipe"

export class $AlloyBlastRecipeProducer {
static readonly "DEFAULT_PRODUCER": $AlloyBlastRecipeProducer

constructor()

public "produce"(material: $Material$Type, property: $BlastProperty$Type, provider: $Consumer$Type<($FinishedRecipe$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlloyBlastRecipeProducer$Type = ($AlloyBlastRecipeProducer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlloyBlastRecipeProducer_ = $AlloyBlastRecipeProducer$Type;
}}
declare module "packages/com/gregtechceu/gtceu/data/recipe/builder/$GTRecipeBuilder" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$CleanroomType, $CleanroomType$Type} from "packages/com/gregtechceu/gtceu/api/machine/multiblock/$CleanroomType"
import {$ResearchRecipeBuilder$StationRecipeBuilder, $ResearchRecipeBuilder$StationRecipeBuilder$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$ResearchRecipeBuilder$StationRecipeBuilder"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$MedicalCondition, $MedicalCondition$Type} from "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$MedicalCondition"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$ResearchRecipeBuilder$ScannerRecipeBuilder, $ResearchRecipeBuilder$ScannerRecipeBuilder$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$ResearchRecipeBuilder$ScannerRecipeBuilder"
import {$MachineDefinition, $MachineDefinition$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MachineDefinition"
import {$FluidStack, $FluidStack$Type} from "packages/com/lowdragmc/lowdraglib/side/fluid/$FluidStack"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Content, $Content$Type} from "packages/com/gregtechceu/gtceu/api/recipe/content/$Content"
import {$RecipeCondition, $RecipeCondition$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$RecipeCondition"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$FinishedRecipe, $FinishedRecipe$Type} from "packages/net/minecraft/data/recipes/$FinishedRecipe"
import {$GTRecipeType, $GTRecipeType$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipeType"
import {$FluidIngredient, $FluidIngredient$Type} from "packages/com/gregtechceu/gtceu/api/recipe/ingredient/$FluidIngredient"
import {$Tag, $Tag$Type} from "packages/net/minecraft/nbt/$Tag"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$GTRecipe, $GTRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$GTRecipeBuilder$ResearchRecipeEntry, $GTRecipeBuilder$ResearchRecipeEntry$Type} from "packages/com/gregtechceu/gtceu/data/recipe/builder/$GTRecipeBuilder$ResearchRecipeEntry"
import {$RecipeCapability, $RecipeCapability$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$RecipeCapability"
import {$TagPrefix, $TagPrefix$Type} from "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$UnificationEntry, $UnificationEntry$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/stack/$UnificationEntry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GTRecipeBuilder {
readonly "input": $Map<($RecipeCapability<(any)>), ($List<($Content)>)>
readonly "tickInput": $Map<($RecipeCapability<(any)>), ($List<($Content)>)>
readonly "output": $Map<($RecipeCapability<(any)>), ($List<($Content)>)>
readonly "tickOutput": $Map<($RecipeCapability<(any)>), ($List<($Content)>)>
 "data": $CompoundTag
readonly "conditions": $List<($RecipeCondition)>
 "id": $ResourceLocation
 "recipeType": $GTRecipeType
 "duration": integer
 "perTick": boolean
 "slotName": string
 "uiName": string
 "chance": float
 "tierChanceBoost": float
 "isFuel": boolean
 "onSave": $BiConsumer<($GTRecipeBuilder), ($Consumer<($FinishedRecipe)>)>

constructor(id: $ResourceLocation$Type, recipeType: $GTRecipeType$Type)
constructor(toCopy: $GTRecipe$Type, recipeType: $GTRecipeType$Type)

public static "of"(id: $ResourceLocation$Type, recipeType: $GTRecipeType$Type): $GTRecipeBuilder
public "id"(id: $ResourceLocation$Type): $GTRecipeBuilder
public "save"(consumer: $Consumer$Type<($FinishedRecipe$Type)>): void
public "copy"(id: $ResourceLocation$Type): $GTRecipeBuilder
public "copy"(id: string): $GTRecipeBuilder
public "input"<T>(capability: $RecipeCapability$Type<(T)>, ...obj: (T)[]): $GTRecipeBuilder
public "build"(): $FinishedRecipe
public "duration"(duration: integer): $GTRecipeBuilder
public "output"<T>(capability: $RecipeCapability$Type<(T)>, ...obj: (T)[]): $GTRecipeBuilder
public "copyFrom"(builder: $GTRecipeBuilder$Type): $GTRecipeBuilder
public "dimension"(dimension: $ResourceLocation$Type, reverse: boolean): $GTRecipeBuilder
public "dimension"(dimension: $ResourceLocation$Type): $GTRecipeBuilder
public "inputs"<T>(capability: $RecipeCapability$Type<(T)>, ...obj: (any)[]): $GTRecipeBuilder
public "toJson"(json: $JsonObject$Type): void
public "posY"(min: integer, max: integer): $GTRecipeBuilder
public "posY"(min: integer, max: integer, reverse: boolean): $GTRecipeBuilder
public "onSave"(onSave: $BiConsumer$Type<($GTRecipeBuilder$Type), ($Consumer$Type<($FinishedRecipe$Type)>)>): $GTRecipeBuilder
public "chance"(chance: float): $GTRecipeBuilder
public "outputs"<T>(capability: $RecipeCapability$Type<(T)>, ...obj: (any)[]): $GTRecipeBuilder
public "recipeType"(recipeType: $GTRecipeType$Type): $GTRecipeBuilder
public "isFuel"(isFuel: boolean): $GTRecipeBuilder
public "circuitMeta"(configuration: integer): $GTRecipeBuilder
public "biome"(biome: $ResourceLocation$Type): $GTRecipeBuilder
public "biome"(biome: $ResourceLocation$Type, reverse: boolean): $GTRecipeBuilder
public "thunder"(level: float): $GTRecipeBuilder
public "thunder"(level: float, reverse: boolean): $GTRecipeBuilder
public "rpm"(rpm: float, reverse: boolean): $GTRecipeBuilder
public "rpm"(rpm: float): $GTRecipeBuilder
public "researchRecipeEntries"(): $Collection<($GTRecipeBuilder$ResearchRecipeEntry)>
public "buildRawRecipe"(): $GTRecipe
public "inputItems"(...inputs: ($Ingredient$Type)[]): $GTRecipeBuilder
public "inputItems"(input: $UnificationEntry$Type, count: integer): $GTRecipeBuilder
public "inputItems"(input: $ItemStack$Type): $GTRecipeBuilder
public "inputItems"(orePrefix: $TagPrefix$Type, material: $Material$Type, count: integer): $GTRecipeBuilder
public "inputItems"(input: $Item$Type, amount: integer): $GTRecipeBuilder
public "inputItems"(input: $UnificationEntry$Type): $GTRecipeBuilder
public "inputItems"(orePrefix: $TagPrefix$Type, material: $Material$Type): $GTRecipeBuilder
public "inputItems"(input: $Supplier$Type<(any)>, amount: integer): $GTRecipeBuilder
public "inputItems"(input: $Supplier$Type<(any)>): $GTRecipeBuilder
public "inputItems"(input: $Item$Type): $GTRecipeBuilder
public "inputItems"(...inputs: ($ItemStack$Type)[]): $GTRecipeBuilder
public "inputItems"(tag: $TagKey$Type<($Item$Type)>, amount: integer): $GTRecipeBuilder
public "inputItems"(tag: $TagKey$Type<($Item$Type)>): $GTRecipeBuilder
public "inputItems"(machine: $MachineDefinition$Type, count: integer): $GTRecipeBuilder
public "inputItems"(machine: $MachineDefinition$Type): $GTRecipeBuilder
public "outputItems"(input: $Supplier$Type<(any)>): $GTRecipeBuilder
public "outputItems"(input: $Item$Type): $GTRecipeBuilder
public "outputItems"(input: $Item$Type, amount: integer): $GTRecipeBuilder
public "outputItems"(...outputs: ($ItemStack$Type)[]): $GTRecipeBuilder
public "outputItems"(output: $ItemStack$Type): $GTRecipeBuilder
public "outputItems"(machine: $MachineDefinition$Type, count: integer): $GTRecipeBuilder
public "outputItems"(machine: $MachineDefinition$Type): $GTRecipeBuilder
public "outputItems"(orePrefix: $TagPrefix$Type, material: $Material$Type, count: integer): $GTRecipeBuilder
public "outputItems"(orePrefix: $TagPrefix$Type, material: $Material$Type): $GTRecipeBuilder
public "outputItems"(input: $Supplier$Type<(any)>, amount: integer): $GTRecipeBuilder
public "slotName"(slotName: string): $GTRecipeBuilder
public "perTick"(perTick: boolean): $GTRecipeBuilder
public "rain"(level: float): $GTRecipeBuilder
public "rain"(level: float, reverse: boolean): $GTRecipeBuilder
public "itemOutputs"(...outputs: ($ItemStack$Type)[]): $GTRecipeBuilder
public "outputFluids"(...outputs: ($FluidIngredient$Type)[]): $GTRecipeBuilder
public "outputFluids"(...outputs: ($FluidStack$Type)[]): $GTRecipeBuilder
public "outputFluids"(output: $FluidStack$Type): $GTRecipeBuilder
public "addData"(key: string, data: string): $GTRecipeBuilder
public "addData"(key: string, data: boolean): $GTRecipeBuilder
public "addData"(key: string, data: float): $GTRecipeBuilder
public "addData"(key: string, data: $Tag$Type): $GTRecipeBuilder
public "addData"(key: string, data: integer): $GTRecipeBuilder
public "addData"(key: string, data: long): $GTRecipeBuilder
public "environmentalHazard"(condition: $MedicalCondition$Type, reverse: boolean): $GTRecipeBuilder
public "environmentalHazard"(condition: $MedicalCondition$Type): $GTRecipeBuilder
public "disableDistilleryRecipes"(flag: boolean): $GTRecipeBuilder
public "researchWithoutRecipe"(researchId: string, dataStack: $ItemStack$Type): $GTRecipeBuilder
public "researchWithoutRecipe"(researchId: string): $GTRecipeBuilder
public "inputStress"(stress: float): $GTRecipeBuilder
public "outputStress"(stress: float): $GTRecipeBuilder
public "chancedInput"(stack: $FluidStack$Type, chance: integer, tierChanceBoost: integer): $GTRecipeBuilder
public "chancedInput"(stack: $ItemStack$Type, chance: integer, tierChanceBoost: integer): $GTRecipeBuilder
public "chancedOutput"(tag: $TagPrefix$Type, mat: $Material$Type, count: integer, chance: integer, tierChanceBoost: integer): $GTRecipeBuilder
public "chancedOutput"(tag: $TagPrefix$Type, mat: $Material$Type, chance: integer, tierChanceBoost: integer): $GTRecipeBuilder
public "chancedOutput"(stack: $FluidStack$Type, chance: integer, tierChanceBoost: integer): $GTRecipeBuilder
public "chancedOutput"(stack: $ItemStack$Type, chance: integer, tierChanceBoost: integer): $GTRecipeBuilder
public "inputFluids"(...inputs: ($FluidIngredient$Type)[]): $GTRecipeBuilder
public "inputFluids"(...inputs: ($FluidStack$Type)[]): $GTRecipeBuilder
public "inputFluids"(input: $FluidStack$Type): $GTRecipeBuilder
public "solderMultiplier"(multiplier: integer): $GTRecipeBuilder
public "fusionStartEU"(eu: long): $GTRecipeBuilder
public "explosivesAmount"(explosivesAmount: integer): $GTRecipeBuilder
public "cleanroom"(cleanroomType: $CleanroomType$Type): $GTRecipeBuilder
public "explosivesType"(explosivesType: $ItemStack$Type): $GTRecipeBuilder
public "blastFurnaceTemp"(blastTemp: integer): $GTRecipeBuilder
public "researchScan"(isScan: boolean): $GTRecipeBuilder
public "scannerResearch"(researchStack: $ItemStack$Type): $GTRecipeBuilder
public "scannerResearch"(research: $UnaryOperator$Type<($ResearchRecipeBuilder$ScannerRecipeBuilder$Type)>): $GTRecipeBuilder
public "stationResearch"(research: $UnaryOperator$Type<($ResearchRecipeBuilder$StationRecipeBuilder$Type)>): $GTRecipeBuilder
public "notConsumableFluid"(ingredient: $FluidIngredient$Type): $GTRecipeBuilder
public "notConsumableFluid"(fluid: $FluidStack$Type): $GTRecipeBuilder
public "tierChanceBoost"(tierChanceBoost: float): $GTRecipeBuilder
public "addCondition"(condition: $RecipeCondition$Type): $GTRecipeBuilder
public "itemOutput"(unificationEntry: $UnificationEntry$Type): $GTRecipeBuilder
public "itemOutput"(unificationEntry: $UnificationEntry$Type, count: integer): $GTRecipeBuilder
public "durationIsTotalCWU"(durationIsTotalCWU: boolean): $GTRecipeBuilder
public "inputEU"(eu: long): $GTRecipeBuilder
public "CWUt"(cwu: integer): $GTRecipeBuilder
public "inputCWU"(cwu: integer): $GTRecipeBuilder
public "outputEU"(eu: long): $GTRecipeBuilder
public "outputCWU"(cwu: integer): $GTRecipeBuilder
public "hideDuration"(hideDuration: boolean): $GTRecipeBuilder
public "EUt"(eu: long): $GTRecipeBuilder
public "EUt"(): long
public "totalCWU"(cwu: integer): $GTRecipeBuilder
public "notConsumable"(ingredient: $Ingredient$Type): $GTRecipeBuilder
public "notConsumable"(orePrefix: $TagPrefix$Type, material: $Material$Type): $GTRecipeBuilder
public "notConsumable"(itemStack: $ItemStack$Type): $GTRecipeBuilder
public "notConsumable"(item: $Supplier$Type<(any)>): $GTRecipeBuilder
public "notConsumable"(item: $Item$Type): $GTRecipeBuilder
public "uiName"(uiName: string): $GTRecipeBuilder
public "capabilitiesToJson"(contents: $Map$Type<($RecipeCapability$Type<(any)>), ($List$Type<($Content$Type)>)>): $JsonObject
public "getSolderMultiplier"(): integer
public static "ofRaw"(): $GTRecipeBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTRecipeBuilder$Type = ($GTRecipeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTRecipeBuilder_ = $GTRecipeBuilder$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/worldgen/feature/$StoneBlobFeature" {
import {$RandomFeatureConfiguration, $RandomFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$RandomFeatureConfiguration"
import {$SpikeConfiguration, $SpikeConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SpikeConfiguration"
import {$MultifaceGrowthConfiguration, $MultifaceGrowthConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$MultifaceGrowthConfiguration"
import {$RootSystemConfiguration, $RootSystemConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$RootSystemConfiguration"
import {$UnderwaterMagmaConfiguration, $UnderwaterMagmaConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$UnderwaterMagmaConfiguration"
import {$TwistingVinesConfig, $TwistingVinesConfig$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$TwistingVinesConfig"
import {$FeaturePlaceContext, $FeaturePlaceContext$Type} from "packages/net/minecraft/world/level/levelgen/feature/$FeaturePlaceContext"
import {$HugeMushroomFeatureConfiguration, $HugeMushroomFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$HugeMushroomFeatureConfiguration"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$HugeFungusConfiguration, $HugeFungusConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/$HugeFungusConfiguration"
import {$FossilFeatureConfiguration, $FossilFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/$FossilFeatureConfiguration"
import {$DeltaFeatureConfiguration, $DeltaFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$DeltaFeatureConfiguration"
import {$BlockPileConfiguration, $BlockPileConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$BlockPileConfiguration"
import {$OreConfiguration, $OreConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$OreConfiguration"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$SculkPatchConfiguration, $SculkPatchConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SculkPatchConfiguration"
import {$NetherForestVegetationConfig, $NetherForestVegetationConfig$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$NetherForestVegetationConfig"
import {$GeodeConfiguration, $GeodeConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$GeodeConfiguration"
import {$StoneBlobConfiguration, $StoneBlobConfiguration$Type} from "packages/com/gregtechceu/gtceu/common/worldgen/feature/configurations/$StoneBlobConfiguration"
import {$RandomBooleanFeatureConfiguration, $RandomBooleanFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$RandomBooleanFeatureConfiguration"
import {$ColumnFeatureConfiguration, $ColumnFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$ColumnFeatureConfiguration"
import {$CountConfiguration, $CountConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$CountConfiguration"
import {$VegetationPatchConfiguration, $VegetationPatchConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$VegetationPatchConfiguration"
import {$Feature, $Feature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$Feature"
import {$BonusChestFeature, $BonusChestFeature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$BonusChestFeature"
import {$LakeFeature$Configuration, $LakeFeature$Configuration$Type} from "packages/net/minecraft/world/level/levelgen/feature/$LakeFeature$Configuration"
import {$BlockColumnConfiguration, $BlockColumnConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$BlockColumnConfiguration"
import {$BlockPos$MutableBlockPos, $BlockPos$MutableBlockPos$Type} from "packages/net/minecraft/core/$BlockPos$MutableBlockPos"
import {$RandomPatchConfiguration, $RandomPatchConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$RandomPatchConfiguration"
import {$ProbabilityFeatureConfiguration, $ProbabilityFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$ProbabilityFeatureConfiguration"
import {$TreeConfiguration, $TreeConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$TreeConfiguration"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$DripstoneClusterConfiguration, $DripstoneClusterConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$DripstoneClusterConfiguration"
import {$LayerConfiguration, $LayerConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$LayerConfiguration"
import {$ReplaceBlockConfiguration, $ReplaceBlockConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$ReplaceBlockConfiguration"
import {$BlockStateConfiguration, $BlockStateConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$BlockStateConfiguration"
import {$SimpleBlockConfiguration, $SimpleBlockConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SimpleBlockConfiguration"
import {$DiskConfiguration, $DiskConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$DiskConfiguration"
import {$SeagrassFeature, $SeagrassFeature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$SeagrassFeature"
import {$ReplaceSphereConfiguration, $ReplaceSphereConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$ReplaceSphereConfiguration"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$PointedDripstoneConfiguration, $PointedDripstoneConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$PointedDripstoneConfiguration"
import {$SpringConfiguration, $SpringConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SpringConfiguration"
import {$OreConfiguration$TargetBlockState, $OreConfiguration$TargetBlockState$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$OreConfiguration$TargetBlockState"
import {$SimpleRandomFeatureConfiguration, $SimpleRandomFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SimpleRandomFeatureConfiguration"
import {$LargeDripstoneConfiguration, $LargeDripstoneConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$LargeDripstoneConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$NoneFeatureConfiguration"
import {$EndGatewayConfiguration, $EndGatewayConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$EndGatewayConfiguration"

export class $StoneBlobFeature extends $Feature<($StoneBlobConfiguration)> {
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>

constructor()

public "place"(context: $FeaturePlaceContext$Type<($StoneBlobConfiguration$Type)>): boolean
public "canPlaceOre"(state: $BlockState$Type, adjacentStateAccessor: $Function$Type<($BlockPos$Type), ($BlockState$Type)>, random: $RandomSource$Type, targetState: $OreConfiguration$TargetBlockState$Type, mutablePos: $BlockPos$MutableBlockPos$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StoneBlobFeature$Type = ($StoneBlobFeature);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StoneBlobFeature_ = $StoneBlobFeature$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/data/$GTElements" {
import {$Element, $Element$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/$Element"

export class $GTElements {
static readonly "H": $Element
static readonly "D": $Element
static readonly "T": $Element
static readonly "He": $Element
static readonly "He3": $Element
static readonly "Li": $Element
static readonly "Be": $Element
static readonly "B": $Element
static readonly "C": $Element
static readonly "N": $Element
static readonly "O": $Element
static readonly "F": $Element
static readonly "Ne": $Element
static readonly "Na": $Element
static readonly "Mg": $Element
static readonly "Al": $Element
static readonly "Si": $Element
static readonly "P": $Element
static readonly "S": $Element
static readonly "Cl": $Element
static readonly "Ar": $Element
static readonly "K": $Element
static readonly "Ca": $Element
static readonly "Sc": $Element
static readonly "Ti": $Element
static readonly "V": $Element
static readonly "Cr": $Element
static readonly "Mn": $Element
static readonly "Fe": $Element
static readonly "Co": $Element
static readonly "Ni": $Element
static readonly "Cu": $Element
static readonly "Zn": $Element
static readonly "Ga": $Element
static readonly "Ge": $Element
static readonly "As": $Element
static readonly "Se": $Element
static readonly "Br": $Element
static readonly "Kr": $Element
static readonly "Rb": $Element
static readonly "Sr": $Element
static readonly "Y": $Element
static readonly "Zr": $Element
static readonly "Nb": $Element
static readonly "Mo": $Element
static readonly "Tc": $Element
static readonly "Ru": $Element
static readonly "Rh": $Element
static readonly "Pd": $Element
static readonly "Ag": $Element
static readonly "Cd": $Element
static readonly "In": $Element
static readonly "Sn": $Element
static readonly "Sb": $Element
static readonly "Te": $Element
static readonly "I": $Element
static readonly "Xe": $Element
static readonly "Cs": $Element
static readonly "Ba": $Element
static readonly "La": $Element
static readonly "Ce": $Element
static readonly "Pr": $Element
static readonly "Nd": $Element
static readonly "Pm": $Element
static readonly "Sm": $Element
static readonly "Eu": $Element
static readonly "Gd": $Element
static readonly "Tb": $Element
static readonly "Dy": $Element
static readonly "Ho": $Element
static readonly "Er": $Element
static readonly "Tm": $Element
static readonly "Yb": $Element
static readonly "Lu": $Element
static readonly "Hf": $Element
static readonly "Ta": $Element
static readonly "W": $Element
static readonly "Re": $Element
static readonly "Os": $Element
static readonly "Ir": $Element
static readonly "Pt": $Element
static readonly "Au": $Element
static readonly "Hg": $Element
static readonly "Tl": $Element
static readonly "Pb": $Element
static readonly "Bi": $Element
static readonly "Po": $Element
static readonly "At": $Element
static readonly "Rn": $Element
static readonly "Fr": $Element
static readonly "Ra": $Element
static readonly "Ac": $Element
static readonly "Th": $Element
static readonly "Pa": $Element
static readonly "U": $Element
static readonly "U238": $Element
static readonly "U235": $Element
static readonly "Np": $Element
static readonly "Pu": $Element
static readonly "Pu239": $Element
static readonly "Pu241": $Element
static readonly "Am": $Element
static readonly "Cm": $Element
static readonly "Bk": $Element
static readonly "Cf": $Element
static readonly "Es": $Element
static readonly "Fm": $Element
static readonly "Md": $Element
static readonly "No": $Element
static readonly "Lr": $Element
static readonly "Rf": $Element
static readonly "Db": $Element
static readonly "Sg": $Element
static readonly "Bh": $Element
static readonly "Hs": $Element
static readonly "Mt": $Element
static readonly "Ds": $Element
static readonly "Rg": $Element
static readonly "Cn": $Element
static readonly "Nh": $Element
static readonly "Fl": $Element
static readonly "Mc": $Element
static readonly "Lv": $Element
static readonly "Ts": $Element
static readonly "Og": $Element
static readonly "Tr": $Element
static readonly "Dr": $Element
static readonly "Ke": $Element
static readonly "Nq": $Element
static readonly "Nq1": $Element
static readonly "Nq2": $Element
static readonly "Nt": $Element
static readonly "Sp": $Element
static readonly "Ma": $Element

constructor()

public static "get"(name: string): $Element
public static "init"(): void
public static "createAndRegister"(protons: long, neutrons: long, halfLifeSeconds: long, decayTo: string, name: string, symbol: string, isIsotope: boolean): $Element
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTElements$Type = ($GTElements);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTElements_ = $GTElements$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pipenet/$LevelPipeNet" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$SavedData, $SavedData$Type} from "packages/net/minecraft/world/level/saveddata/$SavedData"
import {$PipeNet, $PipeNet$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$PipeNet"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $LevelPipeNet<NodeDataType, T extends $PipeNet<(NodeDataType)>> extends $SavedData {

constructor(serverLevel: $ServerLevel$Type)
constructor(serverLevel: $ServerLevel$Type, tag: $CompoundTag$Type)

public "removeNode"(nodePos: $BlockPos$Type): void
public "updateData"(nodePos: $BlockPos$Type, data: NodeDataType): void
public "addNode"(nodePos: $BlockPos$Type, nodeData: NodeDataType, mark: integer, openConnections: integer, isActive: boolean): void
public "save"(compound: $CompoundTag$Type): $CompoundTag
public "getWorld"(): $ServerLevel
public "updateBlockedConnections"(nodePos: $BlockPos$Type, side: $Direction$Type, isBlocked: boolean): void
public "updateMark"(nodePos: $BlockPos$Type, newMark: integer): void
public "getNetFromPos"(blockPos: $BlockPos$Type): T
get "world"(): $ServerLevel
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelPipeNet$Type<NodeDataType, T> = ($LevelPipeNet<(NodeDataType), (T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LevelPipeNet_<NodeDataType, T> = $LevelPipeNet$Type<(NodeDataType), (T)>;
}}
declare module "packages/com/gregtechceu/gtceu/core/mixins/$GuiGraphicsAccessor" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $GuiGraphicsAccessor {

}

export namespace $GuiGraphicsAccessor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiGraphicsAccessor$Type = ($GuiGraphicsAccessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiGraphicsAccessor_ = $GuiGraphicsAccessor$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/fluids/store/$FluidStorage$FluidEntry" {
import {$FluidBuilder, $FluidBuilder$Type} from "packages/com/gregtechceu/gtceu/api/fluids/$FluidBuilder"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $FluidStorage$FluidEntry {

constructor(fluid: $Supplier$Type<(any)>, builder: $FluidBuilder$Type)

public "getBuilder"(): $FluidBuilder
public "getFluid"(): $Supplier<(any)>
public "setBuilder"(builder: $FluidBuilder$Type): void
get "builder"(): $FluidBuilder
get "fluid"(): $Supplier<(any)>
set "builder"(value: $FluidBuilder$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidStorage$FluidEntry$Type = ($FluidStorage$FluidEntry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidStorage$FluidEntry_ = $FluidStorage$FluidEntry$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$GeodeVeinGenerator$GeodeBlockSettings" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$BlockStateProvider, $BlockStateProvider$Type} from "packages/net/minecraft/world/level/levelgen/feature/stateproviders/$BlockStateProvider"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$TagPrefix, $TagPrefix$Type} from "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $GeodeVeinGenerator$GeodeBlockSettings extends $Record {
static readonly "CODEC": $Codec<($GeodeVeinGenerator$GeodeBlockSettings)>

constructor(fillingProvider: $Either$Type<($BlockStateProvider$Type), ($Material$Type)>, innerLayerProvider: $Either$Type<($BlockStateProvider$Type), ($Material$Type)>, alternateInnerLayerProvider: $Either$Type<($BlockStateProvider$Type), ($Material$Type)>, middleLayerProvider: $Either$Type<($BlockStateProvider$Type), ($Material$Type)>, outerLayerProvider: $Either$Type<($BlockStateProvider$Type), ($Material$Type)>, innerPlacements: $List$Type<($BlockState$Type)>, cannotReplace: $TagKey$Type<($Block$Type)>, invalidBlocks: $TagKey$Type<($Block$Type)>, providerMaterialPrefix: $TagPrefix$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "middleLayerProvider"(): $Either<($BlockStateProvider), ($Material)>
public "providerMaterialPrefix"(): $TagPrefix
public "alternateInnerLayerProvider"(): $Either<($BlockStateProvider), ($Material)>
public "invalidBlocks"(): $TagKey<($Block)>
public "innerLayerProvider"(): $Either<($BlockStateProvider), ($Material)>
public "outerLayerProvider"(): $Either<($BlockStateProvider), ($Material)>
public "cannotReplace"(): $TagKey<($Block)>
public "innerPlacements"(): $List<($BlockState)>
public "fillingProvider"(): $Either<($BlockStateProvider), ($Material)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeodeVeinGenerator$GeodeBlockSettings$Type = ($GeodeVeinGenerator$GeodeBlockSettings);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeodeVeinGenerator$GeodeBlockSettings_ = $GeodeVeinGenerator$GeodeBlockSettings$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType" {
import {$IGTToolDefinition, $IGTToolDefinition$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$IGTToolDefinition"
import {$GTToolType$Builder, $GTToolType$Builder$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType$Builder"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$GTToolType$ToolConstructor, $GTToolType$ToolConstructor$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType$ToolConstructor"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$SoundEntry, $SoundEntry$Type} from "packages/com/gregtechceu/gtceu/api/sound/$SoundEntry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GTToolType {
static readonly "SWORD": $GTToolType
static readonly "PICKAXE": $GTToolType
static readonly "SHOVEL": $GTToolType
static readonly "AXE": $GTToolType
static readonly "HOE": $GTToolType
static readonly "MINING_HAMMER": $GTToolType
static readonly "SPADE": $GTToolType
static readonly "SCYTHE": $GTToolType
static readonly "SAW": $GTToolType
static readonly "HARD_HAMMER": $GTToolType
static readonly "SOFT_MALLET": $GTToolType
static readonly "WRENCH": $GTToolType
static readonly "FILE": $GTToolType
static readonly "CROWBAR": $GTToolType
static readonly "SCREWDRIVER": $GTToolType
static readonly "MORTAR": $GTToolType
static readonly "WIRE_CUTTER": $GTToolType
static readonly "KNIFE": $GTToolType
static readonly "BUTCHERY_KNIFE": $GTToolType
static readonly "PLUNGER": $GTToolType
static readonly "SHEARS": $GTToolType
static readonly "DRILL_LV": $GTToolType
static readonly "DRILL_MV": $GTToolType
static readonly "DRILL_HV": $GTToolType
static readonly "DRILL_EV": $GTToolType
static readonly "DRILL_IV": $GTToolType
static readonly "CHAINSAW_LV": $GTToolType
static readonly "WRENCH_LV": $GTToolType
static readonly "WRENCH_HV": $GTToolType
static readonly "WRENCH_IV": $GTToolType
static readonly "BUZZSAW": $GTToolType
static readonly "SCREWDRIVER_LV": $GTToolType
readonly "name": string
readonly "idFormat": string
readonly "itemTags": $List<($TagKey<($Item)>)>
readonly "harvestTags": $List<($TagKey<($Block)>)>
readonly "modelLocation": $ResourceLocation
readonly "toolClassNames": $Set<(string)>
readonly "toolClasses": $Set<($GTToolType)>
readonly "soundEntry": $SoundEntry
readonly "playSoundOnBlockDestroy": boolean
readonly "symbol": character
readonly "toolDefinition": $IGTToolDefinition
readonly "constructor": $GTToolType$ToolConstructor
readonly "electricTier": integer

constructor(name: string, idFormat: string, symbol: character, toolClasses: $Set$Type<($GTToolType$Type)>, toolDefinition: $IGTToolDefinition$Type, arg5: $GTToolType$ToolConstructor$Type, harvestTags: $List$Type<($TagKey$Type<($Block$Type)>)>, itemTags: $List$Type<($TagKey$Type<($Item$Type)>)>, modelLocation: $ResourceLocation$Type, toolClassNames: $Set$Type<(string)>, soundEntry: $SoundEntry$Type, playSoundOnBlockDestroy: boolean, electricTier: integer)

public static "builder"(name: string): $GTToolType$Builder
public "is"(itemStack: $ItemStack$Type): boolean
public static "getTypes"(): $Map<(string), ($GTToolType)>
public "getUnlocalizedName"(): string
get "types"(): $Map<(string), ($GTToolType)>
get "unlocalizedName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTToolType$Type = ($GTToolType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTToolType_ = $GTToolType$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/capability/$IWorkable" {
import {$IControllable, $IControllable$Type} from "packages/com/gregtechceu/gtceu/api/capability/$IControllable"

export interface $IWorkable extends $IControllable {

 "isActive"(): boolean
 "getProgress"(): integer
 "getMaxProgress"(): integer
 "setWorkingEnabled"(arg0: boolean): void
 "isWorkingEnabled"(): boolean
}

export namespace $IWorkable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IWorkable$Type = ($IWorkable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IWorkable_ = $IWorkable$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/laser/$LaserPipeType" {
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$Type} from "packages/net/minecraft/util/$StringRepresentable$EnumCodec"
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$LaserPipeProperties, $LaserPipeProperties$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/laser/$LaserPipeProperties"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IPipeType, $IPipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeType"

export class $LaserPipeType extends $Enum<($LaserPipeType)> implements $IPipeType<($LaserPipeProperties)>, $StringRepresentable {
static readonly "NORMAL": $LaserPipeType
static readonly "TYPE_ID": $ResourceLocation


public "type"(): $ResourceLocation
public static "values"(): ($LaserPipeType)[]
public static "valueOf"(name: string): $LaserPipeType
public "getSerializedName"(): string
public "getThickness"(): float
public "modifyProperties"(baseProperties: $LaserPipeProperties$Type): $LaserPipeProperties
public "isPaintable"(): boolean
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>, arg1: $Function$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$Type)[]): $Keyable
get "serializedName"(): string
get "thickness"(): float
get "paintable"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LaserPipeType$Type = (("normal")) | ($LaserPipeType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LaserPipeType_ = $LaserPipeType$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/optical/$OpticalRoutePath" {
import {$IOpticalComputationProvider, $IOpticalComputationProvider$Type} from "packages/com/gregtechceu/gtceu/api/capability/$IOpticalComputationProvider"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$IRoutePath, $IRoutePath$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IRoutePath"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IOpticalDataAccessHatch, $IOpticalDataAccessHatch$Type} from "packages/com/gregtechceu/gtceu/api/capability/$IOpticalDataAccessHatch"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$OpticalPipeBlockEntity, $OpticalPipeBlockEntity$Type} from "packages/com/gregtechceu/gtceu/common/blockentity/$OpticalPipeBlockEntity"

export class $OpticalRoutePath implements $IRoutePath<($IOpticalComputationProvider)> {

constructor(targetPipe: $OpticalPipeBlockEntity$Type, targetFacing: $Direction$Type, distance: integer)

public "getDistance"(): integer
public "getTargetPipePos"(): $BlockPos
public "getTargetFacing"(): $Direction
public "getDataHatch"(): $IOpticalDataAccessHatch
public "getComputationHatch"(): $IOpticalComputationProvider
public "getTargetPipe"(): $OpticalPipeBlockEntity
public "getTargetBlockEntity"(level: $Level$Type): $BlockEntity
public "getTargetCapability"<I>(capability: $Capability$Type<(I)>, level: $Level$Type): I
get "distance"(): integer
get "targetPipePos"(): $BlockPos
get "targetFacing"(): $Direction
get "dataHatch"(): $IOpticalDataAccessHatch
get "computationHatch"(): $IOpticalComputationProvider
get "targetPipe"(): $OpticalPipeBlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OpticalRoutePath$Type = ($OpticalRoutePath);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OpticalRoutePath_ = $OpticalRoutePath$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/registry/registrate/$MultiblockMachineBuilder" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IMultiPart, $IMultiPart$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/multiblock/$IMultiPart"
import {$NonNullConsumer, $NonNullConsumer$Type} from "packages/com/tterrag/registrate/util/nullness/$NonNullConsumer"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$IMultiController, $IMultiController$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/multiblock/$IMultiController"
import {$CompassNode, $CompassNode$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$CompassNode"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Registrate, $Registrate$Type} from "packages/com/tterrag/registrate/$Registrate"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$TriFunction, $TriFunction$Type} from "packages/org/apache/commons/lang3/function/$TriFunction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IMachineBlockEntity, $IMachineBlockEntity$Type} from "packages/com/gregtechceu/gtceu/api/machine/$IMachineBlockEntity"
import {$MultiblockShapeInfo, $MultiblockShapeInfo$Type} from "packages/com/gregtechceu/gtceu/api/pattern/$MultiblockShapeInfo"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$MachineBuilder, $MachineBuilder$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$MachineBuilder"
import {$IMachineBlock, $IMachineBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$IMachineBlock"
import {$CompassSection, $CompassSection$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$CompassSection"
import {$GTRecipeType, $GTRecipeType$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipeType"
import {$RecipeModifier, $RecipeModifier$Type} from "packages/com/gregtechceu/gtceu/api/recipe/modifier/$RecipeModifier"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$MetaMachineItem, $MetaMachineItem$Type} from "packages/com/gregtechceu/gtceu/api/item/$MetaMachineItem"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$RecipeCapability, $RecipeCapability$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$RecipeCapability"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$IRecipeLogicMachine, $IRecipeLogicMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/$IRecipeLogicMachine"
import {$MultiblockMachineDefinition, $MultiblockMachineDefinition$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MultiblockMachineDefinition"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"
import {$BlockPattern, $BlockPattern$Type} from "packages/com/gregtechceu/gtceu/api/pattern/$BlockPattern"
import {$Object2IntMap, $Object2IntMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntMap"

export class $MultiblockMachineBuilder extends $MachineBuilder<($MultiblockMachineDefinition)> {
 "id": $ResourceLocation


public "register"(): $MultiblockMachineDefinition
public "generator"(generator: boolean): $MultiblockMachineBuilder
public "pattern"(pattern: $Function$Type<($MultiblockMachineDefinition$Type), ($BlockPattern$Type)>): $MultiblockMachineBuilder
public "shape"(shape: $VoxelShape$Type): $MultiblockMachineBuilder
public "recipeTypes"(...recipeTypes: ($GTRecipeType$Type)[]): $MultiblockMachineBuilder
public "tier"(tier: integer): $MultiblockMachineBuilder
public "onBlockEntityRegister"(onBlockEntityRegister: $NonNullConsumer$Type<($BlockEntityType$Type<($BlockEntity$Type)>)>): $MultiblockMachineBuilder
public "overlaySteamHullRenderer"(name: string): $MultiblockMachineBuilder
public "overlayTieredHullRenderer"(name: string): $MultiblockMachineBuilder
public "workableCasingRenderer"(baseCasing: $ResourceLocation$Type, overlayModel: $ResourceLocation$Type): $MultiblockMachineBuilder
public "workableCasingRenderer"(baseCasing: $ResourceLocation$Type, overlayModel: $ResourceLocation$Type, tint: boolean): $MultiblockMachineBuilder
public "recipeModifiers"(...recipeModifiers: ($RecipeModifier$Type)[]): $MultiblockMachineBuilder
public "recipeModifiers"(alwaysTryModifyRecipe: boolean, ...recipeModifiers: ($RecipeModifier$Type)[]): $MultiblockMachineBuilder
public "appearanceBlock"(block: $Supplier$Type<(any)>): $MultiblockMachineBuilder
public "compassNodeSelf"(): $MultiblockMachineBuilder
public "addOutputLimit"(capability: $RecipeCapability$Type<(any)>, limit: integer): $MultiblockMachineBuilder
public "compassPreNodes"(...compassNodes: ($ResourceLocation$Type)[]): $MultiblockMachineBuilder
public "compassPreNodes"(section: $CompassSection$Type, ...compassNodes: (string)[]): $MultiblockMachineBuilder
public "compassPreNodes"(...compassNodes: ($CompassNode$Type)[]): $MultiblockMachineBuilder
public "appearance"(state: $Supplier$Type<($BlockState$Type)>): $MultiblockMachineBuilder
public "allowExtendedFacing"(allowExtendedFacing: boolean): $MultiblockMachineBuilder
public static "createMulti"(registrate: $Registrate$Type, name: string, metaMachine: $Function$Type<($IMachineBlockEntity$Type), (any)>, blockFactory: $BiFunction$Type<($BlockBehaviour$Properties$Type), ($MultiblockMachineDefinition$Type), ($IMachineBlock$Type)>, itemFactory: $BiFunction$Type<($IMachineBlock$Type), ($Item$Properties$Type), ($MetaMachineItem$Type)>, blockEntityFactory: $TriFunction$Type<($BlockEntityType$Type<(any)>), ($BlockPos$Type), ($BlockState$Type), ($IMachineBlockEntity$Type)>): $MultiblockMachineBuilder
public "modelRenderer"(model: $Supplier$Type<($ResourceLocation$Type)>): $MultiblockMachineBuilder
public "onWorking"(onWorking: $Predicate$Type<($IRecipeLogicMachine$Type)>): $MultiblockMachineBuilder
public "afterWorking"(afterWorking: $Consumer$Type<($IRecipeLogicMachine$Type)>): $MultiblockMachineBuilder
public "onWaiting"(onWaiting: $Consumer$Type<($IRecipeLogicMachine$Type)>): $MultiblockMachineBuilder
public "recipeOutputLimits"(map: $Object2IntMap$Type<($RecipeCapability$Type<(any)>)>): $MultiblockMachineBuilder
public "sidedWorkableCasingRenderer"(basePath: string, overlayModel: $ResourceLocation$Type): $MultiblockMachineBuilder
public "additionalDisplay"(): $BiConsumer<($IMultiController), ($List<($Component)>)>
public "additionalDisplay"(additionalDisplay: $BiConsumer$Type<($IMultiController$Type), ($List$Type<($Component$Type)>)>): $MultiblockMachineBuilder
public "shapeInfo"(shape: $Function$Type<($MultiblockMachineDefinition$Type), ($MultiblockShapeInfo$Type)>): $MultiblockMachineBuilder
public "recoveryStacks"(stacks: $Supplier$Type<(($ItemStack$Type)[])>): $MultiblockMachineBuilder
public "shapeInfos"(shapes: $Function$Type<($MultiblockMachineDefinition$Type), ($List$Type<($MultiblockShapeInfo$Type)>)>): $MultiblockMachineBuilder
public "recoveryItems"(items: $Supplier$Type<(($ItemLike$Type)[])>): $MultiblockMachineBuilder
public "allowFlip"(allowFlip: boolean): $MultiblockMachineBuilder
public "partSorter"(partSorter: $Comparator$Type<($IMultiPart$Type)>): $MultiblockMachineBuilder
public "partAppearance"(partAppearance: $TriFunction$Type<($IMultiController$Type), ($IMultiPart$Type), ($Direction$Type), ($BlockState$Type)>): $MultiblockMachineBuilder
public "compassSections"(...sections: ($CompassSection$Type)[]): $MultiblockMachineBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiblockMachineBuilder$Type = ($MultiblockMachineBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiblockMachineBuilder_ = $MultiblockMachineBuilder$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/sound/$SoundEntry" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$BooleanSupplier, $BooleanSupplier$Type} from "packages/java/util/function/$BooleanSupplier"
import {$Vec3i, $Vec3i$Type} from "packages/net/minecraft/core/$Vec3i"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$AutoReleasedSound, $AutoReleasedSound$Type} from "packages/com/gregtechceu/gtceu/api/sound/$AutoReleasedSound"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$SoundSource, $SoundSource$Type} from "packages/net/minecraft/sounds/$SoundSource"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $SoundEntry {

constructor(id: $ResourceLocation$Type, subtitle: string, category: $SoundSource$Type, attenuationDistance: integer)

public "register"(arg0: $Consumer$Type<($SoundEvent$Type)>): void
public "write"(arg0: $JsonObject$Type): void
public "getId"(): $ResourceLocation
public "prepare"(): void
public "play"(world: $Level$Type, entity: $Player$Type, pos: $Vec3i$Type): void
public "play"(world: $Level$Type, entity: $Player$Type, pos: $Vec3i$Type, volume: float, pitch: float): void
public "play"(world: $Level$Type, entity: $Player$Type, pos: $Vec3$Type, volume: float, pitch: float): void
public "play"(arg0: $Level$Type, arg1: $Player$Type, arg2: double, arg3: double, arg4: double, arg5: float, arg6: float): void
public "playOnServer"(world: $Level$Type, pos: $Vec3i$Type, volume: float, pitch: float): void
public "playOnServer"(world: $Level$Type, pos: $Vec3i$Type): void
public "getMainEvent"(): $SoundEvent
public "playAt"(world: $Level$Type, pos: $Vec3i$Type, volume: float, pitch: float, fade: boolean): void
public "playAt"(world: $Level$Type, pos: $Vec3$Type, volume: float, pitch: float, fade: boolean): void
public "playAt"(arg0: $Level$Type, arg1: double, arg2: double, arg3: double, arg4: float, arg5: float, arg6: boolean): void
public "getSubtitleKey"(): string
public "getSubtitle"(): string
public "hasSubtitle"(): boolean
public "playFrom"(entity: $Entity$Type): void
public "playFrom"(entity: $Entity$Type, volume: float, pitch: float): void
public "playAutoReleasedSound"(predicate: $BooleanSupplier$Type, pos: $BlockPos$Type, loop: boolean, delay: integer, volume: float, pitch: float): $AutoReleasedSound
get "id"(): $ResourceLocation
get "mainEvent"(): $SoundEvent
get "subtitleKey"(): string
get "subtitle"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundEntry$Type = ($SoundEntry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SoundEntry_ = $SoundEntry$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/tool/behavior/$IToolBehavior" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IGTTool, $IGTTool$Type} from "packages/com/gregtechceu/gtceu/api/item/$IGTTool"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $IToolBehavior {

 "init"(toolItem: $IGTTool$Type): void
 "onItemRightClick"(world: $Level$Type, player: $Player$Type, hand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
 "addInformation"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
 "onItemUseFirst"(stack: $ItemStack$Type, context: $UseOnContext$Type): $InteractionResult
 "onBlockStartBreak"(stack: $ItemStack$Type, pos: $BlockPos$Type, player: $Player$Type): void
 "canDisableShield"(stack: $ItemStack$Type, shield: $ItemStack$Type, entity: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
 "hitEntity"(stack: $ItemStack$Type, target: $LivingEntity$Type, attacker: $LivingEntity$Type): void
 "onBlockDestroyed"(stack: $ItemStack$Type, world: $Level$Type, state: $BlockState$Type, pos: $BlockPos$Type, entityLiving: $LivingEntity$Type): void
 "onEntitySwing"(entityLiving: $LivingEntity$Type, stack: $ItemStack$Type): void
 "onItemUse"(context: $UseOnContext$Type): $InteractionResult
 "addBehaviorNBT"(stack: $ItemStack$Type, tag: $CompoundTag$Type): void
 "shouldOpenUIAfterUse"(context: $UseOnContext$Type): boolean
}

export namespace $IToolBehavior {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IToolBehavior$Type = ($IToolBehavior);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IToolBehavior_ = $IToolBehavior$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/armor/$ArmorComponentItem" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$IArmorLogic, $IArmorLogic$Type} from "packages/com/gregtechceu/gtceu/api/item/armor/$IArmorLogic"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Equipable, $Equipable$Type} from "packages/net/minecraft/world/item/$Equipable"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$FoodProperties, $FoodProperties$Type} from "packages/net/minecraft/world/food/$FoodProperties"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IItemComponent, $IItemComponent$Type} from "packages/com/gregtechceu/gtceu/api/item/component/$IItemComponent"
import {$ArmorItem$Type, $ArmorItem$Type$Type} from "packages/net/minecraft/world/item/$ArmorItem$Type"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$IClientItemExtensions, $IClientItemExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientItemExtensions"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$IComponentItem, $IComponentItem$Type} from "packages/com/gregtechceu/gtceu/api/item/$IComponentItem"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$ArmorItem, $ArmorItem$Type} from "packages/net/minecraft/world/item/$ArmorItem"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$DispenseItemBehavior, $DispenseItemBehavior$Type} from "packages/net/minecraft/core/dispenser/$DispenseItemBehavior"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ArmorComponentItem extends $ArmorItem implements $IComponentItem {
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
readonly "type": $ArmorItem$Type
readonly "knockbackResistance": float
readonly "material": $ArmorMaterial
 "defaultModifiers": $Multimap<($Attribute), ($AttributeModifier)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "descriptionId": string
 "foodProperties": $FoodProperties
readonly "canRepair": boolean
 "renderProperties": any
 "moonlight$clientAnimationProvider": any

constructor(material: $ArmorMaterial$Type, type: $ArmorItem$Type$Type, properties: $Item$Properties$Type)

public "getCapability"<T>(itemStack: $ItemStack$Type, cap: $Capability$Type<(T)>): $LazyOptional<(T)>
public "getComponents"(): $List<($IItemComponent)>
public "appendHoverText"(stack: $ItemStack$Type, level: $Level$Type, tooltipComponents: $List$Type<($Component$Type)>, isAdvanced: $TooltipFlag$Type): void
public "getName"(stack: $ItemStack$Type): $Component
public "getCraftingRemainingItem"(itemStack: $ItemStack$Type): $ItemStack
public "hasCraftingRemainingItem"(stack: $ItemStack$Type): boolean
public "getAttributeModifiers"(slot: $EquipmentSlot$Type, stack: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "initializeClient"(consumer: $Consumer$Type<($IClientItemExtensions$Type)>): void
public "use"(level: $Level$Type, player: $Player$Type, usedHand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "useOn"(context: $UseOnContext$Type): $InteractionResult
public "finishUsingItem"(stack: $ItemStack$Type, level: $Level$Type, livingEntity: $LivingEntity$Type): $ItemStack
public "isBarVisible"(stack: $ItemStack$Type): boolean
public "getBarColor"(stack: $ItemStack$Type): integer
public "getMaxDamage"(stack: $ItemStack$Type): integer
public "getBarWidth"(stack: $ItemStack$Type): integer
public "interactLivingEntity"(stack: $ItemStack$Type, player: $Player$Type, interactionTarget: $LivingEntity$Type, usedHand: $InteractionHand$Type): $InteractionResult
public "getDescriptionId"(stack: $ItemStack$Type): string
public "inventoryTick"(stack: $ItemStack$Type, level: $Level$Type, entity: $Entity$Type, slotId: integer, isSelected: boolean): void
public "getEnchantmentValue"(): integer
public "isValidRepairItem"(stack: $ItemStack$Type, repairCandidate: $ItemStack$Type): boolean
public "isEnchantable"(stack: $ItemStack$Type): boolean
public "onArmorTick"(stack: $ItemStack$Type, level: $Level$Type, player: $Player$Type): void
public "onItemUseFirst"(itemStack: $ItemStack$Type, context: $UseOnContext$Type): $InteractionResult
public "getArmorTexture"(stack: $ItemStack$Type, entity: $Entity$Type, slot: $EquipmentSlot$Type, type: string): string
public "getType"(): $ArmorItem$Type
public "fillItemCategory"(category: $CreativeModeTab$Type, items: $NonNullList$Type<($ItemStack$Type)>): void
public "damageArmor"(entity: $LivingEntity$Type, stack: $ItemStack$Type, source: $DamageSource$Type, damage: integer, slot: $EquipmentSlot$Type): void
public "getEquipmentSlot"(): $EquipmentSlot
public "attachComponents"(...components: ($IItemComponent$Type)[]): void
public "getArmorDisplay"(player: $Player$Type, armor: $ItemStack$Type, slot: $EquipmentSlot$Type): integer
public "getArmorLogic"(): $IArmorLogic
public "setArmorLogic"(armorLogic: $IArmorLogic$Type): $ArmorComponentItem
public "asItem"(): $Item
public static "get"(arg0: $ItemStack$Type): $Equipable
get "components"(): $List<($IItemComponent)>
get "enchantmentValue"(): integer
get "type"(): $ArmorItem$Type
get "equipmentSlot"(): $EquipmentSlot
get "armorLogic"(): $IArmorLogic
set "armorLogic"(value: $IArmorLogic$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorComponentItem$Type = ($ArmorComponentItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArmorComponentItem_ = $ArmorComponentItem$Type;
}}
declare module "packages/com/gregtechceu/gtceu/integration/kjs/builders/block/$CoilBlockBuilder" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$BlockBuilder, $BlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockBuilder"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$AssetJsonGenerator, $AssetJsonGenerator$Type} from "packages/dev/latvian/mods/kubejs/generator/$AssetJsonGenerator"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $CoilBlockBuilder extends $BlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
 "lootTable": $Consumer<($LootBuilder)>
 "blockstateJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "level"(level: integer): $CoilBlockBuilder
public "createObject"(): $Block
public "texture"(texture: $ResourceLocation$Type): $CoilBlockBuilder
public "temperature"(temperature: integer): $CoilBlockBuilder
public "generateAssetJsons"(generator: $AssetJsonGenerator$Type): void
public "tier"(tier: integer): $CoilBlockBuilder
public "coilMaterial"(material: $Supplier$Type<($Material$Type)>): $CoilBlockBuilder
public "energyDiscount"(energyDiscount: integer): $CoilBlockBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoilBlockBuilder$Type = ($CoilBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CoilBlockBuilder_ = $CoilBlockBuilder$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/data/$GTOres" {
import {$GTOreDefinition, $GTOreDefinition$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTOreDefinition"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$RuleTest, $RuleTest$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$RuleTest"
import {$BedrockOreDefinition, $BedrockOreDefinition$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/bedrockore/$BedrockOreDefinition"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GTOres {
static readonly "toReRegisterBedrock": $Map<($ResourceLocation), ($BedrockOreDefinition)>
static "END_RULES": ($RuleTest)[]
static readonly "BAUXITE_VEIN_END": $GTOreDefinition
static readonly "MAGNETITE_VEIN_END": $GTOreDefinition
static readonly "NAQUADAH_VEIN": $GTOreDefinition
static readonly "PITCHBLENDE_VEIN": $GTOreDefinition
static readonly "SCHEELITE_VEIN": $GTOreDefinition
static readonly "SHELDONITE_VEIN": $GTOreDefinition
static "NETHER_RULES": ($RuleTest)[]
static readonly "BANDED_IRON_VEIN": $GTOreDefinition
static readonly "BERYLLIUM_VEIN": $GTOreDefinition
static readonly "CERTUS_QUARTZ_VEIN": $GTOreDefinition
static readonly "MANGANESE_VEIN": $GTOreDefinition
static readonly "MOLYBDENUM_VEIN": $GTOreDefinition
static readonly "MONAZITE_VEIN": $GTOreDefinition
static readonly "NETHER_QUARTZ_VEIN": $GTOreDefinition
static readonly "REDSTONE_VEIN": $GTOreDefinition
static readonly "SALTPETER_VEIN": $GTOreDefinition
static readonly "SULFUR_VEIN": $GTOreDefinition
static readonly "TETRAHEDRITE_VEIN": $GTOreDefinition
static readonly "TOPAZ_VEIN": $GTOreDefinition
static "OVERWORLD_RULES": ($RuleTest)[]
static readonly "APATITE_VEIN": $GTOreDefinition
static readonly "CASSITERITE_VEIN": $GTOreDefinition
static readonly "COAL_VEIN": $GTOreDefinition
static readonly "COPPER_TIN_VEIN": $GTOreDefinition
static readonly "GALENA_VEIN": $GTOreDefinition
static readonly "GARNET_TIN_VEIN": $GTOreDefinition
static readonly "GARNET_VEIN": $GTOreDefinition
static readonly "IRON_VEIN": $GTOreDefinition
static readonly "LUBRICANT_VEIN": $GTOreDefinition
static readonly "MAGNETITE_VEIN_OW": $GTOreDefinition
static readonly "MINERAL_SAND_VEIN": $GTOreDefinition
static readonly "NICKEL_VEIN": $GTOreDefinition
static readonly "SALTS_VEIN": $GTOreDefinition
static readonly "OILSANDS_VEIN": $GTOreDefinition
static "DEEPSLATE_RULES": ($RuleTest)[]
static readonly "COPPER_VEIN": $GTOreDefinition
static readonly "DIAMOND_VEIN": $GTOreDefinition
static readonly "LAPIS_VEIN": $GTOreDefinition
static readonly "MANGANESE_VEIN_OW": $GTOreDefinition
static readonly "MICA_VEIN": $GTOreDefinition
static readonly "OLIVINE_VEIN": $GTOreDefinition
static readonly "REDSTONE_VEIN_OW": $GTOreDefinition
static readonly "SAPPHIRE_VEIN": $GTOreDefinition

constructor()

public static "init"(): void
public static "create"(name: $ResourceLocation$Type, config: $Consumer$Type<($GTOreDefinition$Type)>): $GTOreDefinition
public static "getLargestIndicatorOffset"(): integer
public static "updateLargestVeinSize"(): void
public static "blankOreDefinition"(): $GTOreDefinition
public static "getLargestVeinSize"(): integer
get "largestIndicatorOffset"(): integer
get "largestVeinSize"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTOres$Type = ($GTOres);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTOres_ = $GTOres$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/tool/$GTShovelItem" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$ShovelItem, $ShovelItem$Type} from "packages/net/minecraft/world/item/$ShovelItem"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$FoodProperties, $FoodProperties$Type} from "packages/net/minecraft/world/food/$FoodProperties"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IGTTool, $IGTTool$Type} from "packages/com/gregtechceu/gtceu/api/item/$IGTTool"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$DustProperty, $DustProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$DustProperty"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$IGTToolDefinition, $IGTToolDefinition$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$IGTToolDefinition"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$HeldItemUIFactory$HeldItemHolder, $HeldItemUIFactory$HeldItemHolder$Type} from "packages/com/lowdragmc/lowdraglib/gui/factory/$HeldItemUIFactory$HeldItemHolder"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$ItemColor, $ItemColor$Type} from "packages/net/minecraft/client/color/item/$ItemColor"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$GTToolType, $GTToolType$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$MaterialToolTier, $MaterialToolTier$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$MaterialToolTier"
import {$ModularUI, $ModularUI$Type} from "packages/com/lowdragmc/lowdraglib/gui/modular/$ModularUI"
import {$ToolProperty, $ToolProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$ToolProperty"
import {$SoundEntry, $SoundEntry$Type} from "packages/com/gregtechceu/gtceu/api/sound/$SoundEntry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GTShovelItem extends $ShovelItem implements $IGTTool {
static "FLATTENABLES": $Map<($Block), ($BlockState)>
 "speed": float
 "defaultModifiers": $Multimap<($Attribute), ($AttributeModifier)>
 "tier": $Tier
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "descriptionId": string
 "foodProperties": $FoodProperties
readonly "canRepair": boolean
 "renderProperties": any
 "moonlight$clientAnimationProvider": any


public static "create"(toolType: $GTToolType$Type, tier: $MaterialToolTier$Type, material: $Material$Type, toolStats: $IGTToolDefinition$Type, properties: $Item$Properties$Type): $GTShovelItem
public "getDamage"(stack: $ItemStack$Type): integer
public "appendHoverText"(stack: $ItemStack$Type, level: $Level$Type, tooltipComponents: $List$Type<($Component$Type)>, isAdvanced: $TooltipFlag$Type): void
public "getName"(stack: $ItemStack$Type): $Component
public "shouldCauseReequipAnimation"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type, slotChanged: boolean): boolean
public "isCorrectToolForDrops"(stack: $ItemStack$Type, state: $BlockState$Type): boolean
public "getCraftingRemainingItem"(itemStack: $ItemStack$Type): $ItemStack
public "hasCraftingRemainingItem"(stack: $ItemStack$Type): boolean
public "getAttributeModifiers"(slot: $EquipmentSlot$Type, stack: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "use"(level: $Level$Type, player: $Player$Type, usedHand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "useOn"(context: $UseOnContext$Type): $InteractionResult
public "getDestroySpeed"(stack: $ItemStack$Type, state: $BlockState$Type): float
public "hurtEnemy"(stack: $ItemStack$Type, target: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
public "getMaxDamage"(stack: $ItemStack$Type): integer
public "mineBlock"(stack: $ItemStack$Type, level: $Level$Type, state: $BlockState$Type, pos: $BlockPos$Type, miningEntity: $LivingEntity$Type): boolean
public "getDescription"(): $Component
public "hasCraftingRemainingItem"(): boolean
public "isValidRepairItem"(stack: $ItemStack$Type, repairCandidate: $ItemStack$Type): boolean
public "doesSneakBypassUse"(stack: $ItemStack$Type, level: $LevelReader$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "onItemUseFirst"(itemStack: $ItemStack$Type, context: $UseOnContext$Type): $InteractionResult
public "onBlockStartBreak"(stack: $ItemStack$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "isDamaged"(stack: $ItemStack$Type): boolean
public "setDamage"(stack: $ItemStack$Type, damage: integer): void
public "getSound"(): $SoundEntry
public "canDisableShield"(stack: $ItemStack$Type, shield: $ItemStack$Type, entity: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
public "getEnchantmentValue"(stack: $ItemStack$Type): integer
public "shouldCauseBlockBreakReset"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type): boolean
public "canApplyAtEnchantingTable"(stack: $ItemStack$Type, enchantment: $Enchantment$Type): boolean
public "getDescriptionId"(): string
public "getDefaultInstance"(): $ItemStack
public "initCapabilities"(stack: $ItemStack$Type, nbt: $CompoundTag$Type): $ICapabilityProvider
public "isElectric"(): boolean
public "getMaterial"(): $Material
public "playSoundOnBlockDestroy"(): boolean
public "getToolStats"(): $IGTToolDefinition
public "getElectricTier"(): integer
public "getToolType"(): $GTToolType
public "get"(defaultMaxCharge: long): $ItemStack
public "get"(): $ItemStack
public "get"(defaultCharge: long, defaultMaxCharge: long): $ItemStack
public "getRaw"(): $ItemStack
public "getColor"(stack: $ItemStack$Type, tintIndex: integer): integer
public "createUI"(entityPlayer: $Player$Type, holder: $HeldItemUIFactory$HeldItemHolder$Type): $ModularUI
public static "tintColor"(): $ItemColor
public "definition$canApplyAtEnchantingTable"(stack: $ItemStack$Type, enchantment: $Enchantment$Type): boolean
public "definition$shouldCauseReequipAnimation"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type, slotChanged: boolean): boolean
public "definition$getDefaultAttributeModifiers"(equipmentSlot: $EquipmentSlot$Type, stack: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "definition$shouldCauseBlockBreakReset"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type): boolean
public "definition$getCraftingRemainingItem"(stack: $ItemStack$Type): $ItemStack
public "definition$hasCraftingRemainingItem"(stack: $ItemStack$Type): boolean
public "definition$canDestroyBlockInCreative"(world: $Level$Type, pos: $BlockPos$Type, stack: $ItemStack$Type, player: $Player$Type): boolean
public "getCharge"(stack: $ItemStack$Type): long
public "playSound"(player: $Player$Type): void
public "asItem"(): $Item
public "definition$isDamaged"(stack: $ItemStack$Type): boolean
public "getToolMaterial"(stack: $ItemStack$Type): $Material
public "getMaxCharge"(stack: $ItemStack$Type): long
public "getToolClasses"(stack: $ItemStack$Type): $Set<($GTToolType)>
public "getTotalToolSpeed"(stack: $ItemStack$Type): float
public "getToolProperty"(stack: $ItemStack$Type): $ToolProperty
public "getDustProperty"(stack: $ItemStack$Type): $DustProperty
public "playCraftingSound"(player: $Player$Type, stack: $ItemStack$Type): void
public "definition$use"(world: $Level$Type, player: $Player$Type, hand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "definition$init"(): void
public "canPlaySound"(stack: $ItemStack$Type): boolean
public "getToolClassNames"(stack: $ItemStack$Type): $Set<(string)>
public "definition$getDestroySpeed"(stack: $ItemStack$Type, state: $BlockState$Type): float
public "getTotalAttackDamage"(stack: $ItemStack$Type): float
public "getTotalAttackSpeed"(stack: $ItemStack$Type): float
public "definition$hurtEnemy"(stack: $ItemStack$Type, target: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
public "getTotalHarvestLevel"(stack: $ItemStack$Type): integer
public "getMaterialAttackSpeed"(stack: $ItemStack$Type): float
public "definition$onBlockStartBreak"(stack: $ItemStack$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "definition$mineBlock"(stack: $ItemStack$Type, worldIn: $Level$Type, state: $BlockState$Type, pos: $BlockPos$Type, entityLiving: $LivingEntity$Type): boolean
public "definition$isValidRepairItem"(toRepair: $ItemStack$Type, repair: $ItemStack$Type): boolean
public "definition$getHarvestLevel"(stack: $ItemStack$Type, toolClass: $GTToolType$Type, player: $Player$Type, blockState: $BlockState$Type): integer
public "getMaterialAttackDamage"(stack: $ItemStack$Type): float
public "definition$canDisableShield"(stack: $ItemStack$Type, shield: $ItemStack$Type, entity: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
public "definition$doesSneakBypassUse"(stack: $ItemStack$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "getMaterialEnchantability"(stack: $ItemStack$Type): integer
public "definition$onEntitySwing"(entityLiving: $LivingEntity$Type, stack: $ItemStack$Type): boolean
public "getTotalEnchantability"(stack: $ItemStack$Type): integer
public "getMaterialDurability"(stack: $ItemStack$Type): integer
public "definition$getDamage"(stack: $ItemStack$Type): integer
public "getTotalMaxDurability"(stack: $ItemStack$Type): integer
public "getMaterialToolSpeed"(stack: $ItemStack$Type): float
public "getMaterialHarvestLevel"(stack: $ItemStack$Type): integer
public "definition$getMaxDamage"(stack: $ItemStack$Type): integer
public "definition$setDamage"(stack: $ItemStack$Type, durability: integer): void
public "definition$getDurabilityForDisplay"(stack: $ItemStack$Type): double
public "definition$onItemUse"(context: $UseOnContext$Type): $InteractionResult
public "setLastCraftingSoundTime"(stack: $ItemStack$Type): void
public "definition$initCapabilities"(stack: $ItemStack$Type, nbt: $CompoundTag$Type): $ICapabilityProvider
public "definition$appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "definition$shouldOpenUIAfterUse"(context: $UseOnContext$Type): boolean
public "definition$fillItemCategory"(category: $CreativeModeTab$Type, items: $NonNullList$Type<($ItemStack$Type)>): void
public "definition$onItemUseFirst"(stack: $ItemStack$Type, context: $UseOnContext$Type): $InteractionResult
public "definition$isCorrectToolForDrops"(stack: $ItemStack$Type, state: $BlockState$Type): boolean
get "description"(): $Component
get "sound"(): $SoundEntry
get "descriptionId"(): string
get "defaultInstance"(): $ItemStack
get "electric"(): boolean
get "material"(): $Material
get "toolStats"(): $IGTToolDefinition
get "electricTier"(): integer
get "toolType"(): $GTToolType
get "raw"(): $ItemStack
set "lastCraftingSoundTime"(value: $ItemStack$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTShovelItem$Type = ($GTShovelItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTShovelItem_ = $GTShovelItem$Type;
}}
declare module "packages/com/gregtechceu/gtceu/integration/kjs/recipe/components/$GTRecipeComponents$FluidIngredientJS" {
import {$FluidIngredient, $FluidIngredient$Type} from "packages/com/gregtechceu/gtceu/api/recipe/ingredient/$FluidIngredient"
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$InputReplacementTransformer$Replacement, $InputReplacementTransformer$Replacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacementTransformer$Replacement"
import {$InputFluid, $InputFluid$Type} from "packages/dev/latvian/mods/kubejs/fluid/$InputFluid"
import {$OutputFluid, $OutputFluid$Type} from "packages/dev/latvian/mods/kubejs/fluid/$OutputFluid"
import {$FluidLike, $FluidLike$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FluidLike"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$OutputReplacementTransformer$Replacement, $OutputReplacementTransformer$Replacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacementTransformer$Replacement"
import {$InputReplacementTransformer, $InputReplacementTransformer$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacementTransformer"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacementTransformer, $OutputReplacementTransformer$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacementTransformer"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export class $GTRecipeComponents$FluidIngredientJS implements $InputFluid, $OutputFluid {

constructor(ingredient: $FluidIngredient$Type)

public "matches"(other: $FluidLike$Type): boolean
public static "of"(o: any): $GTRecipeComponents$FluidIngredientJS
public "getAmount"(): long
public "replaceInput"(recipe: $RecipeJS$Type, match: $ReplacementMatch$Type, original: $InputReplacement$Type): any
public "replaceOutput"(recipe: $RecipeJS$Type, match: $ReplacementMatch$Type, original: $OutputReplacement$Type): any
public "isEmpty"(): boolean
public "transform"(transformer: $InputReplacementTransformer$Type): $InputReplacementTransformer$Replacement
public "transform"(transformer: $OutputReplacementTransformer$Type): $OutputReplacementTransformer$Replacement
get "amount"(): long
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTRecipeComponents$FluidIngredientJS$Type = ($GTRecipeComponents$FluidIngredientJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTRecipeComponents$FluidIngredientJS_ = $GTRecipeComponents$FluidIngredientJS$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/capability/$ICoverable" {
import {$ITickSubscription, $ITickSubscription$Type} from "packages/com/gregtechceu/gtceu/api/blockentity/$ITickSubscription"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$IItemTransfer, $IItemTransfer$Type} from "packages/com/lowdragmc/lowdraglib/side/item/$IItemTransfer"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CoverDefinition, $CoverDefinition$Type} from "packages/com/gregtechceu/gtceu/api/cover/$CoverDefinition"
import {$CoverBehavior, $CoverBehavior$Type} from "packages/com/gregtechceu/gtceu/api/cover/$CoverBehavior"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IFluidTransfer, $IFluidTransfer$Type} from "packages/com/lowdragmc/lowdraglib/side/fluid/$IFluidTransfer"
import {$IAppearance, $IAppearance$Type} from "packages/com/gregtechceu/gtceu/api/block/$IAppearance"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$TickableSubscription, $TickableSubscription$Type} from "packages/com/gregtechceu/gtceu/api/machine/$TickableSubscription"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export interface $ICoverable extends $ITickSubscription, $IAppearance {

 "getLevel"(): $Level
 "onLoad"(): void
 "getPos"(): $BlockPos
 "onNeighborChanged"(block: $Block$Type, fromPos: $BlockPos$Type, isMoving: boolean): void
 "isRemote"(): boolean
 "markDirty"(): void
 "onUnload"(): void
 "notifyBlockUpdate"(): void
 "canPlaceCoverOnSide"(arg0: $CoverDefinition$Type, arg1: $Direction$Type): boolean
 "shouldRenderBackSide"(): boolean
 "getCoverPlateThickness"(): double
 "getCoverAtSide"(arg0: $Direction$Type): $CoverBehavior
 "hasCover"(facing: $Direction$Type): boolean
 "setCoverAtSide"(arg0: $CoverBehavior$Type, arg1: $Direction$Type): void
 "placeCoverOnSide"(side: $Direction$Type, itemStack: $ItemStack$Type, coverDefinition: $CoverDefinition$Type, player: $ServerPlayer$Type): boolean
 "getBlockAppearance"(state: $BlockState$Type, level: $BlockAndTintGetter$Type, pos: $BlockPos$Type, side: $Direction$Type, sourceState: $BlockState$Type, sourcePos: $BlockPos$Type): $BlockState
 "scheduleRenderUpdate"(): void
 "scheduleNeighborShapeUpdate"(): void
 "addCoverCollisionBoundingBox"(): ($VoxelShape)[]
 "getFrontFacing"(): $Direction
 "dropAllCovers"(): void
 "hasAnyCover"(): boolean
 "removeCover"(side: $Direction$Type, player: $Player$Type): boolean
 "removeCover"(dropItself: boolean, side: $Direction$Type, player: $Player$Type): boolean
 "getOffsetTimer"(): long
 "isInValid"(): boolean
 "getCovers"(): $List<($CoverBehavior)>
 "getItemTransferCap"(arg0: $Direction$Type, arg1: boolean): $IItemTransfer
 "getFluidTransferCap"(arg0: $Direction$Type, arg1: boolean): $IFluidTransfer
 "unsubscribe"(arg0: $TickableSubscription$Type): void
 "subscribeServerTick"(arg0: $Runnable$Type): $TickableSubscription
 "subscribeServerTick"(last: $TickableSubscription$Type, runnable: $Runnable$Type): $TickableSubscription
}

export namespace $ICoverable {
function rayTraceCoverableSide(coverable: $ICoverable$Type, player: $Player$Type): $Direction
function getCoverPlateBox(side: $Direction$Type, plateThickness: double): $VoxelShape
function traceCoverSide(result: $BlockHitResult$Type): $Direction
function doesCoverCollide(side: $Direction$Type, collisionBox: $List$Type<($VoxelShape$Type)>, plateThickness: double): boolean
function determineGridSideHit(result: $BlockHitResult$Type): $Direction
function canPlaceCover(coverDef: $CoverDefinition$Type, coverable: $ICoverable$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICoverable$Type = ($ICoverable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICoverable_ = $ICoverable$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$FluidProperty" {
import {$FluidStorage, $FluidStorage$Type} from "packages/com/gregtechceu/gtceu/api/fluids/store/$FluidStorage"
import {$FluidStorageKey, $FluidStorageKey$Type} from "packages/com/gregtechceu/gtceu/api/fluids/store/$FluidStorageKey"
import {$IMaterialProperty, $IMaterialProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IMaterialProperty"
import {$MaterialProperties, $MaterialProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$MaterialProperties"

export class $FluidProperty implements $IMaterialProperty<($FluidProperty)> {

constructor()

public "getStorage"(): $FluidStorage
public "verifyProperty"(properties: $MaterialProperties$Type): void
public "getPrimaryKey"(): $FluidStorageKey
public "setPrimaryKey"(primaryKey: $FluidStorageKey$Type): void
get "storage"(): $FluidStorage
get "primaryKey"(): $FluidStorageKey
set "primaryKey"(value: $FluidStorageKey$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidProperty$Type = ($FluidProperty);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidProperty_ = $FluidProperty$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pipenet/$Node" {
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"

export class $Node<NodeDataType> {
static readonly "DEFAULT_MARK": integer
static readonly "ALL_OPENED": integer
static readonly "ALL_CLOSED": integer
 "data": NodeDataType
 "openConnections": integer
 "mark": integer
 "isActive": boolean

constructor(data: NodeDataType, openConnections: integer, mark: integer, isActive: boolean)

public "isBlocked"(facing: $Direction$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Node$Type<NodeDataType> = ($Node<(NodeDataType)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Node_<NodeDataType> = $Node$Type<(NodeDataType)>;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/trait/$MachineTrait" {
import {$ManagedFieldHolder, $ManagedFieldHolder$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/field/$ManagedFieldHolder"
import {$ISubscription, $ISubscription$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$ISubscription"
import {$IFieldUpdateListener, $IFieldUpdateListener$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$IFieldUpdateListener"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IEnhancedManaged, $IEnhancedManaged$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$IEnhancedManaged"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$MetaMachine, $MetaMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MetaMachine"
import {$IRef, $IRef$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/managed/$IRef"
import {$FieldManagedStorage, $FieldManagedStorage$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/field/$FieldManagedStorage"

export class $MachineTrait implements $IEnhancedManaged {

constructor(machine: $MetaMachine$Type)

public "getSyncStorage"(): $FieldManagedStorage
public "hasCapability"(side: $Direction$Type): boolean
public "onChanged"(): void
public "getMachine"(): $MetaMachine
public "scheduleRenderUpdate"(): void
public "onMachineLoad"(): void
public "onMachineUnLoad"(): void
public "setCapabilityValidator"(capabilityValidator: $Predicate$Type<($Direction$Type)>): void
public "scheduleRender"(fieldName: string, newValue: any, oldValue: any): void
public "markDirty"(name: string): void
public "getFieldHolder"(): $ManagedFieldHolder
public "onPersistedChanged"(ref: $IRef$Type, isDirty: boolean): void
public "onSyncChanged"(ref: $IRef$Type, isDirty: boolean): void
public "addSyncUpdateListener"<T>(name: string, listener: $IFieldUpdateListener$Type<(T)>): $ISubscription
get "syncStorage"(): $FieldManagedStorage
get "machine"(): $MetaMachine
set "capabilityValidator"(value: $Predicate$Type<($Direction$Type)>)
get "fieldHolder"(): $ManagedFieldHolder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineTrait$Type = ($MachineTrait);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineTrait_ = $MachineTrait$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/registry/registrate/$IGTFluidBuilder" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$RegistryEntry, $RegistryEntry$Type} from "packages/com/tterrag/registrate/util/entry/$RegistryEntry"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$FluidState, $FluidState$Type} from "packages/com/gregtechceu/gtceu/api/fluids/$FluidState"

export interface $IGTFluidBuilder {

 "register"(): $RegistryEntry<(any)>
 "state"(arg0: $FluidState$Type): $IGTFluidBuilder
 "color"(arg0: integer): $IGTFluidBuilder
 "luminance"(arg0: integer): $IGTFluidBuilder
 "density"(arg0: integer): $IGTFluidBuilder
 "viscosity"(arg0: integer): $IGTFluidBuilder
 "temperature"(arg0: integer): $IGTFluidBuilder
 "registerFluid"(): $Supplier<(any)>
 "burnTime"(arg0: integer): $IGTFluidBuilder
 "hasBlock"(arg0: boolean): $IGTFluidBuilder
 "hasBucket"(arg0: boolean): $IGTFluidBuilder
 "onFluidRegister"(arg0: $Consumer$Type<($Fluid$Type)>): $IGTFluidBuilder
}

export namespace $IGTFluidBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IGTFluidBuilder$Type = ($IGTFluidBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IGTFluidBuilder_ = $IGTFluidBuilder$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/$SurfaceRockBlock" {
import {$BlockColor, $BlockColor$Type} from "packages/net/minecraft/client/color/block/$BlockColor"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"

export class $SurfaceRockBlock extends $Block {
static readonly "FACING": $DirectionProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, material: $Material$Type)

public "getDescriptionId"(): string
public "getName"(): $MutableComponent
public "canSurvive"(state: $BlockState$Type, level: $LevelReader$Type, pos: $BlockPos$Type): boolean
public "getStateForPlacement"(context: $BlockPlaceContext$Type): $BlockState
public "neighborChanged"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, neighborBlock: $Block$Type, neighborPos: $BlockPos$Type, movedByPiston: boolean): void
public "use"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
public "isOcclusionShapeFullBlock"(state: $BlockState$Type, view: $BlockGetter$Type, pos: $BlockPos$Type): boolean
public "isCollisionShapeFullBlock"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type): boolean
public "getShape"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type, context: $CollisionContext$Type): $VoxelShape
public "getMaterial"(): $Material
public "getStateForDirection"(direction: $Direction$Type): $BlockState
public static "tintedColor"(): $BlockColor
get "descriptionId"(): string
get "name"(): $MutableComponent
get "material"(): $Material
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SurfaceRockBlock$Type = ($SurfaceRockBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SurfaceRockBlock_ = $SurfaceRockBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pipenet/longdistance/$LongDistanceNetwork" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$ILDEndpoint, $ILDEndpoint$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/longdistance/$ILDEndpoint"
import {$LongDistancePipeType, $LongDistancePipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/longdistance/$LongDistancePipeType"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $LongDistanceNetwork {


public static "get"(world: $LevelAccessor$Type, pos: $BlockPos$Type): $LongDistanceNetwork
public "isValid"(): boolean
public "getActiveOutputIndex"(): $ILDEndpoint
public "getActiveInputIndex"(): $ILDEndpoint
public "invalidateEndpoints"(): void
public "onRemoveEndpoint"(endpoint: $ILDEndpoint$Type): void
public "onPlaceEndpoint"(endpoint: $ILDEndpoint$Type): void
public "getOtherEndpoint"(endpoint: $ILDEndpoint$Type): $ILDEndpoint
public "getTotalSize"(): integer
public "getPipeType"(): $LongDistancePipeType
public "onRemovePipe"(pos: $BlockPos$Type): void
public "onPlacePipe"(pos: $BlockPos$Type): void
public "getPipeAmount"(): integer
public "getEndpointAmount"(): integer
public "isIOIndexInvalid"(): boolean
get "valid"(): boolean
get "activeOutputIndex"(): $ILDEndpoint
get "activeInputIndex"(): $ILDEndpoint
get "totalSize"(): integer
get "pipeType"(): $LongDistancePipeType
get "pipeAmount"(): integer
get "endpointAmount"(): integer
get "iOIndexInvalid"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongDistanceNetwork$Type = ($LongDistanceNetwork);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongDistanceNetwork_ = $LongDistanceNetwork$Type;
}}
declare module "packages/com/gregtechceu/gtceu/core/mixins/$IFoliagePlacerTypeAccessor" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IFoliagePlacerTypeAccessor {

}

export namespace $IFoliagePlacerTypeAccessor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFoliagePlacerTypeAccessor$Type = ($IFoliagePlacerTypeAccessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFoliagePlacerTypeAccessor_ = $IFoliagePlacerTypeAccessor$Type;
}}
declare module "packages/com/gregtechceu/gtceu/integration/kjs/$GTRegistryInfo$BuilderType" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$GTRegistryInfo$BuilderFactory, $GTRegistryInfo$BuilderFactory$Type} from "packages/com/gregtechceu/gtceu/integration/kjs/$GTRegistryInfo$BuilderFactory"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export class $GTRegistryInfo$BuilderType<T> extends $Record {

constructor(type: string, builderClass: $Class$Type<(any)>, factory: $GTRegistryInfo$BuilderFactory$Type<(T)>)

public "type"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "factory"(): $GTRegistryInfo$BuilderFactory<(T)>
public "builderClass"(): $Class<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTRegistryInfo$BuilderType$Type<T> = ($GTRegistryInfo$BuilderType<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTRegistryInfo$BuilderType_<T> = $GTRegistryInfo$BuilderType$Type<(T)>;
}}
declare module "packages/com/gregtechceu/gtceu/common/data/$GTBlocks" {
import {$GTCeilingHangingSignBlock, $GTCeilingHangingSignBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/$GTCeilingHangingSignBlock"
import {$WoodType, $WoodType$Type} from "packages/net/minecraft/world/level/block/state/properties/$WoodType"
import {$NonNullConsumer, $NonNullConsumer$Type} from "packages/com/tterrag/registrate/util/nullness/$NonNullConsumer"
import {$IndustrialTNTBlock, $IndustrialTNTBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/explosive/$IndustrialTNTBlock"
import {$PressurePlateBlock, $PressurePlateBlock$Type} from "packages/net/minecraft/world/level/block/$PressurePlateBlock"
import {$LampBlock, $LampBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/$LampBlock"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"
import {$CompassNode, $CompassNode$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$CompassNode"
import {$MinerPipeBlock, $MinerPipeBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/$MinerPipeBlock"
import {$GTWallSignBlock, $GTWallSignBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/$GTWallSignBlock"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$BlockBuilder, $BlockBuilder$Type} from "packages/com/tterrag/registrate/builders/$BlockBuilder"
import {$ItemPipeBlock, $ItemPipeBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/$ItemPipeBlock"
import {$Table, $Table$Type} from "packages/com/google/common/collect/$Table"
import {$LeavesBlock, $LeavesBlock$Type} from "packages/net/minecraft/world/level/block/$LeavesBlock"
import {$TagPrefix, $TagPrefix$Type} from "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix"
import {$BlockEntry, $BlockEntry$Type} from "packages/com/tterrag/registrate/util/entry/$BlockEntry"
import {$LongDistancePipeBlock, $LongDistancePipeBlock$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/longdistance/$LongDistancePipeBlock"
import {$BatteryBlock, $BatteryBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/$BatteryBlock"
import {$ButtonBlock, $ButtonBlock$Type} from "packages/net/minecraft/world/level/block/$ButtonBlock"
import {$DoorBlock, $DoorBlock$Type} from "packages/net/minecraft/world/level/block/$DoorBlock"
import {$StoneBlockType, $StoneBlockType$Type} from "packages/com/gregtechceu/gtceu/common/block/$StoneBlockType"
import {$StairBlock, $StairBlock$Type} from "packages/net/minecraft/world/level/block/$StairBlock"
import {$IFusionCasingType, $IFusionCasingType$Type} from "packages/com/gregtechceu/gtceu/api/block/$IFusionCasingType"
import {$StoneTypes, $StoneTypes$Type} from "packages/com/gregtechceu/gtceu/common/block/$StoneTypes"
import {$BoilerFireboxType, $BoilerFireboxType$Type} from "packages/com/gregtechceu/gtceu/common/block/$BoilerFireboxType"
import {$BlockColor, $BlockColor$Type} from "packages/net/minecraft/client/color/block/$BlockColor"
import {$TrapDoorBlock, $TrapDoorBlock$Type} from "packages/net/minecraft/world/level/block/$TrapDoorBlock"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$SurfaceRockBlock, $SurfaceRockBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/$SurfaceRockBlock"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$CoilBlock, $CoilBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/$CoilBlock"
import {$DuctPipeBlock, $DuctPipeBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/$DuctPipeBlock"
import {$DyeColor, $DyeColor$Type} from "packages/net/minecraft/world/item/$DyeColor"
import {$ImmutableMap, $ImmutableMap$Type} from "packages/com/google/common/collect/$ImmutableMap"
import {$PowderbarrelBlock, $PowderbarrelBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/explosive/$PowderbarrelBlock"
import {$GTWallHangingSignBlock, $GTWallHangingSignBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/$GTWallHangingSignBlock"
import {$SlabBlock, $SlabBlock$Type} from "packages/net/minecraft/world/level/block/$SlabBlock"
import {$LaserPipeBlock, $LaserPipeBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/$LaserPipeBlock"
import {$FluidPipeBlock, $FluidPipeBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/$FluidPipeBlock"
import {$CompassSection, $CompassSection$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$CompassSection"
import {$FenceGateBlock, $FenceGateBlock$Type} from "packages/net/minecraft/world/level/block/$FenceGateBlock"
import {$IRenderer, $IRenderer$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IRenderer"
import {$GTStandingSignBlock, $GTStandingSignBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/$GTStandingSignBlock"
import {$RubberLogBlock, $RubberLogBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/$RubberLogBlock"
import {$ItemColor, $ItemColor$Type} from "packages/net/minecraft/client/color/item/$ItemColor"
import {$CableBlock, $CableBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/$CableBlock"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$SaplingBlock, $SaplingBlock$Type} from "packages/net/minecraft/world/level/block/$SaplingBlock"
import {$RotatedPillarBlock, $RotatedPillarBlock$Type} from "packages/net/minecraft/world/level/block/$RotatedPillarBlock"
import {$OpticalPipeBlock, $OpticalPipeBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/$OpticalPipeBlock"
import {$FenceBlock, $FenceBlock$Type} from "packages/net/minecraft/world/level/block/$FenceBlock"
import {$ActiveBlock, $ActiveBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$ActiveBlock"
import {$NonNullSupplier, $NonNullSupplier$Type} from "packages/com/tterrag/registrate/util/nullness/$NonNullSupplier"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"
import {$FusionCasingBlock, $FusionCasingBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/$FusionCasingBlock"
import {$NonNullFunction, $NonNullFunction$Type} from "packages/com/tterrag/registrate/util/nullness/$NonNullFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$BlockSetType, $BlockSetType$Type} from "packages/net/minecraft/world/level/block/state/properties/$BlockSetType"

export class $GTBlocks {
static "MATERIAL_BLOCKS": $Table<($TagPrefix), ($Material), ($BlockEntry<(any)>)>
static "SURFACE_ROCK_BLOCKS": $Map<($Material), ($BlockEntry<($SurfaceRockBlock)>)>
static "CABLE_BLOCKS": $Table<($TagPrefix), ($Material), ($BlockEntry<($CableBlock)>)>
static "FLUID_PIPE_BLOCKS": $Table<($TagPrefix), ($Material), ($BlockEntry<($FluidPipeBlock)>)>
static "ITEM_PIPE_BLOCKS": $Table<($TagPrefix), ($Material), ($BlockEntry<($ItemPipeBlock)>)>
static readonly "LASER_PIPES": ($BlockEntry<($LaserPipeBlock)>)[]
static readonly "OPTICAL_PIPES": ($BlockEntry<($OpticalPipeBlock)>)[]
static readonly "DUCT_PIPES": ($BlockEntry<($DuctPipeBlock)>)[]
static readonly "LD_ITEM_PIPE": $BlockEntry<($LongDistancePipeBlock)>
static readonly "LD_FLUID_PIPE": $BlockEntry<($LongDistancePipeBlock)>
static readonly "CASING_WOOD_WALL": $BlockEntry<($Block)>
static readonly "CASING_COKE_BRICKS": $BlockEntry<($Block)>
static readonly "CASING_PRIMITIVE_BRICKS": $BlockEntry<($Block)>
static readonly "CASING_BRONZE_BRICKS": $BlockEntry<($Block)>
static readonly "CASING_INVAR_HEATPROOF": $BlockEntry<($Block)>
static readonly "CASING_ALUMINIUM_FROSTPROOF": $BlockEntry<($Block)>
static readonly "CASING_STEEL_SOLID": $BlockEntry<($Block)>
static readonly "CASING_STAINLESS_CLEAN": $BlockEntry<($Block)>
static readonly "CASING_TITANIUM_STABLE": $BlockEntry<($Block)>
static readonly "CASING_TUNGSTENSTEEL_ROBUST": $BlockEntry<($Block)>
static readonly "CASING_PTFE_INERT": $BlockEntry<($Block)>
static readonly "CASING_HSSE_STURDY": $BlockEntry<($Block)>
static readonly "CASING_PALLADIUM_SUBSTATION": $BlockEntry<($Block)>
static readonly "CASING_TEMPERED_GLASS": $BlockEntry<($Block)>
static readonly "CASING_STAINLESS_EVAPORATION": $BlockEntry<($Block)>
static readonly "MATERIALS_TO_CASINGS": $ImmutableMap<($Material), ($BlockEntry<($Block)>)>
static readonly "CASING_GRATE": $BlockEntry<($Block)>
static readonly "CASING_ASSEMBLY_CONTROL": $BlockEntry<($Block)>
static readonly "CASING_LAMINATED_GLASS": $BlockEntry<($Block)>
static readonly "CASING_ASSEMBLY_LINE": $BlockEntry<($ActiveBlock)>
static readonly "CASING_BRONZE_GEARBOX": $BlockEntry<($Block)>
static readonly "CASING_STEEL_GEARBOX": $BlockEntry<($Block)>
static readonly "CASING_STAINLESS_STEEL_GEARBOX": $BlockEntry<($Block)>
static readonly "CASING_TITANIUM_GEARBOX": $BlockEntry<($Block)>
static readonly "CASING_TUNGSTENSTEEL_GEARBOX": $BlockEntry<($Block)>
static readonly "CASING_STEEL_TURBINE": $BlockEntry<($Block)>
static readonly "CASING_TITANIUM_TURBINE": $BlockEntry<($Block)>
static readonly "CASING_STAINLESS_TURBINE": $BlockEntry<($Block)>
static readonly "CASING_TUNGSTENSTEEL_TURBINE": $BlockEntry<($Block)>
static readonly "CASING_BRONZE_PIPE": $BlockEntry<($Block)>
static readonly "CASING_STEEL_PIPE": $BlockEntry<($Block)>
static readonly "CASING_TITANIUM_PIPE": $BlockEntry<($Block)>
static readonly "CASING_TUNGSTENSTEEL_PIPE": $BlockEntry<($Block)>
static readonly "CASING_POLYTETRAFLUOROETHYLENE_PIPE": $BlockEntry<($Block)>
static readonly "MINER_PIPE": $BlockEntry<($MinerPipeBlock)>
static readonly "CASING_PUMP_DECK": $BlockEntry<($Block)>
static readonly "MACHINE_CASING_ULV": $BlockEntry<($Block)>
static readonly "MACHINE_CASING_LV": $BlockEntry<($Block)>
static readonly "MACHINE_CASING_MV": $BlockEntry<($Block)>
static readonly "MACHINE_CASING_HV": $BlockEntry<($Block)>
static readonly "MACHINE_CASING_EV": $BlockEntry<($Block)>
static readonly "MACHINE_CASING_IV": $BlockEntry<($Block)>
static readonly "MACHINE_CASING_LuV": $BlockEntry<($Block)>
static readonly "MACHINE_CASING_ZPM": $BlockEntry<($Block)>
static readonly "MACHINE_CASING_UV": $BlockEntry<($Block)>
static readonly "MACHINE_CASING_UHV": $BlockEntry<($Block)>
static readonly "MACHINE_CASING_UEV": $BlockEntry<($Block)>
static readonly "MACHINE_CASING_UIV": $BlockEntry<($Block)>
static readonly "MACHINE_CASING_UXV": $BlockEntry<($Block)>
static readonly "MACHINE_CASING_OpV": $BlockEntry<($Block)>
static readonly "MACHINE_CASING_MAX": $BlockEntry<($Block)>
static readonly "HERMETIC_CASING_LV": $BlockEntry<($Block)>
static readonly "HERMETIC_CASING_MV": $BlockEntry<($Block)>
static readonly "HERMETIC_CASING_HV": $BlockEntry<($Block)>
static readonly "HERMETIC_CASING_EV": $BlockEntry<($Block)>
static readonly "HERMETIC_CASING_IV": $BlockEntry<($Block)>
static readonly "HERMETIC_CASING_LuV": $BlockEntry<($Block)>
static readonly "HERMETIC_CASING_ZPM": $BlockEntry<($Block)>
static readonly "HERMETIC_CASING_UV": $BlockEntry<($Block)>
static readonly "HERMETIC_CASING_UHV": $BlockEntry<($Block)>
static readonly "BRONZE_HULL": $BlockEntry<($Block)>
static readonly "BRONZE_BRICKS_HULL": $BlockEntry<($Block)>
static readonly "STEEL_HULL": $BlockEntry<($Block)>
static readonly "STEEL_BRICKS_HULL": $BlockEntry<($Block)>
static readonly "COIL_CUPRONICKEL": $BlockEntry<($CoilBlock)>
static readonly "COIL_KANTHAL": $BlockEntry<($CoilBlock)>
static readonly "COIL_NICHROME": $BlockEntry<($CoilBlock)>
static readonly "COIL_RTMALLOY": $BlockEntry<($CoilBlock)>
static readonly "COIL_HSSG": $BlockEntry<($CoilBlock)>
static readonly "COIL_NAQUADAH": $BlockEntry<($CoilBlock)>
static readonly "COIL_TRINIUM": $BlockEntry<($CoilBlock)>
static readonly "COIL_TRITANIUM": $BlockEntry<($CoilBlock)>
static readonly "BATTERY_EMPTY_TIER_I": $BlockEntry<($BatteryBlock)>
static readonly "BATTERY_LAPOTRONIC_EV": $BlockEntry<($BatteryBlock)>
static readonly "BATTERY_LAPOTRONIC_IV": $BlockEntry<($BatteryBlock)>
static readonly "BATTERY_EMPTY_TIER_II": $BlockEntry<($BatteryBlock)>
static readonly "BATTERY_LAPOTRONIC_LuV": $BlockEntry<($BatteryBlock)>
static readonly "BATTERY_LAPOTRONIC_ZPM": $BlockEntry<($BatteryBlock)>
static readonly "BATTERY_EMPTY_TIER_III": $BlockEntry<($BatteryBlock)>
static readonly "BATTERY_LAPOTRONIC_UV": $BlockEntry<($BatteryBlock)>
static readonly "BATTERY_ULTIMATE_UHV": $BlockEntry<($BatteryBlock)>
static readonly "CASING_ENGINE_INTAKE": $BlockEntry<($ActiveBlock)>
static readonly "CASING_EXTREME_ENGINE_INTAKE": $BlockEntry<($ActiveBlock)>
static readonly "ALL_FUSION_CASINGS": $Map<($IFusionCasingType), ($Supplier<($FusionCasingBlock)>)>
static readonly "SUPERCONDUCTING_COIL": $BlockEntry<($FusionCasingBlock)>
static readonly "FUSION_COIL": $BlockEntry<($FusionCasingBlock)>
static readonly "FUSION_CASING": $BlockEntry<($FusionCasingBlock)>
static readonly "FUSION_CASING_MK2": $BlockEntry<($FusionCasingBlock)>
static readonly "FUSION_CASING_MK3": $BlockEntry<($FusionCasingBlock)>
static readonly "FUSION_GLASS": $BlockEntry<($Block)>
static readonly "PLASTCRETE": $BlockEntry<($Block)>
static readonly "FILTER_CASING": $BlockEntry<($Block)>
static readonly "FILTER_CASING_STERILE": $BlockEntry<($Block)>
static readonly "CLEANROOM_GLASS": $BlockEntry<($Block)>
static readonly "ALL_FIREBOXES": $Map<($BoilerFireboxType), ($BlockEntry<($ActiveBlock)>)>
static readonly "FIREBOX_BRONZE": $BlockEntry<($ActiveBlock)>
static readonly "FIREBOX_STEEL": $BlockEntry<($ActiveBlock)>
static readonly "FIREBOX_TITANIUM": $BlockEntry<($ActiveBlock)>
static readonly "FIREBOX_TUNGSTENSTEEL": $BlockEntry<($ActiveBlock)>
static readonly "COMPUTER_CASING": $BlockEntry<($Block)>
static readonly "ADVANCED_COMPUTER_CASING": $BlockEntry<($Block)>
static readonly "COMPUTER_HEAT_VENT": $BlockEntry<($Block)>
static readonly "HIGH_POWER_CASING": $BlockEntry<($Block)>
static readonly "POWDERBARREL": $BlockEntry<($PowderbarrelBlock)>
static readonly "INDUSTRIAL_TNT": $BlockEntry<($IndustrialTNTBlock)>
static readonly "RUBBER_SAPLING": $BlockEntry<($SaplingBlock)>
static readonly "RUBBER_LOG": $BlockEntry<($RubberLogBlock)>
static readonly "RUBBER_LEAVES_DROPPING_CHANCE": (float)[]
static readonly "RUBBER_LEAVES": $BlockEntry<($LeavesBlock)>
static readonly "RUBBER_SET": $BlockSetType
static readonly "RUBBER_TYPE": $WoodType
static readonly "STRIPPED_RUBBER_LOG": $BlockEntry<($RotatedPillarBlock)>
static readonly "RUBBER_WOOD": $BlockEntry<($RotatedPillarBlock)>
static readonly "STRIPPED_RUBBER_WOOD": $BlockEntry<($RotatedPillarBlock)>
static readonly "RUBBER_PLANK": $BlockEntry<($Block)>
static readonly "RUBBER_SLAB": $BlockEntry<($SlabBlock)>
static readonly "RUBBER_FENCE": $BlockEntry<($FenceBlock)>
static readonly "RUBBER_SIGN": $BlockEntry<($GTStandingSignBlock)>
static readonly "RUBBER_WALL_SIGN": $BlockEntry<($GTWallSignBlock)>
static readonly "RUBBER_HANGING_SIGN": $BlockEntry<($GTCeilingHangingSignBlock)>
static readonly "RUBBER_WALL_HANGING_SIGN": $BlockEntry<($GTWallHangingSignBlock)>
static readonly "RUBBER_PRESSURE_PLATE": $BlockEntry<($PressurePlateBlock)>
static readonly "RUBBER_TRAPDOOR": $BlockEntry<($TrapDoorBlock)>
static readonly "RUBBER_STAIRS": $BlockEntry<($StairBlock)>
static readonly "RUBBER_BUTTON": $BlockEntry<($ButtonBlock)>
static readonly "RUBBER_FENCE_GATE": $BlockEntry<($FenceGateBlock)>
static readonly "RUBBER_DOOR": $BlockEntry<($DoorBlock)>
static readonly "TREATED_WOOD_SET": $BlockSetType
static readonly "TREATED_WOOD_TYPE": $WoodType
static readonly "TREATED_WOOD_PLANK": $BlockEntry<($Block)>
static readonly "TREATED_WOOD_SLAB": $BlockEntry<($SlabBlock)>
static readonly "TREATED_WOOD_FENCE": $BlockEntry<($FenceBlock)>
static readonly "TREATED_WOOD_SIGN": $BlockEntry<($GTStandingSignBlock)>
static readonly "TREATED_WOOD_WALL_SIGN": $BlockEntry<($GTWallSignBlock)>
static readonly "TREATED_WOOD_HANGING_SIGN": $BlockEntry<($GTCeilingHangingSignBlock)>
static readonly "TREATED_WOOD_WALL_HANGING_SIGN": $BlockEntry<($GTWallHangingSignBlock)>
static readonly "TREATED_WOOD_PRESSURE_PLATE": $BlockEntry<($PressurePlateBlock)>
static readonly "TREATED_WOOD_TRAPDOOR": $BlockEntry<($TrapDoorBlock)>
static readonly "TREATED_WOOD_STAIRS": $BlockEntry<($StairBlock)>
static readonly "TREATED_WOOD_BUTTON": $BlockEntry<($ButtonBlock)>
static readonly "TREATED_WOOD_FENCE_GATE": $BlockEntry<($FenceGateBlock)>
static readonly "TREATED_WOOD_DOOR": $BlockEntry<($DoorBlock)>
static readonly "ACID_HAZARD_SIGN_BLOCK": $BlockEntry<($Block)>
static readonly "ANTIMATTER_HAZARD_SIGN_BLOCK": $BlockEntry<($Block)>
static readonly "BIO_HAZARD_SIGN_BLOCK": $BlockEntry<($Block)>
static readonly "BOSS_HAZARD_SIGN_BLOCK": $BlockEntry<($Block)>
static readonly "CAUSALITY_HAZARD_SIGN_BLOCK": $BlockEntry<($Block)>
static readonly "EXPLOSION_HAZARD_SIGN_BLOCK": $BlockEntry<($Block)>
static readonly "FIRE_HAZARD_SIGN_BLOCK": $BlockEntry<($Block)>
static readonly "FROST_HAZARD_SIGN_BLOCK": $BlockEntry<($Block)>
static readonly "GENERIC_HAZARD_SIGN_BLOCK": $BlockEntry<($Block)>
static readonly "GREGIFICATION_HAZARD_SIGN_BLOCK": $BlockEntry<($Block)>
static readonly "HIGH_PRESSURE_HAZARD_SIGN_BLOCK": $BlockEntry<($Block)>
static readonly "HIGH_VOLTAGE_HAZARD_SIGN_BLOCK": $BlockEntry<($Block)>
static readonly "HIGH_TEMPERATURE_HAZARD_SIGN_BLOCK": $BlockEntry<($Block)>
static readonly "LASER_HAZARD_SIGN_BLOCK": $BlockEntry<($Block)>
static readonly "MAGIC_HAZARD_SIGN_BLOCK": $BlockEntry<($Block)>
static readonly "MAGNETIC_HAZARD_SIGN_BLOCK": $BlockEntry<($Block)>
static readonly "MOB_INFESTATION_HAZARD_SIGN_BLOCK": $BlockEntry<($Block)>
static readonly "MOB_SPAWNER_HAZARD_SIGN_BLOCK": $BlockEntry<($Block)>
static readonly "NOISE_HAZARD_SIGN_BLOCK": $BlockEntry<($Block)>
static readonly "RADIOACTIVE_HAZARD_SIGN_BLOCK": $BlockEntry<($Block)>
static readonly "SPATIAL_STORAGE_HAZARD_SIGN_BLOCK": $BlockEntry<($Block)>
static readonly "TURRET_HAZARD_SIGN_BLOCK": $BlockEntry<($Block)>
static readonly "VOID_HAZARD_SIGN_BLOCK": $BlockEntry<($Block)>
static readonly "YELLOW_STRIPES_BLOCK_A": $BlockEntry<($Block)>
static readonly "YELLOW_STRIPES_BLOCK_B": $BlockEntry<($Block)>
static "STONE_BLOCKS": $Table<($StoneBlockType), ($StoneTypes), ($BlockEntry<($Block)>)>
static "RED_GRANITE": $BlockEntry<($Block)>
static "MARBLE": $BlockEntry<($Block)>
static "LIGHT_CONCRETE": $BlockEntry<($Block)>
static "DARK_CONCRETE": $BlockEntry<($Block)>
static readonly "FOAM": $BlockEntry<($Block)>
static readonly "PETRIFIED_FOAM": $BlockEntry<($Block)>
static readonly "REINFORCED_STONE": $BlockEntry<($Block)>
static readonly "LAMPS": $Map<($DyeColor), ($BlockEntry<($LampBlock)>)>
static readonly "BORDERLESS_LAMPS": $Map<($DyeColor), ($BlockEntry<($LampBlock)>)>

constructor()

public static "init"(): void
public static "copy"(props: $BlockBehaviour$Properties$Type, newProps: $BlockBehaviour$Properties$Type): $BlockBehaviour$Properties
public static "compassNode"<T extends $ItemLike>(section: $CompassSection$Type, ...preNodes: ($CompassNode$Type)[]): $NonNullConsumer<(T)>
public static "generateStoneBlocks"(): void
public static "unificationBlock"<P, T extends $Block, S2 extends $BlockBuilder<(T), (P)>>(tagPrefix: $TagPrefix$Type, mat: $Material$Type): $NonNullFunction<(S2), (S2)>
public static "compassNodeExist"<T extends $ItemLike>(section: $CompassSection$Type, node: string, ...preNodes: ($CompassNode$Type)[]): $NonNullConsumer<(T)>
public static "createCasingBlock"(name: string, blockSupplier: $NonNullFunction$Type<($BlockBehaviour$Properties$Type), ($Block$Type)>, properties: $NonNullSupplier$Type<(any)>, type: $Supplier$Type<($Supplier$Type<($RenderType$Type)>)>): $BlockEntry<($Block)>
public static "createCasingBlock"(name: string, texture: $ResourceLocation$Type): $BlockEntry<($Block)>
public static "createCasingBlock"(name: string, blockSupplier: $BiFunction$Type<($BlockBehaviour$Properties$Type), ($IRenderer$Type), (any)>, texture: $ResourceLocation$Type, properties: $NonNullSupplier$Type<(any)>, type: $Supplier$Type<($Supplier$Type<($RenderType$Type)>)>): $BlockEntry<($Block)>
public static "leavesItemColor"(): $ItemColor
public static "leavesBlockColor"(): $BlockColor
public static "doMetalPipe"(material: $Material$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTBlocks$Type = ($GTBlocks);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTBlocks_ = $GTBlocks$Type;
}}
declare module "packages/com/gregtechceu/gtceu/integration/kjs/builders/block/$RendererGlassBlockBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$RendererBlockBuilder, $RendererBlockBuilder$Type} from "packages/com/gregtechceu/gtceu/integration/kjs/builders/block/$RendererBlockBuilder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $RendererGlassBlockBuilder extends $RendererBlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
 "lootTable": $Consumer<($LootBuilder)>
 "blockstateJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "createObject"(): $Block
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RendererGlassBlockBuilder$Type = ($RendererGlassBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RendererGlassBlockBuilder_ = $RendererGlassBlockBuilder$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/$ComponentItem" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$FoodProperties, $FoodProperties$Type} from "packages/net/minecraft/world/food/$FoodProperties"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$HeldItemUIFactory$IHeldItemUIHolder, $HeldItemUIFactory$IHeldItemUIHolder$Type} from "packages/com/lowdragmc/lowdraglib/gui/factory/$HeldItemUIFactory$IHeldItemUIHolder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IItemRendererProvider, $IItemRendererProvider$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IItemRendererProvider"
import {$IItemComponent, $IItemComponent$Type} from "packages/com/gregtechceu/gtceu/api/item/component/$IItemComponent"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$IRenderer, $IRenderer$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IRenderer"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$HeldItemUIFactory$HeldItemHolder, $HeldItemUIFactory$HeldItemHolder$Type} from "packages/com/lowdragmc/lowdraglib/gui/factory/$HeldItemUIFactory$HeldItemHolder"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$IComponentItem, $IComponentItem$Type} from "packages/com/gregtechceu/gtceu/api/item/$IComponentItem"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$ModularUI, $ModularUI$Type} from "packages/com/lowdragmc/lowdraglib/gui/modular/$ModularUI"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ComponentItem extends $Item implements $HeldItemUIFactory$IHeldItemUIHolder, $IItemRendererProvider, $IComponentItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "descriptionId": string
 "foodProperties": $FoodProperties
readonly "canRepair": boolean
 "renderProperties": any
 "moonlight$clientAnimationProvider": any


public static "create"(properties: $Item$Properties$Type): $ComponentItem
public "getCapability"<T>(itemStack: $ItemStack$Type, cap: $Capability$Type<(T)>): $LazyOptional<(T)>
public "getComponents"(): $List<($IItemComponent)>
public "createUI"(entityPlayer: $Player$Type, holder: $HeldItemUIFactory$HeldItemHolder$Type): $ModularUI
public "appendHoverText"(stack: $ItemStack$Type, level: $Level$Type, tooltipComponents: $List$Type<($Component$Type)>, isAdvanced: $TooltipFlag$Type): void
public "getName"(stack: $ItemStack$Type): $Component
public "getCraftingRemainingItem"(itemStack: $ItemStack$Type): $ItemStack
public "hasCraftingRemainingItem"(stack: $ItemStack$Type): boolean
public "getAttributeModifiers"(slot: $EquipmentSlot$Type, stack: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "use"(level: $Level$Type, player: $Player$Type, usedHand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "useOn"(context: $UseOnContext$Type): $InteractionResult
public "finishUsingItem"(stack: $ItemStack$Type, level: $Level$Type, livingEntity: $LivingEntity$Type): $ItemStack
public "isBarVisible"(stack: $ItemStack$Type): boolean
public "getBarColor"(stack: $ItemStack$Type): integer
public "getBarWidth"(stack: $ItemStack$Type): integer
public "interactLivingEntity"(stack: $ItemStack$Type, player: $Player$Type, interactionTarget: $LivingEntity$Type, usedHand: $InteractionHand$Type): $InteractionResult
public "getDescriptionId"(stack: $ItemStack$Type): string
public "inventoryTick"(stack: $ItemStack$Type, level: $Level$Type, entity: $Entity$Type, slotId: integer, isSelected: boolean): void
public "isEnchantable"(stack: $ItemStack$Type): boolean
public "onItemUseFirst"(itemStack: $ItemStack$Type, context: $UseOnContext$Type): $InteractionResult
public "getBurnTime"(itemStack: $ItemStack$Type, recipeType: $RecipeType$Type<(any)>): integer
public "getRenderer"(stack: $ItemStack$Type): $IRenderer
public "fillItemCategory"(category: $CreativeModeTab$Type, items: $NonNullList$Type<($ItemStack$Type)>): void
public "burnTime"(burnTime: integer): void
public "getEnchantmentValue"(stack: $ItemStack$Type): integer
public "canApplyAtEnchantingTable"(stack: $ItemStack$Type, enchantment: $Enchantment$Type): boolean
public "attachComponents"(component: $IItemComponent$Type): void
public "attachComponents"(...components: ($IItemComponent$Type)[]): void
public "getInfiniteChargedStack"(): $ItemStack
public "getChargedStack"(chargeAmount: long): $ItemStack
get "components"(): $List<($IItemComponent)>
get "infiniteChargedStack"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentItem$Type = ($ComponentItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentItem_ = $ComponentItem$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/explosive/$IndustrialTNTBlock" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GTExplosiveBlock, $GTExplosiveBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/explosive/$GTExplosiveBlock"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$List, $List$Type} from "packages/java/util/$List"

export class $IndustrialTNTBlock extends $GTExplosiveBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type)

public "appendHoverText"(stack: $ItemStack$Type, level: $BlockGetter$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IndustrialTNTBlock$Type = ($IndustrialTNTBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IndustrialTNTBlock_ = $IndustrialTNTBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$ClassicVeinGenerator$Layer" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$GTOreDefinition, $GTOreDefinition$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTOreDefinition"
import {$LevelChunkSection, $LevelChunkSection$Type} from "packages/net/minecraft/world/level/chunk/$LevelChunkSection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$OreConfiguration$TargetBlockState, $OreConfiguration$TargetBlockState$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$OreConfiguration$TargetBlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BulkSectionAccess, $BulkSectionAccess$Type} from "packages/net/minecraft/world/level/chunk/$BulkSectionAccess"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $ClassicVeinGenerator$Layer {
static readonly "CODEC": $Codec<($ClassicVeinGenerator$Layer)>
readonly "target": $Either<($List<($OreConfiguration$TargetBlockState)>), ($Material)>
 "layers": integer

constructor(target: $Either$Type<($List$Type<($OreConfiguration$TargetBlockState$Type)>), ($Material$Type)>, layers: integer)

public "copy"(): $ClassicVeinGenerator$Layer
public "place"(blockState: $BlockState$Type, access: $BulkSectionAccess$Type, section: $LevelChunkSection$Type, randomSeed: long, entry: $GTOreDefinition$Type, pos: $BlockPos$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassicVeinGenerator$Layer$Type = ($ClassicVeinGenerator$Layer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassicVeinGenerator$Layer_ = $ClassicVeinGenerator$Layer$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/capability/$IHazardParticleContainer" {
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$MedicalCondition, $MedicalCondition$Type} from "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$MedicalCondition"

export interface $IHazardParticleContainer {

 "removeHazard"(condition: $MedicalCondition$Type, particlesToRemove: float): float
 "addHazard"(condition: $MedicalCondition$Type, particlesToAdd: float): float
 "inputsHazard"(arg0: $Direction$Type, arg1: $MedicalCondition$Type): boolean
 "changeHazard"(arg0: $MedicalCondition$Type, arg1: float): float
 "outputsHazard"(side: $Direction$Type, condition: $MedicalCondition$Type): boolean
 "getHazardCapacity"(arg0: $MedicalCondition$Type): float
 "getHazardStored"(arg0: $MedicalCondition$Type): float
 "getHazardCanBeInserted"(condition: $MedicalCondition$Type): float
}

export namespace $IHazardParticleContainer {
const DEFAULT: $IHazardParticleContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IHazardParticleContainer$Type = ($IHazardParticleContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IHazardParticleContainer_ = $IHazardParticleContainer$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/unification/material/$MaterialRegistryManager" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$MaterialRegistry, $MaterialRegistry$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/registry/$MaterialRegistry"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IMaterialRegistryManager$Phase, $IMaterialRegistryManager$Phase$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$IMaterialRegistryManager$Phase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IMaterialRegistryManager, $IMaterialRegistryManager$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$IMaterialRegistryManager"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $MaterialRegistryManager implements $IMaterialRegistryManager {


public "getKey"(material: $Material$Type): $ResourceLocation
public static "getInstance"(): $MaterialRegistryManager
public "getPhase"(): $IMaterialRegistryManager$Phase
public "freezeRegistries"(): void
public "closeRegistries"(): void
public "getRegisteredMaterials"(): $Collection<($Material)>
public "getRegistry"(modid: string): $MaterialRegistry
public "getRegistry"(networkId: integer): $MaterialRegistry
public "getRegistries"(): $Collection<($MaterialRegistry)>
public "createRegistry"(modid: string): $MaterialRegistry
public "unfreezeRegistries"(): void
public "getMaterial"(name: string): $Material
public "getDefaultFallback"(): $Material
public "codec"(): $Codec<($Material)>
public "canModifyMaterials"(): boolean
get "instance"(): $MaterialRegistryManager
get "phase"(): $IMaterialRegistryManager$Phase
get "registeredMaterials"(): $Collection<($Material)>
get "registries"(): $Collection<($MaterialRegistry)>
get "defaultFallback"(): $Material
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialRegistryManager$Type = ($MaterialRegistryManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialRegistryManager_ = $MaterialRegistryManager$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/duct/$DuctPipeProperties" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $DuctPipeProperties {

constructor(transferRate: float)
constructor()

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "setTransferRate"(transferRate: float): void
public "getTransferRate"(): float
set "transferRate"(value: float)
get "transferRate"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DuctPipeProperties$Type = ($DuctPipeProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DuctPipeProperties_ = $DuctPipeProperties$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/registry/$GTRegistries" {
import {$GTRecipeType, $GTRecipeType$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipeType"
import {$GTOreDefinition, $GTOreDefinition$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTOreDefinition"
import {$IEventBus, $IEventBus$Type} from "packages/net/minecraftforge/eventbus/api/$IEventBus"
import {$DimensionMarker, $DimensionMarker$Type} from "packages/com/gregtechceu/gtceu/api/data/$DimensionMarker"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$CoverDefinition, $CoverDefinition$Type} from "packages/com/gregtechceu/gtceu/api/cover/$CoverDefinition"
import {$TrunkPlacerType, $TrunkPlacerType$Type} from "packages/net/minecraft/world/level/levelgen/feature/trunkplacers/$TrunkPlacerType"
import {$Registry, $Registry$Type} from "packages/net/minecraft/core/$Registry"
import {$RecipeCapability, $RecipeCapability$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$RecipeCapability"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$MachineDefinition, $MachineDefinition$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MachineDefinition"
import {$CompassNode, $CompassNode$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$CompassNode"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$GTRegistry$RL, $GTRegistry$RL$Type} from "packages/com/gregtechceu/gtceu/api/registry/$GTRegistry$RL"
import {$BedrockFluidDefinition, $BedrockFluidDefinition$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/bedrockfluid/$BedrockFluidDefinition"
import {$GTRegistry$String, $GTRegistry$String$Type} from "packages/com/gregtechceu/gtceu/api/registry/$GTRegistry$String"
import {$BedrockOreDefinition, $BedrockOreDefinition$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/bedrockore/$BedrockOreDefinition"
import {$Element, $Element$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/$Element"
import {$SoundEntry, $SoundEntry$Type} from "packages/com/gregtechceu/gtceu/api/sound/$SoundEntry"
import {$DeferredRegister, $DeferredRegister$Type} from "packages/net/minecraftforge/registries/$DeferredRegister"
import {$CompassSection, $CompassSection$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$CompassSection"
import {$PlacementModifierType, $PlacementModifierType$Type} from "packages/net/minecraft/world/level/levelgen/placement/$PlacementModifierType"

export class $GTRegistries {
static readonly "ELEMENTS": $GTRegistry$String<($Element)>
static readonly "RECIPE_TYPES": $GTRegistry$RL<($GTRecipeType)>
static readonly "COVERS": $GTRegistry$RL<($CoverDefinition)>
static readonly "MACHINES": $GTRegistry$RL<($MachineDefinition)>
static readonly "RECIPE_CAPABILITIES": $GTRegistry$String<($RecipeCapability<(any)>)>
static readonly "RECIPE_CONDITIONS": $GTRegistry$String<($Class<(any)>)>
static readonly "SOUNDS": $GTRegistry$RL<($SoundEntry)>
static readonly "COMPASS_SECTIONS": $GTRegistry$RL<($CompassSection)>
static readonly "COMPASS_NODES": $GTRegistry$RL<($CompassNode)>
static readonly "BEDROCK_FLUID_DEFINITIONS": $GTRegistry$RL<($BedrockFluidDefinition)>
static readonly "BEDROCK_ORE_DEFINITIONS": $GTRegistry$RL<($BedrockOreDefinition)>
static readonly "ORE_VEINS": $GTRegistry$RL<($GTOreDefinition)>
static readonly "DIMENSION_MARKERS": $GTRegistry$RL<($DimensionMarker)>
static readonly "TRUNK_PLACER_TYPE": $DeferredRegister<($TrunkPlacerType<(any)>)>
static readonly "PLACEMENT_MODIFIER": $DeferredRegister<($PlacementModifierType<(any)>)>
static readonly "GLOBAL_LOOT_MODIFIES": $DeferredRegister<($Codec<(any)>)>

constructor()

public static "register"<V, T extends V>(registry: $Registry$Type<(V)>, name: $ResourceLocation$Type, value: T): T
public static "init"(eventBus: $IEventBus$Type): void
public static "builtinRegistry"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTRegistries$Type = ($GTRegistries);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTRegistries_ = $GTRegistries$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/gui/fancy/$FancyMachineUIWidget$NavigationEntry" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$IFancyUIProvider, $IFancyUIProvider$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$IFancyUIProvider"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $FancyMachineUIWidget$NavigationEntry extends $Record {


public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "page"(): $IFancyUIProvider
public "onNavigation"(): $Runnable
public "homePage"(): $IFancyUIProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FancyMachineUIWidget$NavigationEntry$Type = ($FancyMachineUIWidget$NavigationEntry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FancyMachineUIWidget$NavigationEntry_ = $FancyMachineUIWidget$NavigationEntry$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/lookup/$Branch" {
import {$GTRecipe, $GTRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$AbstractMapIngredient, $AbstractMapIngredient$Type} from "packages/com/gregtechceu/gtceu/api/recipe/lookup/$AbstractMapIngredient"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $Branch {

constructor()

public "getNodes"(): $Map<($AbstractMapIngredient), ($Either<($GTRecipe), ($Branch)>)>
public "getRecipes"(filterHidden: boolean): $Stream<($GTRecipe)>
public "getSpecialNodes"(): $Map<($AbstractMapIngredient), ($Either<($GTRecipe), ($Branch)>)>
public "isEmptyBranch"(): boolean
get "nodes"(): $Map<($AbstractMapIngredient), ($Either<($GTRecipe), ($Branch)>)>
get "specialNodes"(): $Map<($AbstractMapIngredient), ($Either<($GTRecipe), ($Branch)>)>
get "emptyBranch"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Branch$Type = ($Branch);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Branch_ = $Branch$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/item/$ItemPipeNet" {
import {$ItemPipeProperties, $ItemPipeProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$ItemPipeProperties"
import {$PipeNet, $PipeNet$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$PipeNet"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$LevelPipeNet, $LevelPipeNet$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$LevelPipeNet"
import {$ItemRoutePath, $ItemRoutePath$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/item/$ItemRoutePath"

export class $ItemPipeNet extends $PipeNet<($ItemPipeProperties)> {

constructor(world: $LevelPipeNet$Type<($ItemPipeProperties$Type), (any)>)

public "getNetData"(pipePos: $BlockPos$Type, facing: $Direction$Type): $List<($ItemRoutePath)>
public "onPipeConnectionsUpdate"(): void
public "onNeighbourUpdate"(fromPos: $BlockPos$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPipeNet$Type = ($ItemPipeNet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemPipeNet_ = $ItemPipeNet$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/$GTWallSignBlock" {
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$WoodType, $WoodType$Type} from "packages/net/minecraft/world/level/block/state/properties/$WoodType"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$WallSignBlock, $WallSignBlock$Type} from "packages/net/minecraft/world/level/block/$WallSignBlock"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"

export class $GTWallSignBlock extends $WallSignBlock {
static readonly "FACING": $DirectionProperty
static readonly "AABB_THICKNESS": float
static readonly "AABB_BOTTOM": float
static readonly "AABB_TOP": float
static readonly "WATERLOGGED": $BooleanProperty
static readonly "AABB_OFFSET": float
static readonly "SHAPE": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, type: $WoodType$Type)

public "getTicker"<T extends $BlockEntity>(level: $Level$Type, state: $BlockState$Type, blockEntityType: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(pos: $BlockPos$Type, state: $BlockState$Type): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTWallSignBlock$Type = ($GTWallSignBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTWallSignBlock_ = $GTWallSignBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/$DuctPipeBlock" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$PipeModel, $PipeModel$Type} from "packages/com/gregtechceu/gtceu/client/model/$PipeModel"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$IPipeNode, $IPipeNode$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeNode"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$DuctPipeType, $DuctPipeType$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/duct/$DuctPipeType"
import {$PipeBlockRenderer, $PipeBlockRenderer$Type} from "packages/com/gregtechceu/gtceu/client/renderer/block/$PipeBlockRenderer"
import {$IPipeType, $IPipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$DuctPipeProperties, $DuctPipeProperties$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/duct/$DuctPipeProperties"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$PipeBlock, $PipeBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$PipeBlock"
import {$LevelDuctPipeNet, $LevelDuctPipeNet$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/duct/$LevelDuctPipeNet"

export class $DuctPipeBlock extends $PipeBlock<($DuctPipeType), ($DuctPipeProperties), ($LevelDuctPipeNet)> {
readonly "renderer": $PipeBlockRenderer
readonly "model": $PipeModel
readonly "pipeType": PipeType
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, type: $DuctPipeType$Type)

public "createProperties"(pipeTile: $IPipeNode$Type<($DuctPipeType$Type), ($DuctPipeProperties$Type)>): $DuctPipeProperties
public "getBlockEntityType"(): $BlockEntityType<(any)>
public "appendHoverText"(stack: $ItemStack$Type, level: $BlockGetter$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "canPipeConnectToBlock"(selfTile: $IPipeNode$Type<($DuctPipeType$Type), ($DuctPipeProperties$Type)>, side: $Direction$Type, tile: $BlockEntity$Type): boolean
public "getWorldPipeNet"(world: $ServerLevel$Type): $LevelDuctPipeNet
public "canPipesConnect"(selfTile: $IPipeNode$Type<($DuctPipeType$Type), ($DuctPipeProperties$Type)>, side: $Direction$Type, sideTile: $IPipeNode$Type<($DuctPipeType$Type), ($DuctPipeProperties$Type)>): boolean
get "blockEntityType"(): $BlockEntityType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DuctPipeBlock$Type = ($DuctPipeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DuctPipeBlock_ = $DuctPipeBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/$BoilerFireboxType" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $BoilerFireboxType extends $Record {
static "BRONZE_FIREBOX": $BoilerFireboxType
static "STEEL_FIREBOX": $BoilerFireboxType
static "TITANIUM_FIREBOX": $BoilerFireboxType
static "TUNGSTENSTEEL_FIREBOX": $BoilerFireboxType

constructor(name: string, bottom: $ResourceLocation$Type, top: $ResourceLocation$Type, side: $ResourceLocation$Type)

public "getName"(): string
public "name"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "top"(): $ResourceLocation
public "bottom"(): $ResourceLocation
public "getSide"(): $ResourceLocation
public "side"(): $ResourceLocation
public "getTop"(): $ResourceLocation
public "getBottom"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoilerFireboxType$Type = ($BoilerFireboxType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoilerFireboxType_ = $BoilerFireboxType$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/gui/fancy/$ConfiguratorPanel" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IConfigurableWidget, $IConfigurableWidget$Type} from "packages/com/lowdragmc/lowdraglib/gui/editor/configurator/$IConfigurableWidget"
import {$ConfiguratorPanel$Tab, $ConfiguratorPanel$Tab$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$ConfiguratorPanel$Tab"
import {$IFancyConfigurator, $IFancyConfigurator$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$IFancyConfigurator"
import {$List, $List$Type} from "packages/java/util/$List"
import {$WidgetGroup, $WidgetGroup$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$WidgetGroup"
import {$Widget, $Widget$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$Widget"
import {$IGuiTexture, $IGuiTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$IGuiTexture"
import {$ConfiguratorPanel$FloatingTab, $ConfiguratorPanel$FloatingTab$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$ConfiguratorPanel$FloatingTab"
import {$Resources, $Resources$Type} from "packages/com/lowdragmc/lowdraglib/gui/editor/data/$Resources"

export class $ConfiguratorPanel extends $WidgetGroup {
readonly "widgets": $List<($Widget)>

constructor(x: integer, y: integer)

public "clear"(): void
public "setBorder"(border: integer): void
public "mouseClicked"(mouseX: double, mouseY: double, button: integer): boolean
public "getTabs"(): $List<($ConfiguratorPanel$Tab)>
public "setTexture"(texture: $IGuiTexture$Type): void
public "createFloatingTab"(configurator: $IFancyConfigurator$Type): $ConfiguratorPanel$FloatingTab
public "getExpanded"(): $ConfiguratorPanel$Tab
public "expandTab"(tab: $ConfiguratorPanel$Tab$Type): void
public "getTabSize"(): integer
public "collapseTab"(): void
public "attachConfigurators"(...fancyConfigurators: ($IFancyConfigurator$Type)[]): void
public static "deserializeNBT"(widget: $IConfigurableWidget$Type, tag: $CompoundTag$Type, resources: $Resources$Type, isProject: boolean): void
public static "serializeNBT"(widget: $IConfigurableWidget$Type, resources: $Resources$Type, isProject: boolean): $CompoundTag
public static "deserializeWrapper"(tag: $CompoundTag$Type): $IConfigurableWidget
set "border"(value: integer)
get "tabs"(): $List<($ConfiguratorPanel$Tab)>
set "texture"(value: $IGuiTexture$Type)
get "expanded"(): $ConfiguratorPanel$Tab
get "tabSize"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfiguratorPanel$Type = ($ConfiguratorPanel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfiguratorPanel_ = $ConfiguratorPanel$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/tool/$GTHoeItem" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$HoeItem, $HoeItem$Type} from "packages/net/minecraft/world/item/$HoeItem"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$FoodProperties, $FoodProperties$Type} from "packages/net/minecraft/world/food/$FoodProperties"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IGTTool, $IGTTool$Type} from "packages/com/gregtechceu/gtceu/api/item/$IGTTool"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$DustProperty, $DustProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$DustProperty"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IGTToolDefinition, $IGTToolDefinition$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$IGTToolDefinition"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$HeldItemUIFactory$HeldItemHolder, $HeldItemUIFactory$HeldItemHolder$Type} from "packages/com/lowdragmc/lowdraglib/gui/factory/$HeldItemUIFactory$HeldItemHolder"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$ItemColor, $ItemColor$Type} from "packages/net/minecraft/client/color/item/$ItemColor"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$GTToolType, $GTToolType$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$MaterialToolTier, $MaterialToolTier$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$MaterialToolTier"
import {$ModularUI, $ModularUI$Type} from "packages/com/lowdragmc/lowdraglib/gui/modular/$ModularUI"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$ToolProperty, $ToolProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$ToolProperty"
import {$SoundEntry, $SoundEntry$Type} from "packages/com/gregtechceu/gtceu/api/sound/$SoundEntry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GTHoeItem extends $HoeItem implements $IGTTool {
/**
 * 
 * @deprecated
 */
static "TILLABLES": $Map<($Block), ($Pair<($Predicate<($UseOnContext)>), ($Consumer<($UseOnContext)>)>)>
 "speed": float
 "defaultModifiers": $Multimap<($Attribute), ($AttributeModifier)>
 "tier": $Tier
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "descriptionId": string
 "foodProperties": $FoodProperties
readonly "canRepair": boolean
 "renderProperties": any
 "moonlight$clientAnimationProvider": any


public static "create"(toolType: $GTToolType$Type, tier: $MaterialToolTier$Type, material: $Material$Type, toolStats: $IGTToolDefinition$Type, properties: $Item$Properties$Type): $GTHoeItem
public "getDamage"(stack: $ItemStack$Type): integer
public "appendHoverText"(stack: $ItemStack$Type, level: $Level$Type, tooltipComponents: $List$Type<($Component$Type)>, isAdvanced: $TooltipFlag$Type): void
public "getName"(stack: $ItemStack$Type): $Component
public "shouldCauseReequipAnimation"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type, slotChanged: boolean): boolean
public "isCorrectToolForDrops"(stack: $ItemStack$Type, state: $BlockState$Type): boolean
public "getCraftingRemainingItem"(itemStack: $ItemStack$Type): $ItemStack
public "hasCraftingRemainingItem"(stack: $ItemStack$Type): boolean
public "getAttributeModifiers"(slot: $EquipmentSlot$Type, stack: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "use"(level: $Level$Type, player: $Player$Type, usedHand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "useOn"(context: $UseOnContext$Type): $InteractionResult
public "getDestroySpeed"(stack: $ItemStack$Type, state: $BlockState$Type): float
public "hurtEnemy"(stack: $ItemStack$Type, target: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
public "getMaxDamage"(stack: $ItemStack$Type): integer
public "mineBlock"(stack: $ItemStack$Type, level: $Level$Type, state: $BlockState$Type, pos: $BlockPos$Type, miningEntity: $LivingEntity$Type): boolean
public "getDescription"(): $Component
public "hasCraftingRemainingItem"(): boolean
public "isValidRepairItem"(stack: $ItemStack$Type, repairCandidate: $ItemStack$Type): boolean
public "doesSneakBypassUse"(stack: $ItemStack$Type, level: $LevelReader$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "onItemUseFirst"(itemStack: $ItemStack$Type, context: $UseOnContext$Type): $InteractionResult
public "onBlockStartBreak"(stack: $ItemStack$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "isDamaged"(stack: $ItemStack$Type): boolean
public "setDamage"(stack: $ItemStack$Type, damage: integer): void
public "getSound"(): $SoundEntry
public "canDisableShield"(stack: $ItemStack$Type, shield: $ItemStack$Type, entity: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
public "getEnchantmentValue"(stack: $ItemStack$Type): integer
public "shouldCauseBlockBreakReset"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type): boolean
public "canApplyAtEnchantingTable"(stack: $ItemStack$Type, enchantment: $Enchantment$Type): boolean
public "getDescriptionId"(): string
public "getDefaultInstance"(): $ItemStack
public "initCapabilities"(stack: $ItemStack$Type, nbt: $CompoundTag$Type): $ICapabilityProvider
public "isElectric"(): boolean
public "getMaterial"(): $Material
public "playSoundOnBlockDestroy"(): boolean
public "getToolStats"(): $IGTToolDefinition
public "getElectricTier"(): integer
public "getToolType"(): $GTToolType
public "get"(defaultMaxCharge: long): $ItemStack
public "get"(): $ItemStack
public "get"(defaultCharge: long, defaultMaxCharge: long): $ItemStack
public "getRaw"(): $ItemStack
public "getColor"(stack: $ItemStack$Type, tintIndex: integer): integer
public "createUI"(entityPlayer: $Player$Type, holder: $HeldItemUIFactory$HeldItemHolder$Type): $ModularUI
public static "tintColor"(): $ItemColor
public "definition$canApplyAtEnchantingTable"(stack: $ItemStack$Type, enchantment: $Enchantment$Type): boolean
public "definition$shouldCauseReequipAnimation"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type, slotChanged: boolean): boolean
public "definition$getDefaultAttributeModifiers"(equipmentSlot: $EquipmentSlot$Type, stack: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "definition$shouldCauseBlockBreakReset"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type): boolean
public "definition$getCraftingRemainingItem"(stack: $ItemStack$Type): $ItemStack
public "definition$hasCraftingRemainingItem"(stack: $ItemStack$Type): boolean
public "definition$canDestroyBlockInCreative"(world: $Level$Type, pos: $BlockPos$Type, stack: $ItemStack$Type, player: $Player$Type): boolean
public "getCharge"(stack: $ItemStack$Type): long
public "playSound"(player: $Player$Type): void
public "asItem"(): $Item
public "definition$isDamaged"(stack: $ItemStack$Type): boolean
public "getToolMaterial"(stack: $ItemStack$Type): $Material
public "getMaxCharge"(stack: $ItemStack$Type): long
public "getToolClasses"(stack: $ItemStack$Type): $Set<($GTToolType)>
public "getTotalToolSpeed"(stack: $ItemStack$Type): float
public "getToolProperty"(stack: $ItemStack$Type): $ToolProperty
public "getDustProperty"(stack: $ItemStack$Type): $DustProperty
public "playCraftingSound"(player: $Player$Type, stack: $ItemStack$Type): void
public "definition$use"(world: $Level$Type, player: $Player$Type, hand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "definition$init"(): void
public "canPlaySound"(stack: $ItemStack$Type): boolean
public "getToolClassNames"(stack: $ItemStack$Type): $Set<(string)>
public "definition$getDestroySpeed"(stack: $ItemStack$Type, state: $BlockState$Type): float
public "getTotalAttackDamage"(stack: $ItemStack$Type): float
public "getTotalAttackSpeed"(stack: $ItemStack$Type): float
public "definition$hurtEnemy"(stack: $ItemStack$Type, target: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
public "getTotalHarvestLevel"(stack: $ItemStack$Type): integer
public "getMaterialAttackSpeed"(stack: $ItemStack$Type): float
public "definition$onBlockStartBreak"(stack: $ItemStack$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "definition$mineBlock"(stack: $ItemStack$Type, worldIn: $Level$Type, state: $BlockState$Type, pos: $BlockPos$Type, entityLiving: $LivingEntity$Type): boolean
public "definition$isValidRepairItem"(toRepair: $ItemStack$Type, repair: $ItemStack$Type): boolean
public "definition$getHarvestLevel"(stack: $ItemStack$Type, toolClass: $GTToolType$Type, player: $Player$Type, blockState: $BlockState$Type): integer
public "getMaterialAttackDamage"(stack: $ItemStack$Type): float
public "definition$canDisableShield"(stack: $ItemStack$Type, shield: $ItemStack$Type, entity: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
public "definition$doesSneakBypassUse"(stack: $ItemStack$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "getMaterialEnchantability"(stack: $ItemStack$Type): integer
public "definition$onEntitySwing"(entityLiving: $LivingEntity$Type, stack: $ItemStack$Type): boolean
public "getTotalEnchantability"(stack: $ItemStack$Type): integer
public "getMaterialDurability"(stack: $ItemStack$Type): integer
public "definition$getDamage"(stack: $ItemStack$Type): integer
public "getTotalMaxDurability"(stack: $ItemStack$Type): integer
public "getMaterialToolSpeed"(stack: $ItemStack$Type): float
public "getMaterialHarvestLevel"(stack: $ItemStack$Type): integer
public "definition$getMaxDamage"(stack: $ItemStack$Type): integer
public "definition$setDamage"(stack: $ItemStack$Type, durability: integer): void
public "definition$getDurabilityForDisplay"(stack: $ItemStack$Type): double
public "definition$onItemUse"(context: $UseOnContext$Type): $InteractionResult
public "setLastCraftingSoundTime"(stack: $ItemStack$Type): void
public "definition$initCapabilities"(stack: $ItemStack$Type, nbt: $CompoundTag$Type): $ICapabilityProvider
public "definition$appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "definition$shouldOpenUIAfterUse"(context: $UseOnContext$Type): boolean
public "definition$fillItemCategory"(category: $CreativeModeTab$Type, items: $NonNullList$Type<($ItemStack$Type)>): void
public "definition$onItemUseFirst"(stack: $ItemStack$Type, context: $UseOnContext$Type): $InteractionResult
public "definition$isCorrectToolForDrops"(stack: $ItemStack$Type, state: $BlockState$Type): boolean
get "description"(): $Component
get "sound"(): $SoundEntry
get "descriptionId"(): string
get "defaultInstance"(): $ItemStack
get "electric"(): boolean
get "material"(): $Material
get "toolStats"(): $IGTToolDefinition
get "electricTier"(): integer
get "toolType"(): $GTToolType
get "raw"(): $ItemStack
set "lastCraftingSoundTime"(value: $ItemStack$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTHoeItem$Type = ($GTHoeItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTHoeItem_ = $GTHoeItem$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$MedicalCondition$IdleProgressionType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $MedicalCondition$IdleProgressionType extends $Enum<($MedicalCondition$IdleProgressionType)> {
static readonly "UNTREATED_PROGRESSION": $MedicalCondition$IdleProgressionType
static readonly "HEAL": $MedicalCondition$IdleProgressionType
static readonly "NONE": $MedicalCondition$IdleProgressionType


public static "values"(): ($MedicalCondition$IdleProgressionType)[]
public static "valueOf"(name: string): $MedicalCondition$IdleProgressionType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MedicalCondition$IdleProgressionType$Type = (("heal") | ("none") | ("untreated_progression")) | ($MedicalCondition$IdleProgressionType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MedicalCondition$IdleProgressionType_ = $MedicalCondition$IdleProgressionType$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/$TickableSubscription" {
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $TickableSubscription {

constructor(runnable: $Runnable$Type)

public "run"(): void
public "unsubscribe"(): void
public "isStillSubscribed"(): boolean
get "stillSubscribed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickableSubscription$Type = ($TickableSubscription);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TickableSubscription_ = $TickableSubscription$Type;
}}
declare module "packages/com/gregtechceu/gtceu/data/recipe/builder/$GTRecipeBuilder$ResearchRecipeEntry" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $GTRecipeBuilder$ResearchRecipeEntry extends $Record {

constructor(researchId: string, researchStack: $ItemStack$Type, dataStack: $ItemStack$Type, duration: integer, EUt: integer, CWUt: integer)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "duration"(): integer
public "dataStack"(): $ItemStack
public "researchId"(): string
public "researchStack"(): $ItemStack
public "CWUt"(): integer
public "EUt"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTRecipeBuilder$ResearchRecipeEntry$Type = ($GTRecipeBuilder$ResearchRecipeEntry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTRecipeBuilder$ResearchRecipeEntry_ = $GTRecipeBuilder$ResearchRecipeEntry$Type;
}}
declare module "packages/com/gregtechceu/gtceu/integration/kjs/events/$GTRegistryEventJS" {
import {$GTRegistryInfo, $GTRegistryInfo$Type} from "packages/com/gregtechceu/gtceu/integration/kjs/$GTRegistryInfo"
import {$StartupEventJS, $StartupEventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$StartupEventJS"
import {$BuilderBase, $BuilderBase$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$BuilderBase"

export class $GTRegistryEventJS<K, V> extends $StartupEventJS {

constructor(r: $GTRegistryInfo$Type<(K), (V)>)

public "create"(id: string, ...args: (any)[]): $BuilderBase<(any)>
public "create"(id: string): $BuilderBase<(any)>
public "create"(id: string, type: string, ...args: (any)[]): $BuilderBase<(any)>
public "create"(id: string, type: string): $BuilderBase<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTRegistryEventJS$Type<K, V> = ($GTRegistryEventJS<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTRegistryEventJS_<K, V> = $GTRegistryEventJS$Type<(K), (V)>;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$FluidPipeProperties" {
import {$FluidStack, $FluidStack$Type} from "packages/com/lowdragmc/lowdraglib/side/fluid/$FluidStack"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IMaterialProperty, $IMaterialProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IMaterialProperty"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MaterialProperties, $MaterialProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$MaterialProperties"
import {$IPropertyFluidFilter, $IPropertyFluidFilter$Type} from "packages/com/gregtechceu/gtceu/api/capability/$IPropertyFluidFilter"
import {$FluidAttribute, $FluidAttribute$Type} from "packages/com/gregtechceu/gtceu/api/fluids/attribute/$FluidAttribute"
import {$FluidState, $FluidState$Type} from "packages/com/gregtechceu/gtceu/api/fluids/$FluidState"

export class $FluidPipeProperties implements $IMaterialProperty<($FluidPipeProperties)>, $IPropertyFluidFilter {
static readonly "MAX_PIPE_CHANNELS": integer

constructor(maxFluidTemperature: integer, throughput: long, gasProof: boolean, acidProof: boolean, cryoProof: boolean, plasmaProof: boolean, channels: integer)
constructor(maxFluidTemperature: integer, throughput: long, gasProof: boolean, acidProof: boolean, cryoProof: boolean, plasmaProof: boolean)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getChannels"(): integer
public "setCryoProof"(cryoProof: boolean): void
public "verifyProperty"(properties: $MaterialProperties$Type): void
public "setChannels"(channels: integer): void
public "setPlasmaProof"(plasmaProof: boolean): void
public "setGasProof"(gasProof: boolean): void
public "setThroughput"(throughput: long): void
public "getContainedAttributes"(): $Collection<($FluidAttribute)>
public "getMaxFluidTemperature"(): integer
public "getThroughput"(): long
public "setMaxFluidTemperature"(maxFluidTemperature: integer): void
public "getPlatformThroughput"(): long
public "setCanContain"(attribute: $FluidAttribute$Type, canContain: boolean): void
public "canContain"(attribute: $FluidAttribute$Type): boolean
public "canContain"(state: $FluidState$Type): boolean
public "isPlasmaProof"(): boolean
public "isGasProof"(): boolean
public "isAcidProof"(): boolean
public "isCryoProof"(): boolean
public "test"(stack: $FluidStack$Type): boolean
public "appendTooltips"(tooltip: $List$Type<($Component$Type)>, showToolsInfo: boolean, showTemperatureInfo: boolean): void
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($FluidStack)>
public "negate"(): $Predicate<($FluidStack)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($FluidStack)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($FluidStack)>
public static "isEqual"<T>(arg0: any): $Predicate<($FluidStack)>
get "channels"(): integer
set "cryoProof"(value: boolean)
set "channels"(value: integer)
set "plasmaProof"(value: boolean)
set "gasProof"(value: boolean)
set "throughput"(value: long)
get "containedAttributes"(): $Collection<($FluidAttribute)>
get "maxFluidTemperature"(): integer
get "throughput"(): long
set "maxFluidTemperature"(value: integer)
get "platformThroughput"(): long
get "plasmaProof"(): boolean
get "gasProof"(): boolean
get "acidProof"(): boolean
get "cryoProof"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidPipeProperties$Type = ($FluidPipeProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidPipeProperties_ = $FluidPipeProperties$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$MedicalCondition" {
import {$MedicalConditionTracker, $MedicalConditionTracker$Type} from "packages/com/gregtechceu/gtceu/common/capability/$MedicalConditionTracker"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$GTRecipeBuilder, $GTRecipeBuilder$Type} from "packages/com/gregtechceu/gtceu/data/recipe/builder/$GTRecipeBuilder"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$Symptom$ConfiguredSymptom, $Symptom$ConfiguredSymptom$Type} from "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$Symptom$ConfiguredSymptom"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$MedicalCondition$IdleProgressionType, $MedicalCondition$IdleProgressionType$Type} from "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$MedicalCondition$IdleProgressionType"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MedicalCondition {
static readonly "CONDITIONS": $Map<(string), ($MedicalCondition)>
readonly "name": string
readonly "color": integer
readonly "maxProgression": float
readonly "symptoms": $Set<($Symptom$ConfiguredSymptom)>
readonly "idleProgressionType": $MedicalCondition$IdleProgressionType
readonly "idleProgressionRate": float
readonly "canBePermanent": boolean
 "recipeModifier": $Consumer<($GTRecipeBuilder)>

constructor(name: string, color: integer, maxProgression: integer, ...symptoms: ($Symptom$ConfiguredSymptom$Type)[])
constructor(name: string, color: integer, maxProgression: integer, progressionType: $MedicalCondition$IdleProgressionType$Type, canBePermanent: boolean, ...symptoms: ($Symptom$ConfiguredSymptom$Type)[])
constructor(name: string, color: integer, maxProgression: integer, idleProgressionType: $MedicalCondition$IdleProgressionType$Type, idleProgressionRate: float, canBePermanent: boolean, ...symptoms: ($Symptom$ConfiguredSymptom$Type)[])

public "getDamageSource"(level: $Level$Type): $DamageSource
public "getDamageSource"(tracker: $MedicalConditionTracker$Type): $DamageSource
public "setRecipeModifier"(recipeModifier: $Consumer$Type<($GTRecipeBuilder$Type)>): $MedicalCondition
public "getRecipeModifier"(): $Consumer<($GTRecipeBuilder)>
set "recipeModifier"(value: $Consumer$Type<($GTRecipeBuilder$Type)>)
get "recipeModifier"(): $Consumer<($GTRecipeBuilder)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MedicalCondition$Type = ($MedicalCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MedicalCondition_ = $MedicalCondition$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/cable/$EnergyNet" {
import {$WireProperties, $WireProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$WireProperties"
import {$EnergyRoutePath, $EnergyRoutePath$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/cable/$EnergyRoutePath"
import {$PipeNet, $PipeNet$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$PipeNet"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $EnergyNet extends $PipeNet<($WireProperties)> {


public "clearCache"(): void
public "getNetData"(pipePos: $BlockPos$Type): $List<($EnergyRoutePath)>
public "getEnergyFluxPerSec"(): long
public "addEnergyFluxPerSec"(energy: long): void
public "onPipeConnectionsUpdate"(): void
public "onNeighbourUpdate"(fromPos: $BlockPos$Type): void
get "energyFluxPerSec"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyNet$Type = ($EnergyNet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyNet_ = $EnergyNet$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/capability/$MedicalConditionTracker" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$INBTSerializable, $INBTSerializable$Type} from "packages/net/minecraftforge/common/util/$INBTSerializable"
import {$MedicalCondition, $MedicalCondition$Type} from "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$MedicalCondition"
import {$IMedicalConditionTracker, $IMedicalConditionTracker$Type} from "packages/com/gregtechceu/gtceu/api/capability/$IMedicalConditionTracker"
import {$Object2FloatMap, $Object2FloatMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatMap"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $MedicalConditionTracker implements $IMedicalConditionTracker, $INBTSerializable<($CompoundTag)> {

constructor(player: $Player$Type)

public "tick"(): void
public "getMaxAirSupply"(): integer
public "heal"(condition: $MedicalCondition$Type, progression: integer): void
public "getPlayer"(): $Player
public "deserializeNBT"(arg: $CompoundTag$Type): void
public "serializeNBT"(): $CompoundTag
public "getMedicalConditions"(): $Object2FloatMap<($MedicalCondition)>
public "removeMedicalCondition"(condition: $MedicalCondition$Type): void
public "progressCondition"(condition: $MedicalCondition$Type, strength: float): void
public "setMobEffect"(effect: $MobEffect$Type, amplifier: integer): void
public "setMaxAirSupply"(maxAirSupply: integer): void
public "progressRelatedCondition"(material: $Material$Type): void
get "maxAirSupply"(): integer
get "player"(): $Player
get "medicalConditions"(): $Object2FloatMap<($MedicalCondition)>
set "maxAirSupply"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MedicalConditionTracker$Type = ($MedicalConditionTracker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MedicalConditionTracker_ = $MedicalConditionTracker$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/gui/fancy/$IFancyConfigurator" {
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Widget, $Widget$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$Widget"
import {$IGuiTexture, $IGuiTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$IGuiTexture"

export interface $IFancyConfigurator {

 "getTitle"(): $Component
 "writeInitialData"(buffer: $FriendlyByteBuf$Type): void
 "readInitialData"(buffer: $FriendlyByteBuf$Type): void
 "getIcon"(): $IGuiTexture
 "getTooltips"(): $List<($Component)>
 "readUpdateInfo"(id: integer, buf: $FriendlyByteBuf$Type): void
 "createConfigurator"(): $Widget
 "detectAndSendChange"(sender: $BiConsumer$Type<(integer), ($Consumer$Type<($FriendlyByteBuf$Type)>)>): void
}

export namespace $IFancyConfigurator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFancyConfigurator$Type = ($IFancyConfigurator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFancyConfigurator_ = $IFancyConfigurator$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/capability/$ICleanroomReceiver" {
import {$ICleanroomProvider, $ICleanroomProvider$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/$ICleanroomProvider"

export interface $ICleanroomReceiver {

 "getCleanroom"(): $ICleanroomProvider
 "setCleanroom"(arg0: $ICleanroomProvider$Type): void
}

export namespace $ICleanroomReceiver {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICleanroomReceiver$Type = ($ICleanroomReceiver);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICleanroomReceiver_ = $ICleanroomReceiver$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/lookup/$RecipeIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$GTRecipe, $GTRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $RecipeIterator implements $Iterator<($GTRecipe)> {


public "hasNext"(): boolean
public "reset"(): void
public "remove"(): void
public "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeIterator$Type = ($RecipeIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeIterator_ = $RecipeIterator$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/$DuctPipeBlockItem" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$IRenderer, $IRenderer$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IRenderer"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$FoodProperties, $FoodProperties$Type} from "packages/net/minecraft/world/food/$FoodProperties"
import {$DuctPipeBlock, $DuctPipeBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/$DuctPipeBlock"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$Type} from "packages/net/mehvahdjukaar/moonlight/api/item/additional_placements/$AdditionalItemPlacement"
import {$IItemRendererProvider, $IItemRendererProvider$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IItemRendererProvider"
import {$PipeBlockItem, $PipeBlockItem$Type} from "packages/com/gregtechceu/gtceu/api/item/$PipeBlockItem"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $DuctPipeBlockItem extends $PipeBlockItem implements $IItemRendererProvider {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "descriptionId": string
 "foodProperties": $FoodProperties
readonly "canRepair": boolean
 "renderProperties": any
 "moonlight$clientAnimationProvider": any

constructor(block: $DuctPipeBlock$Type, properties: $Item$Properties$Type)

public "getBlock"(): $DuctPipeBlock
public "getRenderer"(stack: $ItemStack$Type): $IRenderer
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public "moonlight$addAdditionalBehavior"(arg0: $AdditionalItemPlacement$Type): void
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
get "block"(): $DuctPipeBlock
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DuctPipeBlockItem$Type = ($DuctPipeBlockItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DuctPipeBlockItem_ = $DuctPipeBlockItem$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/explosive/$PowderbarrelBlock" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$GTExplosiveBlock, $GTExplosiveBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/explosive/$GTExplosiveBlock"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$List, $List$Type} from "packages/java/util/$List"

export class $PowderbarrelBlock extends $GTExplosiveBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type)

public "appendHoverText"(stack: $ItemStack$Type, level: $BlockGetter$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PowderbarrelBlock$Type = ($PowderbarrelBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PowderbarrelBlock_ = $PowderbarrelBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/block/$MaterialBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$AppearanceBlock, $AppearanceBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$AppearanceBlock"
import {$BlockColor, $BlockColor$Type} from "packages/net/minecraft/client/color/block/$BlockColor"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$TagPrefix, $TagPrefix$Type} from "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"

export class $MaterialBlock extends $AppearanceBlock {
readonly "tagPrefix": $TagPrefix
readonly "material": $Material
static "FRAME_COLLISION_BOX": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, tagPrefix: $TagPrefix$Type, material: $Material$Type, registerModel: boolean)
constructor(properties: $BlockBehaviour$Properties$Type, tagPrefix: $TagPrefix$Type, material: $Material$Type)

public "getDescriptionId"(): string
public "getName"(): $MutableComponent
public "onPlace"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, oldState: $BlockState$Type, isMoving: boolean): void
public "updateShape"(state: $BlockState$Type, direction: $Direction$Type, neighborState: $BlockState$Type, level: $LevelAccessor$Type, currentPos: $BlockPos$Type, neighborPos: $BlockPos$Type): $BlockState
public "use"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
public "canBeReplaced"(state: $BlockState$Type, useContext: $BlockPlaceContext$Type): boolean
public "getCollisionShape"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type, context: $CollisionContext$Type): $VoxelShape
public "tick"(state: $BlockState$Type, level: $ServerLevel$Type, pos: $BlockPos$Type, random: $RandomSource$Type): void
public "entityInside"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, entity: $Entity$Type): void
public "animateTick"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, random: $RandomSource$Type): void
public static "getFrameboxFromItem"(stack: $ItemStack$Type): $MaterialBlock
public "replaceWithFramedPipe"(level: $Level$Type, pos: $BlockPos$Type, state: $BlockState$Type, player: $Player$Type, stackInHand: $ItemStack$Type, hit: $BlockHitResult$Type): boolean
public static "tintedColor"(): $BlockColor
public "removeFrame"(level: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, stack: $ItemStack$Type): boolean
get "descriptionId"(): string
get "name"(): $MutableComponent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialBlock$Type = ($MaterialBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialBlock_ = $MaterialBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$WoodProperty" {
import {$IMaterialProperty, $IMaterialProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IMaterialProperty"
import {$MaterialProperties, $MaterialProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$MaterialProperties"

export class $WoodProperty implements $IMaterialProperty<($WoodProperty)> {

constructor()

public "verifyProperty"(properties: $MaterialProperties$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WoodProperty$Type = ($WoodProperty);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WoodProperty_ = $WoodProperty$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/trait/$RecipeLogic$Status" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $RecipeLogic$Status extends $Enum<($RecipeLogic$Status)> {
static readonly "IDLE": $RecipeLogic$Status
static readonly "WORKING": $RecipeLogic$Status
static readonly "WAITING": $RecipeLogic$Status
static readonly "SUSPEND": $RecipeLogic$Status


public static "values"(): ($RecipeLogic$Status)[]
public static "valueOf"(name: string): $RecipeLogic$Status
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeLogic$Status$Type = (("suspend") | ("waiting") | ("idle") | ("working")) | ($RecipeLogic$Status);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeLogic$Status_ = $RecipeLogic$Status$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/$DrumMachineItem" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$MetaMachineItem, $MetaMachineItem$Type} from "packages/com/gregtechceu/gtceu/api/item/$MetaMachineItem"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$FoodProperties, $FoodProperties$Type} from "packages/net/minecraft/world/food/$FoodProperties"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$Type} from "packages/net/mehvahdjukaar/moonlight/api/item/additional_placements/$AdditionalItemPlacement"
import {$IMachineBlock, $IMachineBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$IMachineBlock"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $DrumMachineItem extends $MetaMachineItem {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "descriptionId": string
 "foodProperties": $FoodProperties
readonly "canRepair": boolean
 "renderProperties": any
 "moonlight$clientAnimationProvider": any


public static "create"(block: $IMachineBlock$Type, properties: $Item$Properties$Type): $DrumMachineItem
public "getCapability"<T>(itemStack: $ItemStack$Type, cap: $Capability$Type<(T)>): $LazyOptional<(T)>
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public "moonlight$addAdditionalBehavior"(arg0: $AdditionalItemPlacement$Type): void
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DrumMachineItem$Type = ($DrumMachineItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DrumMachineItem_ = $DrumMachineItem$Type;
}}
declare module "packages/com/gregtechceu/gtceu/integration/kjs/events/$GTBedrockOreVeinEventJS" {
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$BedrockOreDefinition$Builder, $BedrockOreDefinition$Builder$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/bedrockore/$BedrockOreDefinition$Builder"
import {$BedrockOreDefinition, $BedrockOreDefinition$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/bedrockore/$BedrockOreDefinition"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $GTBedrockOreVeinEventJS extends $EventJS {

constructor()

public "add"(id: $ResourceLocation$Type, consumer: $Consumer$Type<($BedrockOreDefinition$Builder$Type)>): void
public "remove"(id: $ResourceLocation$Type): void
public "modify"(id: $ResourceLocation$Type, consumer: $Consumer$Type<($BedrockOreDefinition$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTBedrockOreVeinEventJS$Type = ($GTBedrockOreVeinEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTBedrockOreVeinEventJS_ = $GTBedrockOreVeinEventJS$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTLayerPattern$Builder" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$GTLayerPattern$Layer$Builder, $GTLayerPattern$Layer$Builder$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTLayerPattern$Layer$Builder"
import {$GTLayerPattern, $GTLayerPattern$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTLayerPattern"

export class $GTLayerPattern$Builder {


public "layer"(builder: $Consumer$Type<($GTLayerPattern$Layer$Builder$Type)>): $GTLayerPattern$Builder
public "build"(): $GTLayerPattern
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTLayerPattern$Builder$Type = ($GTLayerPattern$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTLayerPattern$Builder_ = $GTLayerPattern$Builder$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/stack/$ItemMaterialInfo" {
import {$MaterialStack, $MaterialStack$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/stack/$MaterialStack"
import {$ImmutableList, $ImmutableList$Type} from "packages/com/google/common/collect/$ImmutableList"
import {$List, $List$Type} from "packages/java/util/$List"

export class $ItemMaterialInfo {

constructor(...materials: ($MaterialStack$Type)[])
constructor(materials: $List$Type<($MaterialStack$Type)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getMaterials"(): $ImmutableList<($MaterialStack)>
public "getMaterial"(): $MaterialStack
get "materials"(): $ImmutableList<($MaterialStack)>
get "material"(): $MaterialStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemMaterialInfo$Type = ($ItemMaterialInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemMaterialInfo_ = $ItemMaterialInfo$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/info/$MaterialFlags" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$MaterialFlag, $MaterialFlag$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/info/$MaterialFlag"

export class $MaterialFlags {
static readonly "NO_UNIFICATION": $MaterialFlag
static readonly "DECOMPOSITION_BY_ELECTROLYZING": $MaterialFlag
static readonly "DECOMPOSITION_BY_CENTRIFUGING": $MaterialFlag
static readonly "DISABLE_DECOMPOSITION": $MaterialFlag
static readonly "EXPLOSIVE": $MaterialFlag
static readonly "FLAMMABLE": $MaterialFlag
static readonly "STICKY": $MaterialFlag
static readonly "PHOSPHORESCENT": $MaterialFlag
static readonly "GENERATE_PLATE": $MaterialFlag
static readonly "GENERATE_DENSE": $MaterialFlag
static readonly "GENERATE_ROD": $MaterialFlag
static readonly "GENERATE_BOLT_SCREW": $MaterialFlag
static readonly "GENERATE_FRAME": $MaterialFlag
static readonly "GENERATE_GEAR": $MaterialFlag
static readonly "GENERATE_LONG_ROD": $MaterialFlag
static readonly "FORCE_GENERATE_BLOCK": $MaterialFlag
static readonly "EXCLUDE_BLOCK_CRAFTING_RECIPES": $MaterialFlag
static readonly "EXCLUDE_PLATE_COMPRESSOR_RECIPE": $MaterialFlag
static readonly "EXCLUDE_BLOCK_CRAFTING_BY_HAND_RECIPES": $MaterialFlag
static readonly "MORTAR_GRINDABLE": $MaterialFlag
static readonly "NO_WORKING": $MaterialFlag
static readonly "NO_SMASHING": $MaterialFlag
static readonly "NO_SMELTING": $MaterialFlag
static readonly "NO_ORE_SMELTING": $MaterialFlag
static readonly "NO_ORE_PROCESSING_TAB": $MaterialFlag
static readonly "BLAST_FURNACE_CALCITE_DOUBLE": $MaterialFlag
static readonly "BLAST_FURNACE_CALCITE_TRIPLE": $MaterialFlag
static readonly "DISABLE_ALLOY_BLAST": $MaterialFlag
static readonly "DISABLE_ALLOY_PROPERTY": $MaterialFlag
static readonly "SOLDER_MATERIAL": $MaterialFlag
static readonly "SOLDER_MATERIAL_BAD": $MaterialFlag
static readonly "SOLDER_MATERIAL_GOOD": $MaterialFlag
static readonly "GENERATE_FOIL": $MaterialFlag
static readonly "GENERATE_RING": $MaterialFlag
static readonly "GENERATE_SPRING": $MaterialFlag
static readonly "GENERATE_SPRING_SMALL": $MaterialFlag
static readonly "GENERATE_SMALL_GEAR": $MaterialFlag
static readonly "GENERATE_FINE_WIRE": $MaterialFlag
static readonly "GENERATE_ROTOR": $MaterialFlag
static readonly "GENERATE_ROUND": $MaterialFlag
static readonly "IS_MAGNETIC": $MaterialFlag
static readonly "CRYSTALLIZABLE": $MaterialFlag
static readonly "GENERATE_LENS": $MaterialFlag
static readonly "HIGH_SIFTER_OUTPUT": $MaterialFlag

constructor()

public "toString"(): string
public "verify"(material: $Material$Type): void
public "addFlags"(...flags: ($MaterialFlag$Type)[]): $MaterialFlags
public "hasFlag"(flag: $MaterialFlag$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialFlags$Type = ($MaterialFlags);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialFlags_ = $MaterialFlags$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/$RendererBlockItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$BlockItem, $BlockItem$Type} from "packages/net/minecraft/world/item/$BlockItem"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$IRenderer, $IRenderer$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IRenderer"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$Type} from "packages/net/mehvahdjukaar/moonlight/api/item/additional_placements/$AdditionalItemPlacement"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IItemRendererProvider, $IItemRendererProvider$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IItemRendererProvider"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$FoodProperties, $FoodProperties$Type} from "packages/net/minecraft/world/food/$FoodProperties"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RendererBlockItem extends $BlockItem implements $IItemRendererProvider {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "descriptionId": string
 "foodProperties": $FoodProperties
readonly "canRepair": boolean
 "renderProperties": any
 "moonlight$clientAnimationProvider": any

constructor(block: $Block$Type, properties: $Item$Properties$Type)

public "getRenderer"(stack: $ItemStack$Type): $IRenderer
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public "moonlight$addAdditionalBehavior"(arg0: $AdditionalItemPlacement$Type): void
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RendererBlockItem$Type = ($RendererBlockItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RendererBlockItem_ = $RendererBlockItem$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/fluids/attribute/$IAttributedFluid" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$FluidAttribute, $FluidAttribute$Type} from "packages/com/gregtechceu/gtceu/api/fluids/attribute/$FluidAttribute"
import {$FluidState, $FluidState$Type} from "packages/com/gregtechceu/gtceu/api/fluids/$FluidState"

export interface $IAttributedFluid {

 "getState"(): $FluidState
 "getAttributes"(): $Collection<($FluidAttribute)>
 "addAttribute"(arg0: $FluidAttribute$Type): void
}

export namespace $IAttributedFluid {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IAttributedFluid$Type = ($IAttributedFluid);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IAttributedFluid_ = $IAttributedFluid$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/info/$MaterialFlag" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $MaterialFlag {


public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "getByName"(name: string): $MaterialFlag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialFlag$Type = ($MaterialFlag);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialFlag_ = $MaterialFlag$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/gui/fancy/$PageSwitcher" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Widget, $Widget$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$Widget"
import {$IFancyUIProvider, $IFancyUIProvider$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$IFancyUIProvider"
import {$IFancyUIProvider$PageGroupingData, $IFancyUIProvider$PageGroupingData$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$IFancyUIProvider$PageGroupingData"
import {$ConfiguratorPanel, $ConfiguratorPanel$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$ConfiguratorPanel"
import {$TabsWidget, $TabsWidget$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$TabsWidget"
import {$TooltipComponent, $TooltipComponent$Type} from "packages/net/minecraft/world/inventory/tooltip/$TooltipComponent"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$FancyMachineUIWidget, $FancyMachineUIWidget$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$FancyMachineUIWidget"
import {$IGuiTexture, $IGuiTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$IGuiTexture"
import {$TooltipsPanel, $TooltipsPanel$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$TooltipsPanel"

export class $PageSwitcher implements $IFancyUIProvider {

constructor(onPageSwitched: $Consumer$Type<($IFancyUIProvider$Type)>)

public "getTitle"(): $Component
public "setPageList"(allPages: $List$Type<($IFancyUIProvider$Type)>, currentPage: $IFancyUIProvider$Type): void
public "createMainPage"(widget: $FancyMachineUIWidget$Type): $Widget
public "getTabIcon"(): $IGuiTexture
public "hasPlayerInventory"(): boolean
public "getTabTooltips"(): $List<($Component)>
public "attachTooltips"(tooltipsPanel: $TooltipsPanel$Type): void
public "attachSideTabs"(configuratorPanel: $TabsWidget$Type): void
public "getSubTabs"(): $List<($IFancyUIProvider)>
public "getTabTooltipComponent"(): $TooltipComponent
public "getPageGroupingData"(): $IFancyUIProvider$PageGroupingData
public "attachConfigurators"(configuratorPanel: $ConfiguratorPanel$Type): void
get "title"(): $Component
get "tabIcon"(): $IGuiTexture
get "tabTooltips"(): $List<($Component)>
get "subTabs"(): $List<($IFancyUIProvider)>
get "tabTooltipComponent"(): $TooltipComponent
get "pageGroupingData"(): $IFancyUIProvider$PageGroupingData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PageSwitcher$Type = ($PageSwitcher);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PageSwitcher_ = $PageSwitcher$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/$OpticalPipeBlockItem" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$IRenderer, $IRenderer$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IRenderer"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$FoodProperties, $FoodProperties$Type} from "packages/net/minecraft/world/food/$FoodProperties"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$OpticalPipeBlock, $OpticalPipeBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/$OpticalPipeBlock"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$Type} from "packages/net/mehvahdjukaar/moonlight/api/item/additional_placements/$AdditionalItemPlacement"
import {$IItemRendererProvider, $IItemRendererProvider$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IItemRendererProvider"
import {$PipeBlockItem, $PipeBlockItem$Type} from "packages/com/gregtechceu/gtceu/api/item/$PipeBlockItem"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $OpticalPipeBlockItem extends $PipeBlockItem implements $IItemRendererProvider {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "descriptionId": string
 "foodProperties": $FoodProperties
readonly "canRepair": boolean
 "renderProperties": any
 "moonlight$clientAnimationProvider": any

constructor(block: $OpticalPipeBlock$Type, properties: $Item$Properties$Type)

public "appendHoverText"(stack: $ItemStack$Type, level: $Level$Type, tooltip: $List$Type<($Component$Type)>, isAdvanced: $TooltipFlag$Type): void
public "getRenderer"(stack: $ItemStack$Type): $IRenderer
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public "moonlight$addAdditionalBehavior"(arg0: $AdditionalItemPlacement$Type): void
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OpticalPipeBlockItem$Type = ($OpticalPipeBlockItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OpticalPipeBlockItem_ = $OpticalPipeBlockItem$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/tool/aoe/$AoESymmetrical" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"

export class $AoESymmetrical {
readonly "column": integer
readonly "row": integer
readonly "layer": integer


public static "of"(column: integer, row: integer, layer: integer): $AoESymmetrical
public static "read"(tag: $CompoundTag$Type, defaultDefinition: $AoESymmetrical$Type): $AoESymmetrical
public static "getLayer"(tag: $CompoundTag$Type, defaultDefinition: $AoESymmetrical$Type): integer
public static "none"(): $AoESymmetrical
public static "getColumn"(tag: $CompoundTag$Type, defaultDefinition: $AoESymmetrical$Type): integer
public static "getRow"(tag: $CompoundTag$Type, defaultDefinition: $AoESymmetrical$Type): integer
public static "decreaseLayer"(tag: $CompoundTag$Type, defaultDefinition: $AoESymmetrical$Type): void
public static "increaseColumn"(tag: $CompoundTag$Type, defaultDefinition: $AoESymmetrical$Type): void
public static "increaseRow"(tag: $CompoundTag$Type, defaultDefinition: $AoESymmetrical$Type): void
public static "increaseLayer"(tag: $CompoundTag$Type, defaultDefinition: $AoESymmetrical$Type): void
public static "decreaseRow"(tag: $CompoundTag$Type, defaultDefinition: $AoESymmetrical$Type): void
public static "decreaseColumn"(tag: $CompoundTag$Type, defaultDefinition: $AoESymmetrical$Type): void
public static "readMax"(tag: $CompoundTag$Type): $AoESymmetrical
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AoESymmetrical$Type = ($AoESymmetrical);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AoESymmetrical_ = $AoESymmetrical$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/gui/fancy/$ConfiguratorPanel$FloatingTab" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IConfigurableWidget, $IConfigurableWidget$Type} from "packages/com/lowdragmc/lowdraglib/gui/editor/configurator/$IConfigurableWidget"
import {$ConfiguratorPanel$Tab, $ConfiguratorPanel$Tab$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$ConfiguratorPanel$Tab"
import {$IFancyConfigurator, $IFancyConfigurator$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$IFancyConfigurator"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Widget, $Widget$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$Widget"
import {$ConfiguratorPanel, $ConfiguratorPanel$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$ConfiguratorPanel"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$Resources, $Resources$Type} from "packages/com/lowdragmc/lowdraglib/gui/editor/data/$Resources"

export class $ConfiguratorPanel$FloatingTab extends $ConfiguratorPanel$Tab {
readonly "widgets": $List<($Widget)>

constructor(this$0: $ConfiguratorPanel$Type, configurator: $IFancyConfigurator$Type)

public "onClose"(closeCallback: $Runnable$Type): void
public "collapseTo"(x: integer, y: integer): void
public static "deserializeNBT"(widget: $IConfigurableWidget$Type, tag: $CompoundTag$Type, resources: $Resources$Type, isProject: boolean): void
public static "serializeNBT"(widget: $IConfigurableWidget$Type, resources: $Resources$Type, isProject: boolean): $CompoundTag
public static "deserializeWrapper"(tag: $CompoundTag$Type): $IConfigurableWidget
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfiguratorPanel$FloatingTab$Type = ($ConfiguratorPanel$FloatingTab);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfiguratorPanel$FloatingTab_ = $ConfiguratorPanel$FloatingTab$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$RotorProperty" {
import {$IMaterialProperty, $IMaterialProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IMaterialProperty"
import {$MaterialProperties, $MaterialProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$MaterialProperties"

export class $RotorProperty implements $IMaterialProperty<($RotorProperty)> {

constructor(power: integer, efficiency: integer, damage: float, durability: integer)

public "getDamage"(): float
public "setDamage"(damage: integer): void
public "verifyProperty"(properties: $MaterialProperties$Type): void
public "getPower"(): integer
public "getEfficiency"(): integer
public "getDurability"(): integer
public "setPower"(power: integer): void
public "setDurability"(durability: integer): void
public "setEfficiency"(efficiency: integer): void
get "damage"(): float
set "damage"(value: integer)
get "power"(): integer
get "efficiency"(): integer
get "durability"(): integer
set "power"(value: integer)
set "durability"(value: integer)
set "efficiency"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RotorProperty$Type = ($RotorProperty);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RotorProperty_ = $RotorProperty$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/$MachineDefinition" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MetaMachine, $MetaMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MetaMachine"
import {$IMachineBlockEntity, $IMachineBlockEntity$Type} from "packages/com/gregtechceu/gtceu/api/machine/$IMachineBlockEntity"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$IMachineBlock, $IMachineBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$IMachineBlock"
import {$GTRecipeType, $GTRecipeType$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipeType"
import {$RecipeModifier, $RecipeModifier$Type} from "packages/com/gregtechceu/gtceu/api/recipe/modifier/$RecipeModifier"
import {$MetaMachineItem, $MetaMachineItem$Type} from "packages/com/gregtechceu/gtceu/api/item/$MetaMachineItem"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$IRenderer, $IRenderer$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IRenderer"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$GTRecipe, $GTRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$RecipeCapability, $RecipeCapability$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$RecipeCapability"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$IRecipeLogicMachine, $IRecipeLogicMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/$IRecipeLogicMachine"
import {$EditableMachineUI, $EditableMachineUI$Type} from "packages/com/gregtechceu/gtceu/api/gui/editor/$EditableMachineUI"
import {$Object2IntMap, $Object2IntMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntMap"

export class $MachineDefinition implements $Supplier<($IMachineBlock)> {


public "getName"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getId"(): $ResourceLocation
public "getItem"(): $MetaMachineItem
public "getShape"(direction: $Direction$Type): $VoxelShape
public "getBlock"(): $Block
public "getBlockEntityType"(): $BlockEntityType<(any)>
public "getEditableUI"(): $EditableMachineUI
public "setShape"(shape: $VoxelShape$Type): void
public "defaultBlockState"(): $BlockState
public "getAppearance"(): $Supplier<($BlockState)>
public "setRenderer"(renderer: $IRenderer$Type): void
public "getTier"(): integer
public "getRenderer"(): $IRenderer
public "getDescriptionId"(): string
public "asStack"(count: integer): $ItemStack
public "asStack"(): $ItemStack
public "getRecipeTypes"(): ($GTRecipeType)[]
public static "createDefinition"(id: $ResourceLocation$Type): $MachineDefinition
public "setTier"(tier: integer): void
public "setDefaultPaintingColor"(defaultPaintingColor: integer): void
public "getDefaultPaintingColor"(): integer
public "getRecipeOutputLimits"(): $Object2IntMap<($RecipeCapability<(any)>)>
public "setBlockEntityTypeSupplier"(blockEntityTypeSupplier: $Supplier$Type<($BlockEntityType$Type<(any)>)>): void
public "setAlwaysTryModifyRecipe"(alwaysTryModifyRecipe: boolean): void
public "isAlwaysTryModifyRecipe"(): boolean
public "setRecipeOutputLimits"(recipeOutputLimits: $Object2IntMap$Type<($RecipeCapability$Type<(any)>)>): void
public "createMetaMachine"(blockEntity: $IMachineBlockEntity$Type): $MetaMachine
public "setRecipeModifier"(recipeModifier: $RecipeModifier$Type): void
public "setBeforeWorking"(beforeWorking: $BiPredicate$Type<($IRecipeLogicMachine$Type), ($GTRecipe$Type)>): void
public "getRecipeModifier"(): $RecipeModifier
public static "setBuilt"(state: $MachineDefinition$Type): void
public "setRecipeTypes"(recipeTypes: ($GTRecipeType$Type)[]): void
public "setOnWorking"(onWorking: $Predicate$Type<($IRecipeLogicMachine$Type)>): void
public "getOnWaiting"(): $Consumer<($IRecipeLogicMachine)>
public "getOnWorking"(): $Predicate<($IRecipeLogicMachine)>
public "getBeforeWorking"(): $BiPredicate<($IRecipeLogicMachine), ($GTRecipe)>
public static "clearBuilt"(): void
public static "getBuilt"(): $MachineDefinition
public "setItemSupplier"(itemSupplier: $Supplier$Type<(any)>): void
public "setBlockSupplier"(blockSupplier: $Supplier$Type<(any)>): void
public "setMachineSupplier"(machineSupplier: $Function$Type<($IMachineBlockEntity$Type), ($MetaMachine$Type)>): void
public "getAfterWorking"(): $Consumer<($IRecipeLogicMachine)>
public "setEditableUI"(editableUI: $EditableMachineUI$Type): void
public "setTooltipBuilder"(tooltipBuilder: $BiConsumer$Type<($ItemStack$Type), ($List$Type<($Component$Type)>)>): void
public "setAppearance"(appearance: $Supplier$Type<($BlockState$Type)>): void
public "setOnWaiting"(onWaiting: $Consumer$Type<($IRecipeLogicMachine$Type)>): void
public "getTooltipBuilder"(): $BiConsumer<($ItemStack), ($List<($Component)>)>
public "setAfterWorking"(afterWorking: $Consumer$Type<($IRecipeLogicMachine$Type)>): void
get "name"(): string
get "id"(): $ResourceLocation
get "item"(): $MetaMachineItem
get "block"(): $Block
get "blockEntityType"(): $BlockEntityType<(any)>
get "editableUI"(): $EditableMachineUI
set "shape"(value: $VoxelShape$Type)
get "appearance"(): $Supplier<($BlockState)>
set "renderer"(value: $IRenderer$Type)
get "tier"(): integer
get "renderer"(): $IRenderer
get "descriptionId"(): string
get "recipeTypes"(): ($GTRecipeType)[]
set "tier"(value: integer)
set "defaultPaintingColor"(value: integer)
get "defaultPaintingColor"(): integer
get "recipeOutputLimits"(): $Object2IntMap<($RecipeCapability<(any)>)>
set "blockEntityTypeSupplier"(value: $Supplier$Type<($BlockEntityType$Type<(any)>)>)
set "alwaysTryModifyRecipe"(value: boolean)
get "alwaysTryModifyRecipe"(): boolean
set "recipeOutputLimits"(value: $Object2IntMap$Type<($RecipeCapability$Type<(any)>)>)
set "recipeModifier"(value: $RecipeModifier$Type)
set "beforeWorking"(value: $BiPredicate$Type<($IRecipeLogicMachine$Type), ($GTRecipe$Type)>)
get "recipeModifier"(): $RecipeModifier
set "built"(value: $MachineDefinition$Type)
set "recipeTypes"(value: ($GTRecipeType$Type)[])
set "onWorking"(value: $Predicate$Type<($IRecipeLogicMachine$Type)>)
get "onWaiting"(): $Consumer<($IRecipeLogicMachine)>
get "onWorking"(): $Predicate<($IRecipeLogicMachine)>
get "beforeWorking"(): $BiPredicate<($IRecipeLogicMachine), ($GTRecipe)>
get "built"(): $MachineDefinition
set "itemSupplier"(value: $Supplier$Type<(any)>)
set "blockSupplier"(value: $Supplier$Type<(any)>)
set "machineSupplier"(value: $Function$Type<($IMachineBlockEntity$Type), ($MetaMachine$Type)>)
get "afterWorking"(): $Consumer<($IRecipeLogicMachine)>
set "editableUI"(value: $EditableMachineUI$Type)
set "tooltipBuilder"(value: $BiConsumer$Type<($ItemStack$Type), ($List$Type<($Component$Type)>)>)
set "appearance"(value: $Supplier$Type<($BlockState$Type)>)
set "onWaiting"(value: $Consumer$Type<($IRecipeLogicMachine$Type)>)
get "tooltipBuilder"(): $BiConsumer<($ItemStack), ($List<($Component)>)>
set "afterWorking"(value: $Consumer$Type<($IRecipeLogicMachine$Type)>)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineDefinition$Type = ($MachineDefinition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineDefinition_ = $MachineDefinition$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/tool/$MaterialToolTier" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ToolProperty, $ToolProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$ToolProperty"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"

export class $MaterialToolTier implements $Tier {
readonly "material": $Material
readonly "property": $ToolProperty

constructor(material: $Material$Type)

public "getTag"(): $TagKey<($Block)>
public "getAttackDamageBonus"(): float
public "getLevel"(): integer
public "getRepairIngredient"(): $Ingredient
public "getEnchantmentValue"(): integer
public "getUses"(): integer
public "getSpeed"(): float
get "tag"(): $TagKey<($Block)>
get "attackDamageBonus"(): float
get "level"(): integer
get "repairIngredient"(): $Ingredient
get "enchantmentValue"(): integer
get "uses"(): integer
get "speed"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialToolTier$Type = ($MaterialToolTier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialToolTier_ = $MaterialToolTier$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/$IWorldGenLayer" {
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$Type} from "packages/net/minecraft/util/$StringRepresentable$EnumCodec"
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$RuleTest, $RuleTest$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$RuleTest"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export interface $IWorldGenLayer extends $StringRepresentable {

 "getTarget"(): $RuleTest
 "getLevels"(): $Set<($ResourceLocation)>
 "isApplicableForLevel"(arg0: $ResourceLocation$Type): boolean
 "getSerializedName"(): string
}

export namespace $IWorldGenLayer {
const CODEC: $Codec<($IWorldGenLayer)>
const NOWHERE: $IWorldGenLayer
function fromEnum<E>(arg0: $Supplier$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
function fromEnumWithMapping<E>(arg0: $Supplier$Type<((E)[])>, arg1: $Function$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
function keys(arg0: ($StringRepresentable$Type)[]): $Keyable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IWorldGenLayer$Type = ($IWorldGenLayer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IWorldGenLayer_ = $IWorldGenLayer$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix" {
import {$MaterialIconType, $MaterialIconType$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/info/$MaterialIconType"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MaterialStack, $MaterialStack$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/stack/$MaterialStack"
import {$TagPrefix$BlockProperties, $TagPrefix$BlockProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix$BlockProperties"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$TagPrefix$MaterialRecipeHandler, $TagPrefix$MaterialRecipeHandler$Type} from "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix$MaterialRecipeHandler"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"
import {$TagPrefix$OreType, $TagPrefix$OreType$Type} from "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix$OreType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$FinishedRecipe, $FinishedRecipe$Type} from "packages/net/minecraft/data/recipes/$FinishedRecipe"
import {$Table, $Table$Type} from "packages/com/google/common/collect/$Table"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IMaterialProperty, $IMaterialProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IMaterialProperty"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"
import {$PropertyKey, $PropertyKey$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$PropertyKey"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $TagPrefix {
static readonly "PREFIXES": $Map<(string), ($TagPrefix)>
static readonly "ORES": $Map<($TagPrefix), ($TagPrefix$OreType)>
static readonly "CODEC": $Codec<($TagPrefix)>
static readonly "ore": $TagPrefix
static readonly "oreGranite": $TagPrefix
static readonly "oreDiorite": $TagPrefix
static readonly "oreAndesite": $TagPrefix
static readonly "oreRedGranite": $TagPrefix
static readonly "oreMarble": $TagPrefix
static readonly "oreDeepslate": $TagPrefix
static readonly "oreTuff": $TagPrefix
static readonly "oreSand": $TagPrefix
static readonly "oreRedSand": $TagPrefix
static readonly "oreGravel": $TagPrefix
static readonly "oreBasalt": $TagPrefix
static readonly "oreNetherrack": $TagPrefix
static readonly "oreBlackstone": $TagPrefix
static readonly "oreEndstone": $TagPrefix
static readonly "rawOre": $TagPrefix
static readonly "rawOreBlock": $TagPrefix
static readonly "crushedRefined": $TagPrefix
static readonly "crushedPurified": $TagPrefix
static readonly "crushed": $TagPrefix
static readonly "ingotHot": $TagPrefix
static readonly "ingot": $TagPrefix
static readonly "gem": $TagPrefix
static readonly "gemChipped": $TagPrefix
static readonly "gemFlawed": $TagPrefix
static readonly "gemFlawless": $TagPrefix
static readonly "gemExquisite": $TagPrefix
static readonly "dustSmall": $TagPrefix
static readonly "dustTiny": $TagPrefix
static readonly "dustImpure": $TagPrefix
static readonly "dustPure": $TagPrefix
static readonly "dust": $TagPrefix
static readonly "nugget": $TagPrefix
static readonly "plateDense": $TagPrefix
static readonly "plateDouble": $TagPrefix
static readonly "plate": $TagPrefix
static readonly "round": $TagPrefix
static readonly "foil": $TagPrefix
static readonly "rodLong": $TagPrefix
static readonly "rod": $TagPrefix
static readonly "bolt": $TagPrefix
static readonly "screw": $TagPrefix
static readonly "ring": $TagPrefix
static readonly "springSmall": $TagPrefix
static readonly "spring": $TagPrefix
static readonly "wireFine": $TagPrefix
static readonly "rotor": $TagPrefix
static readonly "gearSmall": $TagPrefix
static readonly "gear": $TagPrefix
static readonly "lens": $TagPrefix
static readonly "dye": $TagPrefix
static readonly "toolHeadBuzzSaw": $TagPrefix
static readonly "toolHeadScrewdriver": $TagPrefix
static readonly "toolHeadDrill": $TagPrefix
static readonly "toolHeadChainsaw": $TagPrefix
static readonly "toolHeadWrench": $TagPrefix
static readonly "turbineBlade": $TagPrefix
static readonly "block": $TagPrefix
static readonly "log": $TagPrefix
static readonly "planks": $TagPrefix
static readonly "slab": $TagPrefix
static readonly "stairs": $TagPrefix
static readonly "fence": $TagPrefix
static readonly "fenceGate": $TagPrefix
static readonly "door": $TagPrefix
static readonly "rock": $TagPrefix
static readonly "frameGt": $TagPrefix
static readonly "pipeTinyFluid": $TagPrefix
static readonly "pipeSmallFluid": $TagPrefix
static readonly "pipeNormalFluid": $TagPrefix
static readonly "pipeLargeFluid": $TagPrefix
static readonly "pipeHugeFluid": $TagPrefix
static readonly "pipeQuadrupleFluid": $TagPrefix
static readonly "pipeNonupleFluid": $TagPrefix
static readonly "pipeSmallItem": $TagPrefix
static readonly "pipeNormalItem": $TagPrefix
static readonly "pipeLargeItem": $TagPrefix
static readonly "pipeHugeItem": $TagPrefix
static readonly "pipeSmallRestrictive": $TagPrefix
static readonly "pipeNormalRestrictive": $TagPrefix
static readonly "pipeLargeRestrictive": $TagPrefix
static readonly "pipeHugeRestrictive": $TagPrefix
static readonly "wireGtHex": $TagPrefix
static readonly "wireGtOctal": $TagPrefix
static readonly "wireGtQuadruple": $TagPrefix
static readonly "wireGtDouble": $TagPrefix
static readonly "wireGtSingle": $TagPrefix
static readonly "cableGtHex": $TagPrefix
static readonly "cableGtOctal": $TagPrefix
static readonly "cableGtQuadruple": $TagPrefix
static readonly "cableGtDouble": $TagPrefix
static readonly "cableGtSingle": $TagPrefix
readonly "name": string
readonly "invertedName": boolean
 "langValue": string

constructor(name: string, invertedName: boolean)
constructor(name: string)

public "name"(): string
public static "get"(name: string): $TagPrefix
public "equals"(o: any): boolean
public "toString"(): string
public static "values"(): $Collection<($TagPrefix)>
public "hashCode"(): integer
public static "init"(): void
public "getLocalizedName"(material: $Material$Type): $MutableComponent
public "maxStackSize"(): integer
public "maxStackSize"(maxStackSize: integer): $TagPrefix
public static "getPrefix"(prefixName: string, replacement: $TagPrefix$Type): $TagPrefix
public static "getPrefix"(prefixName: string): $TagPrefix
public "removeIgnored"(material: $Material$Type): void
public "blockProperties"(blockProperties: $TagPrefix$BlockProperties$Type): $TagPrefix
public "blockProperties"(renderType: $Supplier$Type<($Supplier$Type<($RenderType$Type)>)>, properties: $UnaryOperator$Type<($BlockBehaviour$Properties$Type)>): $TagPrefix
public "blockProperties"(): $TagPrefix$BlockProperties
public "doGenerateItem"(material: $Material$Type): boolean
public "doGenerateItem"(): boolean
public "getUnlocalizedName"(material: $Material$Type): string
public "getUnlocalizedName"(): string
public "getIgnored"(): $Map<($Material), (($Supplier<(any)>)[])>
public "getItemParentTags"(): ($TagKey<($Item)>)[]
public "getBlockTags"(mat: $Material$Type): ($TagKey<($Block)>)[]
public "getItemTags"(mat: $Material$Type): ($TagKey<($Item)>)[]
public "generateBlock"(generateBlock: boolean): $TagPrefix
public "invertedName"(): boolean
public "idPattern"(): string
public "idPattern"(idPattern: string): $TagPrefix
public "materialIconType"(materialIconType: $MaterialIconType$Type): $TagPrefix
public "materialIconType"(): $MaterialIconType
public "itemTable"(itemTable: $Supplier$Type<($Table$Type<($TagPrefix$Type), ($Material$Type), (any)>)>): $TagPrefix
public "secondaryMaterials"(): $List<($MaterialStack)>
public "generateItem"(generateItem: boolean): $TagPrefix
public "prefixOnlyTagPath"(path: string): $TagPrefix
public static "oreTagPrefix"(name: string, miningToolTag: $TagKey$Type<($Block$Type)>): $TagPrefix
public "defaultTagPath"(path: string): $TagPrefix
public "defaultTagPath"(path: string, isVanilla: boolean): $TagPrefix
public "unificationEnabled"(unificationEnabled: boolean): $TagPrefix
public "materialAmount"(materialAmount: long): $TagPrefix
public "materialAmount"(): long
public "registerOre"(stoneType: $Supplier$Type<($BlockState$Type)>, material: $Supplier$Type<($Material$Type)>, properties: $BlockBehaviour$Properties$Type, baseModelLocation: $ResourceLocation$Type, doubleDrops: boolean, isSand: boolean, shouldDropAsItem: boolean): $TagPrefix
public "registerOre"(stoneType: $Supplier$Type<($BlockState$Type)>, material: $Supplier$Type<($Material$Type)>, properties: $BlockBehaviour$Properties$Type, baseModelLocation: $ResourceLocation$Type, doubleDrops: boolean): $TagPrefix
public "registerOre"(stoneType: $Supplier$Type<($BlockState$Type)>, material: $Supplier$Type<($Material$Type)>, properties: $BlockBehaviour$Properties$Type, baseModelLocation: $ResourceLocation$Type): $TagPrefix
public "registerOre"(stoneType: $Supplier$Type<($BlockState$Type)>, material: $Supplier$Type<($Material$Type)>, properties: $Supplier$Type<($BlockBehaviour$Properties$Type)>, baseModelLocation: $ResourceLocation$Type, doubleDrops: boolean, isSand: boolean, shouldDropAsItem: boolean): $TagPrefix
public "miningToolTag"(tag: $TagKey$Type<($Block$Type)>): $TagPrefix
public "miningToolTag"(): $Set<($TagKey<($Block)>)>
public "unformattedTagPath"(path: string, isVanilla: boolean): $TagPrefix
public "unformattedTagPath"(path: string): $TagPrefix
public "getAllItemTags"(mat: $Material$Type): ($TagKey<($Item)>)[]
public "customTagPath"(path: string, formatter: $BiFunction$Type<($TagPrefix$Type), ($Material$Type), ($TagKey$Type<($Item$Type)>)>): $TagPrefix
public "isAmountModified"(material: $Material$Type): boolean
public "getMaterialAmount"(material: $Material$Type): long
public "prefixTagPath"(path: string): $TagPrefix
public "hasItemTable"(): boolean
public "executeHandler"<T extends $IMaterialProperty<(T)>>(provider: $Consumer$Type<($FinishedRecipe$Type)>, propertyKey: $PropertyKey$Type<(T)>, handler: $TagPrefix$MaterialRecipeHandler$Type<(T)>): void
public "setIgnoredBlock"(material: $Material$Type, ...items: ($Block$Type)[]): void
public "setIgnored"(material: $Material$Type, ...items: ($ItemLike$Type)[]): void
public "setIgnored"(material: $Material$Type, ...items: ($Supplier$Type<(any)>)[]): void
public "setIgnored"(material: $Material$Type): void
public "getItemFromTable"(material: $Material$Type): $Supplier<($ItemLike)>
public "doGenerateBlock"(): boolean
public "doGenerateBlock"(material: $Material$Type): boolean
public "getAllBlockTags"(mat: $Material$Type): ($TagKey<($Block)>)[]
public "isIgnored"(material: $Material$Type): boolean
public "tooltip"(): $BiConsumer<($Material), ($List<($Component)>)>
public "tooltip"(tooltip: $BiConsumer$Type<($Material$Type), ($List$Type<($Component$Type)>)>): $TagPrefix
public "addSecondaryMaterial"(secondaryMaterial: $MaterialStack$Type): void
public "modifyMaterialAmount"(material: $Material$Type, amount: float): void
public "generationCondition"(generationCondition: $Predicate$Type<($Material$Type)>): $TagPrefix
public "generationCondition"(): $Predicate<($Material)>
public "langValue"(langValue: string): $TagPrefix
public "langValue"(): string
get "unlocalizedName"(): string
get "ignored"(): $Map<($Material), (($Supplier<(any)>)[])>
get "itemParentTags"(): ($TagKey<($Item)>)[]
set "ignored"(value: $Material$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagPrefix$Type = ($TagPrefix);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TagPrefix_ = $TagPrefix$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/optical/$LevelOpticalPipeNet" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$OpticalPipeProperties, $OpticalPipeProperties$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/optical/$OpticalPipeProperties"
import {$LevelPipeNet, $LevelPipeNet$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$LevelPipeNet"
import {$OpticalPipeNet, $OpticalPipeNet$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/optical/$OpticalPipeNet"

export class $LevelOpticalPipeNet extends $LevelPipeNet<($OpticalPipeProperties), ($OpticalPipeNet)> {

constructor(serverLevel: $ServerLevel$Type, tag: $CompoundTag$Type)
constructor(level: $ServerLevel$Type)

public static "getOrCreate"(serverLevel: $ServerLevel$Type): $LevelOpticalPipeNet
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelOpticalPipeNet$Type = ($LevelOpticalPipeNet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LevelOpticalPipeNet_ = $LevelOpticalPipeNet$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$ItemPipeProperties" {
import {$IMaterialProperty, $IMaterialProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IMaterialProperty"
import {$MaterialProperties, $MaterialProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$MaterialProperties"

export class $ItemPipeProperties implements $IMaterialProperty<($ItemPipeProperties)> {

constructor(priority: integer, transferRate: float)
constructor()

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "setPriority"(priority: integer): void
public "getPriority"(): integer
public "verifyProperty"(properties: $MaterialProperties$Type): void
public "setTransferRate"(transferRate: float): void
public "getTransferRate"(): float
set "priority"(value: integer)
get "priority"(): integer
set "transferRate"(value: float)
get "transferRate"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPipeProperties$Type = ($ItemPipeProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemPipeProperties_ = $ItemPipeProperties$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/registry/$GTRegistry$String" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Tag, $Tag$Type} from "packages/net/minecraft/nbt/$Tag"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GTRegistry, $GTRegistry$Type} from "packages/com/gregtechceu/gtceu/api/registry/$GTRegistry"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GTRegistry$String<V> extends $GTRegistry<(string), (V)> {
static readonly "REGISTERED": $Map<($ResourceLocation), ($GTRegistry<(any), (any)>)>

constructor(registryName: $ResourceLocation$Type)

public "codec"(): $Codec<(V)>
public "readBuf"(buf: $FriendlyByteBuf$Type): V
public "loadFromNBT"(tag: $Tag$Type): V
public "saveToNBT"(value: V): $Tag
public "writeBuf"(value: V, buf: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTRegistry$String$Type<V> = ($GTRegistry$String<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTRegistry$String_<V> = $GTRegistry$String$Type<(V)>;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$ToolProperty" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$IMaterialProperty, $IMaterialProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IMaterialProperty"
import {$GTToolType, $GTToolType$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType"
import {$MaterialToolTier, $MaterialToolTier$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$MaterialToolTier"
import {$MaterialProperties, $MaterialProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$MaterialProperties"
import {$Object2IntMap, $Object2IntMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntMap"

export class $ToolProperty implements $IMaterialProperty<($ToolProperty)> {

constructor(harvestSpeed: float, attackDamage: float, durability: integer, harvestLevel: integer, types: ($GTToolType$Type)[])
constructor()

public "addTypes"(...types: ($GTToolType$Type)[]): $ToolProperty
public "hasType"(toolType: $GTToolType$Type): boolean
public "setAttackSpeed"(attackSpeed: float): void
public "getTier"(material: $Material$Type): $MaterialToolTier
public "verifyProperty"(properties: $MaterialProperties$Type): void
public "getTypes"(): ($GTToolType)[]
public "getHarvestLevel"(): integer
public "setAttackDamage"(attackDamage: float): void
public "getAttackDamage"(): float
public "getDurability"(): integer
public "getAttackSpeed"(): float
public "getEnchantments"(): $Object2IntMap<($Enchantment)>
public "setHarvestLevel"(harvestLevel: integer): void
public "setTypes"(types: ($GTToolType$Type)[]): void
public "getHarvestSpeed"(): float
public "getEnchantability"(): integer
public "getDurabilityMultiplier"(): integer
public "addEnchantmentForTools"(enchantment: $Enchantment$Type, level: integer): void
public "isUnbreakable"(): boolean
public "setHarvestSpeed"(harvestSpeed: float): void
public "setEnchantability"(enchantability: integer): void
public "setUnbreakable"(isUnbreakable: boolean): void
public "setMagnetic"(isMagnetic: boolean): void
public "setDurability"(durability: integer): void
public "removeTypes"(...types: ($GTToolType$Type)[]): $ToolProperty
public "isMagnetic"(): boolean
public "isIgnoreCraftingTools"(): boolean
public "setIgnoreCraftingTools"(ignoreCraftingTools: boolean): void
public "setDurabilityMultiplier"(durabilityMultiplier: integer): void
set "attackSpeed"(value: float)
get "types"(): ($GTToolType)[]
get "harvestLevel"(): integer
set "attackDamage"(value: float)
get "attackDamage"(): float
get "durability"(): integer
get "attackSpeed"(): float
get "enchantments"(): $Object2IntMap<($Enchantment)>
set "harvestLevel"(value: integer)
set "types"(value: ($GTToolType$Type)[])
get "harvestSpeed"(): float
get "enchantability"(): integer
get "durabilityMultiplier"(): integer
get "unbreakable"(): boolean
set "harvestSpeed"(value: float)
set "enchantability"(value: integer)
set "unbreakable"(value: boolean)
set "magnetic"(value: boolean)
set "durability"(value: integer)
get "magnetic"(): boolean
get "ignoreCraftingTools"(): boolean
set "ignoreCraftingTools"(value: boolean)
set "durabilityMultiplier"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToolProperty$Type = ($ToolProperty);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ToolProperty_ = $ToolProperty$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/$LampBlockItem" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$IRenderer, $IRenderer$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IRenderer"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$LampBlock, $LampBlock$Type} from "packages/com/gregtechceu/gtceu/common/block/$LampBlock"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$FoodProperties, $FoodProperties$Type} from "packages/net/minecraft/world/food/$FoodProperties"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$BlockItem, $BlockItem$Type} from "packages/net/minecraft/world/item/$BlockItem"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$Type} from "packages/net/mehvahdjukaar/moonlight/api/item/additional_placements/$AdditionalItemPlacement"
import {$IItemRendererProvider, $IItemRendererProvider$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IItemRendererProvider"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $LampBlockItem extends $BlockItem implements $IItemRendererProvider {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "descriptionId": string
 "foodProperties": $FoodProperties
readonly "canRepair": boolean
 "renderProperties": any
 "moonlight$clientAnimationProvider": any

constructor(block: $LampBlock$Type, properties: $Item$Properties$Type)

public "getBlock"(): $LampBlock
public "getRenderer"(stack: $ItemStack$Type): $IRenderer
public "fillItemCategory"(category: $CreativeModeTab$Type, items: $NonNullList$Type<($ItemStack$Type)>): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public "moonlight$addAdditionalBehavior"(arg0: $AdditionalItemPlacement$Type): void
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
get "block"(): $LampBlock
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LampBlockItem$Type = ($LampBlockItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LampBlockItem_ = $LampBlockItem$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/ui/$GTRecipeTypeUI" {
import {$GTRecipeType, $GTRecipeType$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipeType"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Table, $Table$Type} from "packages/com/google/common/collect/$Table"
import {$IEditableUI, $IEditableUI$Type} from "packages/com/gregtechceu/gtceu/api/gui/editor/$IEditableUI"
import {$Size, $Size$Type} from "packages/com/lowdragmc/lowdraglib/utils/$Size"
import {$WidgetGroup, $WidgetGroup$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$WidgetGroup"
import {$GTRecipe, $GTRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe"
import {$ProgressTexture, $ProgressTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$ProgressTexture"
import {$RecipeCapability, $RecipeCapability$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$RecipeCapability"
import {$ResourceTexture, $ResourceTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$ResourceTexture"
import {$IO, $IO$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IO"
import {$ProgressTexture$FillDirection, $ProgressTexture$FillDirection$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$ProgressTexture$FillDirection"
import {$Byte2ObjectMap, $Byte2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectMap"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$RecipeCondition, $RecipeCondition$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$RecipeCondition"
import {$List, $List$Type} from "packages/java/util/$List"
import {$DoubleSupplier, $DoubleSupplier$Type} from "packages/java/util/function/$DoubleSupplier"
import {$IGuiTexture, $IGuiTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$IGuiTexture"
import {$GTRecipeTypeUI$RecipeHolder, $GTRecipeTypeUI$RecipeHolder$Type} from "packages/com/gregtechceu/gtceu/api/recipe/ui/$GTRecipeTypeUI$RecipeHolder"
import {$SteamTexture, $SteamTexture$Type} from "packages/com/gregtechceu/gtceu/api/gui/$SteamTexture"

export class $GTRecipeTypeUI {

constructor(recipeType: $GTRecipeType$Type)

public "createUITemplate"(progressSupplier: $DoubleSupplier$Type, storages: $Table$Type<($IO$Type), ($RecipeCapability$Type<(any)>), (any)>, data: $CompoundTag$Type, conditions: $List$Type<($RecipeCondition$Type)>, isSteam: boolean, isHighPressure: boolean): $WidgetGroup
public "createUITemplate"(progressSupplier: $DoubleSupplier$Type, storages: $Table$Type<($IO$Type), ($RecipeCapability$Type<(any)>), (any)>, data: $CompoundTag$Type, conditions: $List$Type<($RecipeCondition$Type)>): $WidgetGroup
public "hasCustomUI"(): boolean
public "reloadCustomUI"(): void
public "getCustomUI"(): $CompoundTag
public "setSteamMoveType"(steamMoveType: $ProgressTexture$FillDirection$Type): void
public "setSlotOverlay"(isOutput: boolean, isFluid: boolean, isLast: boolean, slotOverlay: $IGuiTexture$Type): $GTRecipeTypeUI
public "setSlotOverlay"(isOutput: boolean, isFluid: boolean, slotOverlay: $IGuiTexture$Type): $GTRecipeTypeUI
public "setUiBuilder"(uiBuilder: $BiConsumer$Type<($GTRecipe$Type), ($WidgetGroup$Type)>): void
public "setProgressBar"(progressBar: $ResourceTexture$Type, moveType: $ProgressTexture$FillDirection$Type): $GTRecipeTypeUI
public "getMaxTooltips"(): integer
public "getSlotOverlays"(): $Byte2ObjectMap<($IGuiTexture)>
public "setMaxTooltips"(maxTooltips: integer): void
public "createEditableUITemplate"(isSteam: boolean, isHighPressure: boolean): $IEditableUI<($WidgetGroup), ($GTRecipeTypeUI$RecipeHolder)>
public "isJEIVisible"(): boolean
public "setSteamProgressBarTexture"(steamProgressBarTexture: $SteamTexture$Type): void
public "appendJEIUI"(recipe: $GTRecipe$Type, widgetGroup: $WidgetGroup$Type): void
public "getOriginalWidth"(): integer
public "getJEISize"(): $Size
public "getPropertyHeightShift"(): integer
public "getProgressBarTexture"(): $ProgressTexture
public "setProgressBarTexture"(progressBarTexture: $ProgressTexture$Type): void
public "setSlotOverlays"(slotOverlays: $Byte2ObjectMap$Type<($IGuiTexture$Type)>): void
public "setJEIVisible"(JEIVisible: boolean): void
get "customUI"(): $CompoundTag
set "steamMoveType"(value: $ProgressTexture$FillDirection$Type)
set "uiBuilder"(value: $BiConsumer$Type<($GTRecipe$Type), ($WidgetGroup$Type)>)
get "maxTooltips"(): integer
get "slotOverlays"(): $Byte2ObjectMap<($IGuiTexture)>
set "maxTooltips"(value: integer)
get "jEIVisible"(): boolean
set "steamProgressBarTexture"(value: $SteamTexture$Type)
get "originalWidth"(): integer
get "jEISize"(): $Size
get "propertyHeightShift"(): integer
get "progressBarTexture"(): $ProgressTexture
set "progressBarTexture"(value: $ProgressTexture$Type)
set "slotOverlays"(value: $Byte2ObjectMap$Type<($IGuiTexture$Type)>)
set "jEIVisible"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTRecipeTypeUI$Type = ($GTRecipeTypeUI);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTRecipeTypeUI_ = $GTRecipeTypeUI$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/laser/$LaserRoutePath" {
import {$IAttachData, $IAttachData$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IAttachData"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$IRoutePath, $IRoutePath$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IRoutePath"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ILaserContainer, $ILaserContainer$Type} from "packages/com/gregtechceu/gtceu/api/capability/$ILaserContainer"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $LaserRoutePath implements $IRoutePath<($ILaserContainer)>, $IAttachData {

constructor(targetPipePos: $BlockPos$Type, targetFacing: $Direction$Type, distance: integer)

public "getDistance"(): integer
public "setAttached"(side: $Direction$Type, attach: boolean): boolean
public "getTargetPipePos"(): $BlockPos
public "getTargetFacing"(): $Direction
public "getConnections"(): byte
public "canAttachTo"(side: $Direction$Type): boolean
public "getTargetBlockEntity"(level: $Level$Type): $BlockEntity
public "getTargetCapability"<I>(capability: $Capability$Type<(I)>, level: $Level$Type): I
get "distance"(): integer
get "targetPipePos"(): $BlockPos
get "targetFacing"(): $Direction
get "connections"(): byte
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LaserRoutePath$Type = ($LaserRoutePath);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LaserRoutePath_ = $LaserRoutePath$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pipenet/$IRoutePath" {
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export interface $IRoutePath<T> {

 "getHandler"(arg0: $Level$Type): T
 "getDistance"(): integer
 "getTargetBlockEntity"(level: $Level$Type): $BlockEntity
 "getTargetPipePos"(): $BlockPos
 "getTargetFacing"(): $Direction
 "getTargetCapability"<I>(capability: $Capability$Type<(I)>, level: $Level$Type): I
}

export namespace $IRoutePath {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRoutePath$Type<T> = ($IRoutePath<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRoutePath_<T> = $IRoutePath$Type<(T)>;
}}
declare module "packages/com/gregtechceu/gtceu/api/pipenet/longdistance/$ILDEndpoint" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$ILDNetworkPart, $ILDNetworkPart$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/longdistance/$ILDNetworkPart"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$LongDistancePipeType, $LongDistancePipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/longdistance/$LongDistancePipeType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IO, $IO$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IO"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $ILDEndpoint extends $ILDNetworkPart {

 "getLevel"(): $Level
 "getPos"(): $BlockPos
 "getLink"(): $ILDEndpoint
 "isOutput"(): boolean
 "isInput"(): boolean
 "invalidateLink"(): void
 "setIoType"(arg0: $IO$Type): void
 "getIoType"(): $IO
 "getPipeType"(): $LongDistancePipeType
 "getFrontFacing"(): $Direction
 "isInValid"(): boolean
 "getOutputFacing"(): $Direction
}

export namespace $ILDEndpoint {
function tryGet(world: $LevelAccessor$Type, pos: $BlockPos$Type): $ILDEndpoint
function tryGet(world: $LevelAccessor$Type, pos: $BlockPos$Type, blockState: $BlockState$Type): $ILDNetworkPart
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ILDEndpoint$Type = ($ILDEndpoint);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ILDEndpoint_ = $ILDEndpoint$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/data/machines/$GCyMMachines" {
import {$MachineDefinition, $MachineDefinition$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MachineDefinition"
import {$MultiblockMachineDefinition, $MultiblockMachineDefinition$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MultiblockMachineDefinition"

export class $GCyMMachines {
static readonly "PARALLEL_HATCH": ($MachineDefinition)[]
static readonly "LARGE_MACERATION_TOWER": $MultiblockMachineDefinition
static readonly "LARGE_CHEMICAL_BATH": $MultiblockMachineDefinition
static readonly "LARGE_CENTRIFUGE": $MultiblockMachineDefinition
static readonly "LARGE_MIXER": $MultiblockMachineDefinition
static readonly "LARGE_ELECTROLYZER": $MultiblockMachineDefinition
static readonly "LARGE_ELECTROMAGNET": $MultiblockMachineDefinition
static readonly "LARGE_PACKER": $MultiblockMachineDefinition
static readonly "LARGE_ASSEMBLER": $MultiblockMachineDefinition
static readonly "LARGE_CIRCUIT_ASSEMBLER": $MultiblockMachineDefinition
static readonly "LARGE_ARC_SMELTER": $MultiblockMachineDefinition
static readonly "LARGE_ENGRAVING_LASER": $MultiblockMachineDefinition
static readonly "LARGE_SIFTING_FUNNEL": $MultiblockMachineDefinition
static readonly "BLAST_ALLOY_SMELTER": $MultiblockMachineDefinition
static readonly "LARGE_AUTOCLAVE": $MultiblockMachineDefinition
static readonly "LARGE_MATERIAL_PRESS": $MultiblockMachineDefinition
static readonly "LARGE_BREWER": $MultiblockMachineDefinition
static readonly "LARGE_CUTTER": $MultiblockMachineDefinition
static readonly "LARGE_DISTILLERY": $MultiblockMachineDefinition
static readonly "LARGE_EXTRACTOR": $MultiblockMachineDefinition
static readonly "LARGE_EXTRUDER": $MultiblockMachineDefinition
static readonly "LARGE_SOLIDIFIER": $MultiblockMachineDefinition
static readonly "LARGE_WIREMILL": $MultiblockMachineDefinition
static readonly "MEGA_BLAST_FURNACE": $MultiblockMachineDefinition
static readonly "MEGA_VACUUM_FREEZER": $MultiblockMachineDefinition

constructor()

public static "init"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GCyMMachines$Type = ($GCyMMachines);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GCyMMachines_ = $GCyMMachines$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/data/$GCyMBlocks" {
import {$BlockEntry, $BlockEntry$Type} from "packages/com/tterrag/registrate/util/entry/$BlockEntry"
import {$ActiveBlock, $ActiveBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$ActiveBlock"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $GCyMBlocks {
static readonly "CASING_NONCONDUCTING": $BlockEntry<($Block)>
static readonly "CASING_VIBRATION_SAFE": $BlockEntry<($Block)>
static readonly "CASING_WATERTIGHT": $BlockEntry<($Block)>
static readonly "CASING_SECURE_MACERATION": $BlockEntry<($Block)>
static readonly "CASING_HIGH_TEMPERATURE_SMELTING": $BlockEntry<($Block)>
static readonly "CASING_LASER_SAFE_ENGRAVING": $BlockEntry<($Block)>
static readonly "CASING_LARGE_SCALE_ASSEMBLING": $BlockEntry<($Block)>
static readonly "CASING_SHOCK_PROOF": $BlockEntry<($Block)>
static readonly "CASING_STRESS_PROOF": $BlockEntry<($Block)>
static readonly "CASING_CORROSION_PROOF": $BlockEntry<($Block)>
static readonly "CASING_REACTION_SAFE": $BlockEntry<($Block)>
static readonly "CASING_ATOMIC": $BlockEntry<($Block)>
static readonly "CASING_INDUSTRIAL_STEAM": $BlockEntry<($Block)>
static readonly "SLICING_BLADES": $BlockEntry<($ActiveBlock)>
static readonly "MOLYBDENUM_DISILICIDE_COIL_BLOCK": $BlockEntry<($ActiveBlock)>
static readonly "ELECTROLYTIC_CELL": $BlockEntry<($ActiveBlock)>
static readonly "CRUSHING_WHEELS": $BlockEntry<($ActiveBlock)>
static readonly "HEAT_VENT": $BlockEntry<($ActiveBlock)>

constructor()

public static "init"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GCyMBlocks$Type = ($GCyMBlocks);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GCyMBlocks_ = $GCyMBlocks$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/machine/$KineticMachineDefinition" {
import {$MachineDefinition, $MachineDefinition$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MachineDefinition"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $KineticMachineDefinition extends $MachineDefinition {
readonly "isSource": boolean
readonly "torque": float
 "frontRotation": boolean

constructor(id: $ResourceLocation$Type, isSource: boolean, torque: float)

public "isSource"(): boolean
public "setFrontRotation"(frontRotation: boolean): $KineticMachineDefinition
public "isFrontRotation"(): boolean
public "getTorque"(): float
get "source"(): boolean
set "frontRotation"(value: boolean)
get "frontRotation"(): boolean
get "torque"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KineticMachineDefinition$Type = ($KineticMachineDefinition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KineticMachineDefinition_ = $KineticMachineDefinition$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/capability/recipe/$IO" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$EnumSelectorWidget$SelectableEnum, $EnumSelectorWidget$SelectableEnum$Type} from "packages/com/gregtechceu/gtceu/api/gui/widget/$EnumSelectorWidget$SelectableEnum"
import {$IGuiTexture, $IGuiTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$IGuiTexture"

export class $IO extends $Enum<($IO)> implements $EnumSelectorWidget$SelectableEnum {
static readonly "IN": $IO
static readonly "OUT": $IO
static readonly "BOTH": $IO
static readonly "NONE": $IO
readonly "tooltip": string
readonly "icon": $IGuiTexture


public static "values"(): ($IO)[]
public static "valueOf"(name: string): $IO
public "support"(io: $IO$Type): boolean
public "getIcon"(): $IGuiTexture
public "getTooltip"(): string
get "icon"(): $IGuiTexture
get "tooltip"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IO$Type = (("in") | ("none") | ("out") | ("both")) | ($IO);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IO_ = $IO$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/cover/data/$DistributionMode" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$EnumSelectorWidget$SelectableEnum, $EnumSelectorWidget$SelectableEnum$Type} from "packages/com/gregtechceu/gtceu/api/gui/widget/$EnumSelectorWidget$SelectableEnum"
import {$IGuiTexture, $IGuiTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$IGuiTexture"

export class $DistributionMode extends $Enum<($DistributionMode)> implements $EnumSelectorWidget$SelectableEnum {
static readonly "ROUND_ROBIN_GLOBAL": $DistributionMode
static readonly "ROUND_ROBIN_PRIO": $DistributionMode
static readonly "INSERT_FIRST": $DistributionMode
static readonly "VALUES": ($DistributionMode)[]
readonly "localeName": string


public static "values"(): ($DistributionMode)[]
public static "valueOf"(name: string): $DistributionMode
public "getIcon"(): $IGuiTexture
public "getTooltip"(): string
get "icon"(): $IGuiTexture
get "tooltip"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DistributionMode$Type = (("round_robin_prio") | ("round_robin_global") | ("insert_first")) | ($DistributionMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DistributionMode_ = $DistributionMode$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/$Element" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Element {

constructor(protons: long, neutrons: long, halfLifeSeconds: long, decayTo: string, name: string, symbol: string, isIsotope: boolean)

public "name"(): string
public "name"(name: string): void
public "symbol"(symbol: string): void
public "symbol"(): string
public "mass"(): long
public "protons"(protons: long): void
public "protons"(): long
public "halfLifeSeconds"(): long
public "halfLifeSeconds"(halfLifeSeconds: long): void
public "neutrons"(): long
public "neutrons"(neutrons: long): void
public "decayTo"(decayTo: string): void
public "decayTo"(): string
public "isIsotope"(isIsotope: boolean): void
public "isIsotope"(): boolean
get "isotope"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Element$Type = ($Element);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Element_ = $Element$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType$Builder" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$GTToolType$ToolConstructor, $GTToolType$ToolConstructor$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType$ToolConstructor"
import {$ToolDefinitionBuilder, $ToolDefinitionBuilder$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$ToolDefinitionBuilder"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$IGTToolDefinition, $IGTToolDefinition$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$IGTToolDefinition"
import {$GTToolType, $GTToolType$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType"
import {$SoundEntry, $SoundEntry$Type} from "packages/com/gregtechceu/gtceu/api/sound/$SoundEntry"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $GTToolType$Builder {

constructor(name: string)

public "constructor"(arg0: $GTToolType$ToolConstructor$Type): $GTToolType$Builder
public "build"(): $GTToolType
public "symbol"(symbol: character): $GTToolType$Builder
public "tier"(tier: integer): $GTToolType$Builder
public "sound"(sound: $SoundEntry$Type, playSoundOnBlockDestroy: boolean): $GTToolType$Builder
public "sound"(sound: $SoundEntry$Type): $GTToolType$Builder
public "modelLocation"(modelLocation: $ResourceLocation$Type): $GTToolType$Builder
public "toolStats"(builder: $UnaryOperator$Type<($ToolDefinitionBuilder$Type)>): $GTToolType$Builder
public "toolStats"(toolStats: $IGTToolDefinition$Type): $GTToolType$Builder
public "harvestTag"(...tags: ($TagKey$Type<($Block$Type)>)[]): $GTToolType$Builder
public "toolClasses"(...classes: ($GTToolType$Type)[]): $GTToolType$Builder
public "toolClassNames"(toolClassNames: $Set$Type<(string)>): $GTToolType$Builder
public "toolClassNames"(...classes: (string)[]): $GTToolType$Builder
public "toolTag"(...tags: ($TagKey$Type<($Item$Type)>)[]): $GTToolType$Builder
public "electric"(tier: integer): $GTToolType$Builder
public "idFormat"(idFormat: string): $GTToolType$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTToolType$Builder$Type = ($GTToolType$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTToolType$Builder_ = $GTToolType$Builder$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/stack/$MaterialStack" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$Record, $Record$Type} from "packages/java/lang/$Record"

export class $MaterialStack extends $Record {

constructor(material: $Material$Type, amount: long)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public "copy"(): $MaterialStack
public "copy"(amount: long): $MaterialStack
public "amount"(): long
public static "fromString"(str: charseq): $MaterialStack
public "material"(): $Material
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialStack$Type = ($MaterialStack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialStack_ = $MaterialStack$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/feature/multiblock/$IMultiPart" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IMachineFeature, $IMachineFeature$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/$IMachineFeature"
import {$IRecipeHandlerTrait, $IRecipeHandlerTrait$Type} from "packages/com/gregtechceu/gtceu/api/machine/trait/$IRecipeHandlerTrait"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IFancyUIMachine, $IFancyUIMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/$IFancyUIMachine"
import {$ConfiguratorPanel, $ConfiguratorPanel$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$ConfiguratorPanel"
import {$IFancyUIProvider, $IFancyUIProvider$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$IFancyUIProvider"
import {$IMultiController, $IMultiController$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/multiblock/$IMultiController"
import {$TooltipComponent, $TooltipComponent$Type} from "packages/net/minecraft/world/inventory/tooltip/$TooltipComponent"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MetaMachine, $MetaMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MetaMachine"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$FancyMachineUIWidget, $FancyMachineUIWidget$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$FancyMachineUIWidget"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IWorkableMultiController, $IWorkableMultiController$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/multiblock/$IWorkableMultiController"
import {$GTRecipe, $GTRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe"
import {$Widget, $Widget$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$Widget"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IFancyUIProvider$PageGroupingData, $IFancyUIProvider$PageGroupingData$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$IFancyUIProvider$PageGroupingData"
import {$TabsWidget, $TabsWidget$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$TabsWidget"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$ModularUI, $ModularUI$Type} from "packages/com/lowdragmc/lowdraglib/gui/modular/$ModularUI"
import {$IGuiTexture, $IGuiTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$IGuiTexture"
import {$TooltipsPanel, $TooltipsPanel$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$TooltipsPanel"

export interface $IMultiPart extends $IMachineFeature, $IFancyUIMachine {

 "isFormed"(): boolean
 "getControllers"(): $List<($IMultiController)>
 "hasController"(arg0: $BlockPos$Type): boolean
 "onWorking"(controller: $IWorkableMultiController$Type): boolean
 "afterWorking"(controller: $IWorkableMultiController$Type): boolean
 "onWaiting"(controller: $IWorkableMultiController$Type): boolean
 "beforeWorking"(controller: $IWorkableMultiController$Type): boolean
 "addedToController"(arg0: $IMultiController$Type): void
 "modifyRecipe"(recipe: $GTRecipe$Type): $GTRecipe
 "getRecipeHandlers"(): $List<($IRecipeHandlerTrait)>
 "canShared"(): boolean
 "onPaused"(controller: $IWorkableMultiController$Type): boolean
 "addMultiText"(textList: $List$Type<($Component$Type)>): void
 "getFormedAppearance"(sourceState: $BlockState$Type, sourcePos: $BlockPos$Type, side: $Direction$Type): $BlockState
 "replacePartModelWhenFormed"(): boolean
 "attachFancyTooltipsToController"(controller: $IMultiController$Type, tooltipsPanel: $TooltipsPanel$Type): void
 "removedFromController"(arg0: $IMultiController$Type): void
 "self"(): $MetaMachine
 "getTitle"(): $Component
 "createUI"(entityPlayer: $Player$Type): $ModularUI
 "createMainPage"(widget: $FancyMachineUIWidget$Type): $Widget
 "getTabTooltips"(): $List<($Component)>
 "attachTooltips"(tooltipsPanel: $TooltipsPanel$Type): void
 "attachSideTabs"(sideTabs: $TabsWidget$Type): void
 "getTabIcon"(): $IGuiTexture
 "createUIWidget"(): $Widget
 "attachConfigurators"(configuratorPanel: $ConfiguratorPanel$Type): void
 "isInvalid"(): boolean
 "markAsDirty"(): void
 "isRemote"(): boolean
 "shouldOpenUI"(player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): boolean
 "tryToOpenUI"(player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
 "hasPlayerInventory"(): boolean
 "getSubTabs"(): $List<($IFancyUIProvider)>
 "getTabTooltipComponent"(): $TooltipComponent
 "getPageGroupingData"(): $IFancyUIProvider$PageGroupingData
}

export namespace $IMultiPart {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMultiPart$Type = ($IMultiPart);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMultiPart_ = $IMultiPart$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix$OreType" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $TagPrefix$OreType extends $Record {

constructor(stoneType: $Supplier$Type<($BlockState$Type)>, material: $Supplier$Type<($Material$Type)>, template: $Supplier$Type<($BlockBehaviour$Properties$Type)>, baseModelLocation: $ResourceLocation$Type, isDoubleDrops: boolean, isSand: boolean, shouldDropAsItem: boolean)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "template"(): $Supplier<($BlockBehaviour$Properties)>
public "material"(): $Supplier<($Material)>
public "stoneType"(): $Supplier<($BlockState)>
public "baseModelLocation"(): $ResourceLocation
public "shouldDropAsItem"(): boolean
public "isSand"(): boolean
public "isDoubleDrops"(): boolean
get "sand"(): boolean
get "doubleDrops"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagPrefix$OreType$Type = ($TagPrefix$OreType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TagPrefix$OreType_ = $TagPrefix$OreType$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/cover/data/$ManualIOMode" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$EnumSelectorWidget$SelectableEnum, $EnumSelectorWidget$SelectableEnum$Type} from "packages/com/gregtechceu/gtceu/api/gui/widget/$EnumSelectorWidget$SelectableEnum"
import {$IGuiTexture, $IGuiTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$IGuiTexture"

export class $ManualIOMode extends $Enum<($ManualIOMode)> implements $EnumSelectorWidget$SelectableEnum {
static readonly "DISABLED": $ManualIOMode
static readonly "FILTERED": $ManualIOMode
static readonly "UNFILTERED": $ManualIOMode
static readonly "VALUES": ($ManualIOMode)[]
readonly "localeName": string


public static "values"(): ($ManualIOMode)[]
public static "valueOf"(name: string): $ManualIOMode
public "getIcon"(): $IGuiTexture
public "getTooltip"(): string
get "icon"(): $IGuiTexture
get "tooltip"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ManualIOMode$Type = (("filtered") | ("disabled") | ("unfiltered")) | ($ManualIOMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ManualIOMode_ = $ManualIOMode$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/$ItemPipeBlock" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ItemPipeProperties, $ItemPipeProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$ItemPipeProperties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$PipeModel, $PipeModel$Type} from "packages/com/gregtechceu/gtceu/client/model/$PipeModel"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LevelItemPipeNet, $LevelItemPipeNet$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/item/$LevelItemPipeNet"
import {$IPipeNode, $IPipeNode$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeNode"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$MaterialPipeBlock, $MaterialPipeBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$MaterialPipeBlock"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$PipeBlockRenderer, $PipeBlockRenderer$Type} from "packages/com/gregtechceu/gtceu/client/renderer/block/$PipeBlockRenderer"
import {$IPipeType, $IPipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeType"
import {$ItemPipeType, $ItemPipeType$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/item/$ItemPipeType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"

export class $ItemPipeBlock extends $MaterialPipeBlock<($ItemPipeType), ($ItemPipeProperties), ($LevelItemPipeNet)> {
readonly "material": $Material
readonly "renderer": $PipeBlockRenderer
readonly "model": $PipeModel
readonly "pipeType": PipeType
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, itemPipeType: $ItemPipeType$Type, material: $Material$Type)

public "getBlockEntityType"(): $BlockEntityType<(any)>
public "appendHoverText"(stack: $ItemStack$Type, level: $BlockGetter$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "canPipeConnectToBlock"(selfTile: $IPipeNode$Type<($ItemPipeType$Type), ($ItemPipeProperties$Type)>, side: $Direction$Type, tile: $BlockEntity$Type): boolean
public "getWorldPipeNet"(level: $ServerLevel$Type): $LevelItemPipeNet
public "canPipesConnect"(selfTile: $IPipeNode$Type<($ItemPipeType$Type), ($ItemPipeProperties$Type)>, side: $Direction$Type, sideTile: $IPipeNode$Type<($ItemPipeType$Type), ($ItemPipeProperties$Type)>): boolean
get "blockEntityType"(): $BlockEntityType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPipeBlock$Type = ($ItemPipeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemPipeBlock_ = $ItemPipeBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/laser/$LevelLaserPipeNet" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$LaserPipeNet, $LaserPipeNet$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/laser/$LaserPipeNet"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$LaserPipeProperties, $LaserPipeProperties$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/laser/$LaserPipeProperties"
import {$LevelPipeNet, $LevelPipeNet$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$LevelPipeNet"

export class $LevelLaserPipeNet extends $LevelPipeNet<($LaserPipeProperties), ($LaserPipeNet)> {

constructor(serverLevel: $ServerLevel$Type, tag: $CompoundTag$Type)
constructor(serverLevel: $ServerLevel$Type)

public static "getOrCreate"(serverLevel: $ServerLevel$Type): $LevelLaserPipeNet
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelLaserPipeNet$Type = ($LevelLaserPipeNet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LevelLaserPipeNet_ = $LevelLaserPipeNet$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IngotProperty" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$IMaterialProperty, $IMaterialProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IMaterialProperty"
import {$MaterialProperties, $MaterialProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$MaterialProperties"

export class $IngotProperty implements $IMaterialProperty<($IngotProperty)> {

constructor()

public "verifyProperty"(properties: $MaterialProperties$Type): void
public "setArcSmeltingInto"(arcSmeltingInto: $Material$Type): void
public "setMacerateInto"(macerateInto: $Material$Type): void
public "setSmeltingInto"(smeltingInto: $Material$Type): void
public "setMagneticMaterial"(magneticMaterial: $Material$Type): void
public "getSmeltingInto"(): $Material
public "getArcSmeltingInto"(): $Material
public "getMacerateInto"(): $Material
public "getMagneticMaterial"(): $Material
set "arcSmeltingInto"(value: $Material$Type)
set "macerateInto"(value: $Material$Type)
set "smeltingInto"(value: $Material$Type)
set "magneticMaterial"(value: $Material$Type)
get "smeltingInto"(): $Material
get "arcSmeltingInto"(): $Material
get "macerateInto"(): $Material
get "magneticMaterial"(): $Material
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngotProperty$Type = ($IngotProperty);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IngotProperty_ = $IngotProperty$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/gui/$SteamTexture" {
import {$ResourceTexture, $ResourceTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$ResourceTexture"

export class $SteamTexture {


public "get"(isHighPressure: boolean): $ResourceTexture
public static "fullImage"(path: string): $SteamTexture
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SteamTexture$Type = ($SteamTexture);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SteamTexture_ = $SteamTexture$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/block/$OreBlock" {
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$TagPrefix, $TagPrefix$Type} from "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$MaterialBlock, $MaterialBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$MaterialBlock"

export class $OreBlock extends $MaterialBlock {
readonly "tagPrefix": $TagPrefix
readonly "material": $Material
static "FRAME_COLLISION_BOX": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, tagPrefix: $TagPrefix$Type, material: $Material$Type, registerModel: boolean)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OreBlock$Type = ($OreBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OreBlock_ = $OreBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipeType" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$GTRecipeType$ICustomRecipeLogic, $GTRecipeType$ICustomRecipeLogic$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipeType$ICustomRecipeLogic"
import {$TreeMap, $TreeMap$Type} from "packages/java/util/$TreeMap"
import {$ResourceTexture, $ResourceTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$ResourceTexture"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ProgressTexture$FillDirection, $ProgressTexture$FillDirection$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$ProgressTexture$FillDirection"
import {$GTRecipeTypeUI, $GTRecipeTypeUI$Type} from "packages/com/gregtechceu/gtceu/api/recipe/ui/$GTRecipeTypeUI"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$GTRecipeBuilder, $GTRecipeBuilder$Type} from "packages/com/gregtechceu/gtceu/data/recipe/builder/$GTRecipeBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$FinishedRecipe, $FinishedRecipe$Type} from "packages/net/minecraft/data/recipes/$FinishedRecipe"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$WidgetGroup, $WidgetGroup$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$WidgetGroup"
import {$GTRecipe, $GTRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe"
import {$RecipeCapability, $RecipeCapability$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$RecipeCapability"
import {$IO, $IO$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IO"
import {$IRecipeCapabilityHolder, $IRecipeCapabilityHolder$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IRecipeCapabilityHolder"
import {$Byte2ObjectMap, $Byte2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectMap"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$RecipeManager, $RecipeManager$Type} from "packages/net/minecraft/world/item/crafting/$RecipeManager"
import {$GTRecipeLookup, $GTRecipeLookup$Type} from "packages/com/gregtechceu/gtceu/api/recipe/lookup/$GTRecipeLookup"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"
import {$IGuiTexture, $IGuiTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$IGuiTexture"
import {$SoundEntry, $SoundEntry$Type} from "packages/com/gregtechceu/gtceu/api/sound/$SoundEntry"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$SteamTexture, $SteamTexture$Type} from "packages/com/gregtechceu/gtceu/api/gui/$SteamTexture"
import {$UnificationEntry, $UnificationEntry$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/stack/$UnificationEntry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GTRecipeType implements $RecipeType<($GTRecipe)> {
readonly "registryName": $ResourceLocation
readonly "group": string
readonly "maxInputs": $TreeMap<($RecipeCapability<(any)>), (integer)>
readonly "maxOutputs": $TreeMap<($RecipeCapability<(any)>), (integer)>

constructor(registryName: $ResourceLocation$Type, group: string, ...proxyRecipes: ($RecipeType$Type<(any)>)[])

public "toString"(): string
public "copyFrom"(builder: $GTRecipeBuilder$Type): $GTRecipeBuilder
public "getLookup"(): $GTRecipeLookup
public "setMaxSize"(io: $IO$Type, cap: $RecipeCapability$Type<(any)>, max: integer): $GTRecipeType
public "getRecipe"(recipeManager: $RecipeManager$Type, id: $ResourceLocation$Type): $GTRecipe
public "getIconSupplier"(): $Supplier<($ItemStack)>
public "getRecipeUI"(): $GTRecipeTypeUI
public "getSound"(): $SoundEntry
public "isScanner"(): boolean
public "recipeBuilder"(id: string, ...append: (any)[]): $GTRecipeBuilder
public "recipeBuilder"(id: $ResourceLocation$Type, ...append: (any)[]): $GTRecipeBuilder
public "recipeBuilder"(entry: $UnificationEntry$Type, ...append: (any)[]): $GTRecipeBuilder
public "recipeBuilder"(item: $Supplier$Type<(any)>, ...append: (any)[]): $GTRecipeBuilder
public "recipeBuilder"(itemLike: $ItemLike$Type, ...append: (any)[]): $GTRecipeBuilder
public "isFuelRecipeType"(): boolean
public "addDataInfo"(dataInfo: $Function$Type<($CompoundTag$Type), (string)>): $GTRecipeType
public "searchFuelRecipe"(holder: $IRecipeCapabilityHolder$Type): $Iterator<($GTRecipe)>
public "setEUIO"(io: $IO$Type): $GTRecipeType
public "setSlotOverlay"(isOutput: boolean, isFluid: boolean, isLast: boolean, slotOverlay: $IGuiTexture$Type): $GTRecipeType
public "setSlotOverlay"(isOutput: boolean, isFluid: boolean, slotOverlay: $IGuiTexture$Type): $GTRecipeType
public "setUiBuilder"(uiBuilder: $BiConsumer$Type<($GTRecipe$Type), ($WidgetGroup$Type)>): $GTRecipeType
public "setMaxIOSize"(maxInputs: integer, maxOutputs: integer, maxFluidInputs: integer, maxFluidOutputs: integer): $GTRecipeType
public "setProgressBar"(progressBar: $ResourceTexture$Type, moveType: $ProgressTexture$FillDirection$Type): $GTRecipeType
public "getMaxOutputs"(cap: $RecipeCapability$Type<(any)>): integer
public "searchRecipe"(holder: $IRecipeCapabilityHolder$Type): $Iterator<($GTRecipe)>
public "getMaxInputs"(cap: $RecipeCapability$Type<(any)>): integer
public "onRecipeBuild"(onBuild: $BiConsumer$Type<($GTRecipeBuilder$Type), ($Consumer$Type<($FinishedRecipe$Type)>)>): $GTRecipeType
public "addDataStickEntry"(researchId: string, recipe: $GTRecipe$Type): void
public "getDataStickEntry"(researchId: string): $Collection<($GTRecipe)>
public "prepareBuilder"(onPrepare: $Consumer$Type<($GTRecipeBuilder$Type)>): $GTRecipeType
public "getSmallRecipeMap"(): $GTRecipeType
public "getMaxTooltips"(): integer
public "setRecipeUI"(recipeUI: $GTRecipeTypeUI$Type): $GTRecipeType
public "setSound"(sound: $SoundEntry$Type): $GTRecipeType
public "setScanner"(isScanner: boolean): $GTRecipeType
public "setSmallRecipeMap"(smallRecipeMap: $GTRecipeType$Type): $GTRecipeType
public "isHasResearchSlot"(): boolean
public "getSlotOverlays"(): $Byte2ObjectMap<($IGuiTexture)>
public "setRecipeBuilder"(recipeBuilder: $GTRecipeBuilder$Type): $GTRecipeType
public "setFuelRecipeType"(isFuelRecipeType: boolean): $GTRecipeType
public "setIconSupplier"(iconSupplier: $Supplier$Type<($ItemStack$Type)>): $GTRecipeType
public "setMaxTooltips"(maxTooltips: integer): $GTRecipeType
public "setHasResearchSlot"(hasResearchSlot: boolean): $GTRecipeType
public "getDataInfos"(): $List<($Function<($CompoundTag), (string)>)>
public "getProxyRecipes"(): $Map<($RecipeType<(any)>), ($List<($GTRecipe)>)>
public "toGTrecipe"(id: $ResourceLocation$Type, recipe: $Recipe$Type<(any)>): $GTRecipe
public "setVoltageTextOffset"(voltageTextOffset: integer): $GTRecipeType
public "isOffsetVoltageText"(): boolean
public "getCustomRecipeLogicRunners"(): $List<($GTRecipeType$ICustomRecipeLogic)>
public "setSteamProgressBar"(progressBar: $SteamTexture$Type, moveType: $ProgressTexture$FillDirection$Type): $GTRecipeType
public "addCustomRecipeLogic"(recipeLogic: $GTRecipeType$ICustomRecipeLogic$Type): $GTRecipeType
public "removeDataStickEntry"(researchId: string, recipe: $GTRecipe$Type): boolean
public "getRepresentativeRecipes"(): $List<($GTRecipe)>
public "setOffsetVoltageText"(offsetVoltageText: boolean): $GTRecipeType
public "getVoltageTextOffset"(): integer
public static "simple"<T extends $Recipe<(any)>>(arg0: $ResourceLocation$Type): $RecipeType<($GTRecipe)>
public static "register"<T extends $Recipe<(any)>>(arg0: string): $RecipeType<($GTRecipe)>
get "lookup"(): $GTRecipeLookup
get "iconSupplier"(): $Supplier<($ItemStack)>
get "recipeUI"(): $GTRecipeTypeUI
get "sound"(): $SoundEntry
get "scanner"(): boolean
get "fuelRecipeType"(): boolean
set "eUIO"(value: $IO$Type)
set "uiBuilder"(value: $BiConsumer$Type<($GTRecipe$Type), ($WidgetGroup$Type)>)
get "smallRecipeMap"(): $GTRecipeType
get "maxTooltips"(): integer
set "recipeUI"(value: $GTRecipeTypeUI$Type)
set "sound"(value: $SoundEntry$Type)
set "scanner"(value: boolean)
set "smallRecipeMap"(value: $GTRecipeType$Type)
get "hasResearchSlot"(): boolean
get "slotOverlays"(): $Byte2ObjectMap<($IGuiTexture)>
set "fuelRecipeType"(value: boolean)
set "iconSupplier"(value: $Supplier$Type<($ItemStack$Type)>)
set "maxTooltips"(value: integer)
set "hasResearchSlot"(value: boolean)
get "dataInfos"(): $List<($Function<($CompoundTag), (string)>)>
get "proxyRecipes"(): $Map<($RecipeType<(any)>), ($List<($GTRecipe)>)>
set "voltageTextOffset"(value: integer)
get "offsetVoltageText"(): boolean
get "customRecipeLogicRunners"(): $List<($GTRecipeType$ICustomRecipeLogic)>
get "representativeRecipes"(): $List<($GTRecipe)>
set "offsetVoltageText"(value: boolean)
get "voltageTextOffset"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTRecipeType$Type = ($GTRecipeType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTRecipeType_ = $GTRecipeType$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/$IMachineBlockEntity" {
import {$IAsyncAutoSyncBlockEntity, $IAsyncAutoSyncBlockEntity$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/blockentity/$IAsyncAutoSyncBlockEntity"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IAutoPersistBlockEntity, $IAutoPersistBlockEntity$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/blockentity/$IAutoPersistBlockEntity"
import {$IRPCBlockEntity, $IRPCBlockEntity$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/blockentity/$IRPCBlockEntity"
import {$MultiManagedStorage, $MultiManagedStorage$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/managed/$MultiManagedStorage"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ResourceTexture, $ResourceTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$ResourceTexture"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IRef, $IRef$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/managed/$IRef"
import {$MachineDefinition, $MachineDefinition$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MachineDefinition"
import {$IManaged, $IManaged$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$IManaged"
import {$IToolGridHighLight, $IToolGridHighLight$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$IToolGridHighLight"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$GTToolType, $GTToolType$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType"
import {$MetaMachine, $MetaMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MetaMachine"
import {$RPCMethodMeta, $RPCMethodMeta$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/field/$RPCMethodMeta"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$SPacketRPCMethodPayload, $SPacketRPCMethodPayload$Type} from "packages/com/lowdragmc/lowdraglib/networking/s2c/$SPacketRPCMethodPayload"

export interface $IMachineBlockEntity extends $IToolGridHighLight, $IAsyncAutoSyncBlockEntity, $IRPCBlockEntity, $IAutoPersistBlockEntity {

 "pos"(): $BlockPos
 "getDefinition"(): $MachineDefinition
 "getOffset"(): long
 "self"(): $BlockEntity
 "level"(): $Level
 "getMetaMachine"(): $MetaMachine
 "getRootStorage"(): $MultiManagedStorage
 "notifyBlockUpdate"(): void
 "loadCustomPersistedData"(tag: $CompoundTag$Type): void
 "saveCustomPersistedData"(tag: $CompoundTag$Type, forDrop: boolean): void
 "scheduleRenderUpdate"(): void
 "getOffsetTimer"(): long
 "shouldRenderGrid"(player: $Player$Type, held: $ItemStack$Type, toolTypes: $Set$Type<($GTToolType$Type)>): boolean
 "sideTips"(player: $Player$Type, toolTypes: $Set$Type<($GTToolType$Type)>, side: $Direction$Type): $ResourceTexture
 "onInValid"(): void
 "onValid"(): void
 "useAsyncThread"(): boolean
 "asyncTick"(periodID: long): void
 "getRPCMethod"(managed: $IManaged$Type, methodName: string): $RPCMethodMeta
 "rpcToPlayer"(managed: $IManaged$Type, player: $ServerPlayer$Type, methodName: string, ...args: (any)[]): void
 "rpcToTracking"(managed: $IManaged$Type, methodName: string, ...args: (any)[]): void
 "generateRpcPacket"(managed: $IManaged$Type, methodName: string, ...args: (any)[]): $SPacketRPCMethodPayload
 "saveManagedPersistentData"(tag: $CompoundTag$Type, forDrop: boolean): void
 "loadManagedPersistentData"(tag: $CompoundTag$Type): void
 "readCustomSyncData"(tag: $CompoundTag$Type): void
 "writeCustomSyncData"(tag: $CompoundTag$Type): void
 "getSyncTag"(): string
 "defaultServerTick"(): void
 "syncNow"(force: boolean): void
 "getBlockEntityType"(): $BlockEntityType<(any)>
 "getCurrentPos"(): $BlockPos
 "getSelf"(): $BlockEntity
 "getNonLazyFields"(): ($IRef)[]
}

export namespace $IMachineBlockEntity {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMachineBlockEntity$Type = ($IMachineBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMachineBlockEntity_ = $IMachineBlockEntity$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/lookup/$AbstractMapIngredient" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $AbstractMapIngredient {


public "equals"(obj: any): boolean
public "hashCode"(): integer
public "isSpecialIngredient"(): boolean
get "specialIngredient"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractMapIngredient$Type = ($AbstractMapIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractMapIngredient_ = $AbstractMapIngredient$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pattern/$TraceabilityPredicate" {
import {$MultiblockState, $MultiblockState$Type} from "packages/com/gregtechceu/gtceu/api/pattern/$MultiblockState"
import {$BlockInfo, $BlockInfo$Type} from "packages/com/lowdragmc/lowdraglib/utils/$BlockInfo"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$IO, $IO$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IO"
import {$SimplePredicate, $SimplePredicate$Type} from "packages/com/gregtechceu/gtceu/api/pattern/predicates/$SimplePredicate"

export class $TraceabilityPredicate {
 "common": $List<($SimplePredicate)>
 "limited": $List<($SimplePredicate)>
 "isController": boolean

constructor(simplePredicate: $SimplePredicate$Type)
constructor(predicate: $Predicate$Type<($MultiblockState$Type)>, candidates: $Supplier$Type<(($BlockInfo$Type)[])>)
constructor(predicate: $TraceabilityPredicate$Type)
constructor()

public "test"(blockWorldState: $MultiblockState$Type): boolean
public "setIO"(io: $IO$Type): $TraceabilityPredicate
public "sort"(): $TraceabilityPredicate
public "or"(other: $TraceabilityPredicate$Type): $TraceabilityPredicate
public "isAny"(): boolean
public "setController"(): $TraceabilityPredicate
public "isAir"(): boolean
public "isSingle"(): boolean
public "disableRenderFormed"(): $TraceabilityPredicate
public "setMaxGlobalLimited"(max: integer, previewCount: integer): $TraceabilityPredicate
public "setMaxGlobalLimited"(max: integer): $TraceabilityPredicate
public "setMinGlobalLimited"(min: integer, previewCount: integer): $TraceabilityPredicate
public "setMinGlobalLimited"(min: integer): $TraceabilityPredicate
public "addCache"(): boolean
public "setSlotName"(slotName: string): $TraceabilityPredicate
public "hasAir"(): boolean
public "setNBTParser"(nbtParser: string): $TraceabilityPredicate
public "setExactLimit"(limit: integer): $TraceabilityPredicate
public "addTooltips"(...tips: ($Component$Type)[]): $TraceabilityPredicate
public "setPreviewCount"(count: integer): $TraceabilityPredicate
public "setMaxLayerLimited"(max: integer): $TraceabilityPredicate
public "setMaxLayerLimited"(max: integer, previewCount: integer): $TraceabilityPredicate
public "setMinLayerLimited"(min: integer, previewCount: integer): $TraceabilityPredicate
public "setMinLayerLimited"(min: integer): $TraceabilityPredicate
set "iO"(value: $IO$Type)
get "any"(): boolean
get "air"(): boolean
get "single"(): boolean
set "maxGlobalLimited"(value: integer)
set "minGlobalLimited"(value: integer)
set "slotName"(value: string)
set "nBTParser"(value: string)
set "exactLimit"(value: integer)
set "previewCount"(value: integer)
set "maxLayerLimited"(value: integer)
set "minLayerLimited"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TraceabilityPredicate$Type = ($TraceabilityPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TraceabilityPredicate_ = $TraceabilityPredicate$Type;
}}
declare module "packages/com/gregtechceu/gtceu/core/mixins/$PrimedTntAccessor" {
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export interface $PrimedTntAccessor {

 "setOwner"(arg0: $LivingEntity$Type): void

(arg0: $LivingEntity$Type): void
}

export namespace $PrimedTntAccessor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PrimedTntAccessor$Type = ($PrimedTntAccessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PrimedTntAccessor_ = $PrimedTntAccessor$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType$ToolConstructor" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$IGTTool, $IGTTool$Type} from "packages/com/gregtechceu/gtceu/api/item/$IGTTool"
import {$IGTToolDefinition, $IGTToolDefinition$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$IGTToolDefinition"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$GTToolType, $GTToolType$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType"
import {$MaterialToolTier, $MaterialToolTier$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$MaterialToolTier"

export interface $GTToolType$ToolConstructor {

 "apply"(arg0: $GTToolType$Type, arg1: $MaterialToolTier$Type, arg2: $Material$Type, arg3: $IGTToolDefinition$Type, arg4: $Item$Properties$Type): $IGTTool

(arg0: $GTToolType$Type, arg1: $MaterialToolTier$Type, arg2: $Material$Type, arg3: $IGTToolDefinition$Type, arg4: $Item$Properties$Type): $IGTTool
}

export namespace $GTToolType$ToolConstructor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTToolType$ToolConstructor$Type = ($GTToolType$ToolConstructor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTToolType$ToolConstructor_ = $GTToolType$ToolConstructor$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$VeinedVeinGenerator" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$GTOreDefinition, $GTOreDefinition$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTOreDefinition"
import {$VeinedVeinGenerator$VeinBlockDefinition, $VeinedVeinGenerator$VeinBlockDefinition$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$VeinedVeinGenerator$VeinBlockDefinition"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$OreConfiguration$TargetBlockState, $OreConfiguration$TargetBlockState$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$OreConfiguration$TargetBlockState"
import {$VeinGenerator, $VeinGenerator$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/$VeinGenerator"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $VeinedVeinGenerator extends $VeinGenerator {
static readonly "BLOCK_ENTRY_CODEC": $Codec<($Either<($List<($OreConfiguration$TargetBlockState)>), ($Material)>)>
static readonly "CODEC": $Codec<($VeinedVeinGenerator)>
 "oreBlocks": $List<($VeinedVeinGenerator$VeinBlockDefinition)>
 "rareBlocks": $List<($VeinedVeinGenerator$VeinBlockDefinition)>
 "fillerBlock": $BlockState
 "minYLevel": integer
 "maxYLevel": integer
 "veininessThreshold": float
 "edgeRoundoffBegin": integer
 "maxEdgeRoundoff": double
 "minRichness": float
 "maxRichness": float
 "maxRichnessThreshold": float
 "rareBlockChance": float
static readonly "REGISTRY_CODEC": $Codec<($Codec<(any)>)>
static readonly "DIRECT_CODEC": $Codec<($VeinGenerator)>

constructor(entry: $GTOreDefinition$Type)
constructor(oreBlocks: $List$Type<($VeinedVeinGenerator$VeinBlockDefinition$Type)>, rareBlocks: $List$Type<($VeinedVeinGenerator$VeinBlockDefinition$Type)>, fillerBlock: $BlockState$Type, minYLevel: integer, maxYLevel: integer, veininessThreshold: float, edgeRoundoffBegin: integer, maxEdgeRoundoff: double, minRichness: float, maxRichness: float, maxRichnessThreshold: float, rareBlockChance: float)

public "copy"(): $VeinGenerator
public "codec"(): $Codec<(any)>
public "getAllEntries"(): $List<($Map$Entry<($Either<($BlockState), ($Material)>), (integer)>)>
public "oreBlock"(blockState: $BlockState$Type, weight: integer): $VeinedVeinGenerator
public "oreBlock"(block: $Material$Type, weight: integer): $VeinedVeinGenerator
public "oreBlock"(material: $VeinedVeinGenerator$VeinBlockDefinition$Type): $VeinedVeinGenerator
public "maxRichnessThreshold"(maxRichnessThreshold: float): $VeinedVeinGenerator
public "minYLevel"(minYLevel: integer): $VeinedVeinGenerator
public "maxYLevel"(maxYLevel: integer): $VeinedVeinGenerator
public "rareBlockChance"(rareBlockChance: float): $VeinedVeinGenerator
public "fillerBlock"(fillerBlock: $BlockState$Type): $VeinedVeinGenerator
public "veininessThreshold"(veininessThreshold: float): $VeinedVeinGenerator
public "minRichness"(minRichness: float): $VeinedVeinGenerator
public "maxRichness"(maxRichness: float): $VeinedVeinGenerator
public "edgeRoundoffBegin"(edgeRoundoffBegin: integer): $VeinedVeinGenerator
public "maxEdgeRoundoff"(maxEdgeRoundoff: double): $VeinedVeinGenerator
public "rareBlock"(blockState: $BlockState$Type, weight: integer): $VeinedVeinGenerator
public "rareBlock"(block: $Material$Type, weight: integer): $VeinedVeinGenerator
public "rareBlock"(material: $VeinedVeinGenerator$VeinBlockDefinition$Type): $VeinedVeinGenerator
get "allEntries"(): $List<($Map$Entry<($Either<($BlockState), ($Material)>), (integer)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VeinedVeinGenerator$Type = ($VeinedVeinGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VeinedVeinGenerator_ = $VeinedVeinGenerator$Type;
}}
declare module "packages/com/gregtechceu/gtceu/core/mixins/$BlockBehaviourAccessor" {
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $BlockBehaviourAccessor {

 "setDrops"(arg0: $ResourceLocation$Type): void
 "getBlockProperties"(): $BlockBehaviour$Properties
}

export namespace $BlockBehaviourAccessor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBehaviourAccessor$Type = ($BlockBehaviourAccessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockBehaviourAccessor_ = $BlockBehaviourAccessor$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/gui/fancy/$FancyMachineUIWidget" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IConfigurableWidget, $IConfigurableWidget$Type} from "packages/com/lowdragmc/lowdraglib/gui/editor/configurator/$IConfigurableWidget"
import {$PageSwitcher, $PageSwitcher$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$PageSwitcher"
import {$WidgetGroup, $WidgetGroup$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$WidgetGroup"
import {$Widget, $Widget$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$Widget"
import {$Deque, $Deque$Type} from "packages/java/util/$Deque"
import {$TitleBarWidget, $TitleBarWidget$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$TitleBarWidget"
import {$IFancyUIProvider, $IFancyUIProvider$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$IFancyUIProvider"
import {$ConfiguratorPanel, $ConfiguratorPanel$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$ConfiguratorPanel"
import {$Resources, $Resources$Type} from "packages/com/lowdragmc/lowdraglib/gui/editor/data/$Resources"
import {$PlayerInventoryWidget, $PlayerInventoryWidget$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/custom/$PlayerInventoryWidget"
import {$VerticalTabsWidget, $VerticalTabsWidget$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$VerticalTabsWidget"
import {$List, $List$Type} from "packages/java/util/$List"
import {$FancyMachineUIWidget$NavigationEntry, $FancyMachineUIWidget$NavigationEntry$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$FancyMachineUIWidget$NavigationEntry"
import {$TooltipsPanel, $TooltipsPanel$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$TooltipsPanel"

export class $FancyMachineUIWidget extends $WidgetGroup {
readonly "widgets": $List<($Widget)>

constructor(mainPage: $IFancyUIProvider$Type, width: integer, height: integer)

public "setBorder"(border: integer): void
public "getPlayerInventory"(): $PlayerInventoryWidget
public "getCurrentPage"(): $IFancyUIProvider
public "initWidget"(): void
public "getConfiguratorPanel"(): $ConfiguratorPanel
public "getSideTabsWidget"(): $VerticalTabsWidget
public "getTitleBar"(): $TitleBarWidget
public "getBorder"(): integer
public "getMainPage"(): $IFancyUIProvider
public "getTooltipsPanel"(): $TooltipsPanel
public "getPageSwitcher"(): $PageSwitcher
public "getPageContainer"(): $WidgetGroup
public "getPreviousPages"(): $Deque<($FancyMachineUIWidget$NavigationEntry)>
public "getAllPages"(): $List<($IFancyUIProvider)>
public "getCurrentHomePage"(): $IFancyUIProvider
public static "deserializeNBT"(widget: $IConfigurableWidget$Type, tag: $CompoundTag$Type, resources: $Resources$Type, isProject: boolean): void
public static "serializeNBT"(widget: $IConfigurableWidget$Type, resources: $Resources$Type, isProject: boolean): $CompoundTag
public static "deserializeWrapper"(tag: $CompoundTag$Type): $IConfigurableWidget
set "border"(value: integer)
get "playerInventory"(): $PlayerInventoryWidget
get "currentPage"(): $IFancyUIProvider
get "configuratorPanel"(): $ConfiguratorPanel
get "sideTabsWidget"(): $VerticalTabsWidget
get "titleBar"(): $TitleBarWidget
get "border"(): integer
get "mainPage"(): $IFancyUIProvider
get "tooltipsPanel"(): $TooltipsPanel
get "pageSwitcher"(): $PageSwitcher
get "pageContainer"(): $WidgetGroup
get "previousPages"(): $Deque<($FancyMachineUIWidget$NavigationEntry)>
get "allPages"(): $List<($IFancyUIProvider)>
get "currentHomePage"(): $IFancyUIProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FancyMachineUIWidget$Type = ($FancyMachineUIWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FancyMachineUIWidget_ = $FancyMachineUIWidget$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/cover/$RobotArmCover" {
import {$ManagedFieldHolder, $ManagedFieldHolder$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/field/$ManagedFieldHolder"
import {$ICoverable, $ICoverable$Type} from "packages/com/gregtechceu/gtceu/api/capability/$ICoverable"
import {$ConveyorCover, $ConveyorCover$Type} from "packages/com/gregtechceu/gtceu/common/cover/$ConveyorCover"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CoverDefinition, $CoverDefinition$Type} from "packages/com/gregtechceu/gtceu/api/cover/$CoverDefinition"
import {$TransferMode, $TransferMode$Type} from "packages/com/gregtechceu/gtceu/common/cover/data/$TransferMode"

export class $RobotArmCover extends $ConveyorCover {
static readonly "MANAGED_FIELD_HOLDER": $ManagedFieldHolder
readonly "tier": integer
readonly "maxItemTransferRate": integer
readonly "coverDefinition": $CoverDefinition
readonly "coverHolder": $ICoverable
readonly "attachedSide": $Direction

constructor(definition: $CoverDefinition$Type, coverHolder: $ICoverable$Type, attachedSide: $Direction$Type, tier: integer)

public "buffer"(amount: integer): void
public "getBuffer"(): integer
public "clearBuffer"(): void
public "getTransferMode"(): $TransferMode
public "getFieldHolder"(): $ManagedFieldHolder
public "getGlobalTransferLimit"(): integer
get "transferMode"(): $TransferMode
get "fieldHolder"(): $ManagedFieldHolder
get "globalTransferLimit"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RobotArmCover$Type = ($RobotArmCover);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RobotArmCover_ = $RobotArmCover$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/blockentity/$DuctPipeBlockEntity" {
import {$DuctNetHandler, $DuctNetHandler$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/duct/$DuctNetHandler"
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$DuctPipeNet, $DuctPipeNet$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/duct/$DuctPipeNet"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$PipeBlockEntity, $PipeBlockEntity$Type} from "packages/com/gregtechceu/gtceu/api/blockentity/$PipeBlockEntity"
import {$IHazardParticleContainer, $IHazardParticleContainer$Type} from "packages/com/gregtechceu/gtceu/api/capability/$IHazardParticleContainer"
import {$AttachmentTarget, $AttachmentTarget$Type} from "packages/net/fabricmc/fabric/api/attachment/v1/$AttachmentTarget"
import {$DuctPipeProperties, $DuctPipeProperties$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/duct/$DuctPipeProperties"
import {$ManagedFieldHolder, $ManagedFieldHolder$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/field/$ManagedFieldHolder"
import {$DuctPipeType, $DuctPipeType$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/duct/$DuctPipeType"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$EnumMap, $EnumMap$Type} from "packages/java/util/$EnumMap"

export class $DuctPipeBlockEntity extends $PipeBlockEntity<($DuctPipeType), ($DuctPipeProperties)> {
readonly "clientCapability": $IHazardParticleContainer
static readonly "MANAGED_FIELD_HOLDER": $ManagedFieldHolder
 "level": $Level
 "worldPosition": $BlockPos
 "remove": boolean
 "hasComparators": byte


public static "create"(type: $BlockEntityType$Type<(any)>, pos: $BlockPos$Type, blockState: $BlockState$Type): $DuctPipeBlockEntity
public "getHandlers"(): $EnumMap<($Direction), ($DuctNetHandler)>
public "getCapability"<T>(cap: $Capability$Type<(T)>, side: $Direction$Type): $LazyOptional<(T)>
public "getDefaultHandler"(): $DuctNetHandler
public static "onBlockEntityRegister"(ductBlockEntityBlockEntityType: $BlockEntityType$Type<($DuctPipeBlockEntity$Type)>): void
public "canAttachTo"(side: $Direction$Type): boolean
public "canHaveBlockedFaces"(): boolean
public "checkNetwork"(): void
public "initHandlers"(): void
public "getDuctPipeNet"(): $DuctPipeNet
public static "transfer"(original: $AttachmentTarget$Type, target: $AttachmentTarget$Type, isDeath: boolean): void
get "handlers"(): $EnumMap<($Direction), ($DuctNetHandler)>
get "defaultHandler"(): $DuctNetHandler
get "ductPipeNet"(): $DuctPipeNet
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DuctPipeBlockEntity$Type = ($DuctPipeBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DuctPipeBlockEntity_ = $DuctPipeBlockEntity$Type;
}}
declare module "packages/com/gregtechceu/gtceu/client/model/$PipeModel" {
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ItemDisplayContext, $ItemDisplayContext$Type} from "packages/net/minecraft/world/item/$ItemDisplayContext"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$List, $List$Type} from "packages/java/util/$List"
import {$SupplierMemoizer$MemoizedSupplier, $SupplierMemoizer$MemoizedSupplier$Type} from "packages/com/gregtechceu/gtceu/utils/$SupplierMemoizer$MemoizedSupplier"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"
import {$BakedQuad, $BakedQuad$Type} from "packages/net/minecraft/client/renderer/block/model/$BakedQuad"

export class $PipeModel {
static readonly "PIPE_BLOCKED_OVERLAY": $ResourceLocation
static readonly "PIPE_BLOCKED_OVERLAY_UP": $ResourceLocation
static readonly "PIPE_BLOCKED_OVERLAY_DOWN": $ResourceLocation
static readonly "PIPE_BLOCKED_OVERLAY_LEFT": $ResourceLocation
static readonly "PIPE_BLOCKED_OVERLAY_RIGHT": $ResourceLocation
static readonly "PIPE_BLOCKED_OVERLAY_NU": $ResourceLocation
static readonly "PIPE_BLOCKED_OVERLAY_ND": $ResourceLocation
static readonly "PIPE_BLOCKED_OVERLAY_NL": $ResourceLocation
static readonly "PIPE_BLOCKED_OVERLAY_NR": $ResourceLocation
static readonly "PIPE_BLOCKED_OVERLAY_UD": $ResourceLocation
static readonly "PIPE_BLOCKED_OVERLAY_UL": $ResourceLocation
static readonly "PIPE_BLOCKED_OVERLAY_UR": $ResourceLocation
static readonly "PIPE_BLOCKED_OVERLAY_DL": $ResourceLocation
static readonly "PIPE_BLOCKED_OVERLAY_DR": $ResourceLocation
static readonly "PIPE_BLOCKED_OVERLAY_LR": $ResourceLocation
static readonly "ITEM_CONNECTIONS": integer
readonly "thickness": float
readonly "coreCube": $AABB
readonly "sideCubes": $Map<($Direction), ($AABB)>
 "sideTexture": $SupplierMemoizer$MemoizedSupplier<($ResourceLocation)>
 "endTexture": $SupplierMemoizer$MemoizedSupplier<($ResourceLocation)>
 "secondarySideTexture": $SupplierMemoizer$MemoizedSupplier<($ResourceLocation)>
 "secondaryEndTexture": $SupplierMemoizer$MemoizedSupplier<($ResourceLocation)>
 "sideOverlayTexture": $ResourceLocation
 "endOverlayTexture": $ResourceLocation

constructor(thickness: float, sideTexture: $Supplier$Type<($ResourceLocation$Type)>, endTexture: $Supplier$Type<($ResourceLocation$Type)>, secondarySideTexture: $Supplier$Type<($ResourceLocation$Type)>, secondaryEndTexture: $Supplier$Type<($ResourceLocation$Type)>)

public "getParticleTexture"(): $TextureAtlasSprite
public "renderItem"(stack: $ItemStack$Type, transformType: $ItemDisplayContext$Type, leftHand: boolean, matrixStack: $PoseStack$Type, buffer: $MultiBufferSource$Type, combinedLight: integer, combinedOverlay: integer, model: $BakedModel$Type): void
public "bakeQuads"(side: $Direction$Type, connections: integer, blockedConnections: integer): $List<($BakedQuad)>
public "getShapes"(connections: integer): $VoxelShape
public "setSideOverlayTexture"(sideOverlayTexture: $ResourceLocation$Type): void
public "setEndOverlayTexture"(endOverlayTexture: $ResourceLocation$Type): void
public "registerTextureAtlas"(register: $Consumer$Type<($ResourceLocation$Type)>): void
public static "initializeRestrictor"(atlas: $Function$Type<($ResourceLocation$Type), ($TextureAtlasSprite$Type)>): void
get "particleTexture"(): $TextureAtlasSprite
set "sideOverlayTexture"(value: $ResourceLocation$Type)
set "endOverlayTexture"(value: $ResourceLocation$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PipeModel$Type = ($PipeModel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PipeModel_ = $PipeModel$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/multiblock/$PartAbility" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $PartAbility {
static readonly "EXPORT_ITEMS": $PartAbility
static readonly "IMPORT_ITEMS": $PartAbility
static readonly "EXPORT_FLUIDS": $PartAbility
static readonly "IMPORT_FLUIDS": $PartAbility
static readonly "EXPORT_FLUIDS_1X": $PartAbility
static readonly "IMPORT_FLUIDS_1X": $PartAbility
static readonly "EXPORT_FLUIDS_4X": $PartAbility
static readonly "IMPORT_FLUIDS_4X": $PartAbility
static readonly "EXPORT_FLUIDS_9X": $PartAbility
static readonly "IMPORT_FLUIDS_9X": $PartAbility
static readonly "INPUT_ENERGY": $PartAbility
static readonly "OUTPUT_ENERGY": $PartAbility
static readonly "SUBSTATION_INPUT_ENERGY": $PartAbility
static readonly "SUBSTATION_OUTPUT_ENERGY": $PartAbility
static readonly "INPUT_KINETIC": $PartAbility
static readonly "OUTPUT_KINETIC": $PartAbility
static readonly "ROTOR_HOLDER": $PartAbility
static readonly "PUMP_FLUID_HATCH": $PartAbility
static readonly "STEAM": $PartAbility
static readonly "STEAM_IMPORT_ITEMS": $PartAbility
static readonly "STEAM_EXPORT_ITEMS": $PartAbility
static readonly "MAINTENANCE": $PartAbility
static readonly "MUFFLER": $PartAbility
static readonly "TANK_VALVE": $PartAbility
static readonly "PASSTHROUGH_HATCH": $PartAbility
static readonly "PARALLEL_HATCH": $PartAbility
static readonly "INPUT_LASER": $PartAbility
static readonly "OUTPUT_LASER": $PartAbility
static readonly "COMPUTATION_DATA_RECEPTION": $PartAbility
static readonly "COMPUTATION_DATA_TRANSMISSION": $PartAbility
static readonly "OPTICAL_DATA_RECEPTION": $PartAbility
static readonly "OPTICAL_DATA_TRANSMISSION": $PartAbility
static readonly "DATA_ACCESS": $PartAbility
static readonly "HPCA_COMPONENT": $PartAbility
static readonly "OBJECT_HOLDER": $PartAbility

constructor(name: string)

public "getName"(): string
public "register"(tier: integer, block: $Block$Type): void
public "getBlocks"(...tiers: (integer)[]): $Collection<($Block)>
public "isApplicable"(block: $Block$Type): boolean
public "getAllBlocks"(): $Collection<($Block)>
public "getBlockRange"(from: integer, to: integer): $Collection<($Block)>
get "name"(): string
get "allBlocks"(): $Collection<($Block)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PartAbility$Type = ($PartAbility);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PartAbility_ = $PartAbility$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/ui/$GTRecipeTypeUI$RecipeHolder" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Table, $Table$Type} from "packages/com/google/common/collect/$Table"
import {$RecipeCondition, $RecipeCondition$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$RecipeCondition"
import {$List, $List$Type} from "packages/java/util/$List"
import {$DoubleSupplier, $DoubleSupplier$Type} from "packages/java/util/function/$DoubleSupplier"
import {$RecipeCapability, $RecipeCapability$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$RecipeCapability"
import {$IO, $IO$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IO"

export class $GTRecipeTypeUI$RecipeHolder extends $Record {

constructor(progressSupplier: $DoubleSupplier$Type, storages: $Table$Type<($IO$Type), ($RecipeCapability$Type<(any)>), (any)>, data: $CompoundTag$Type, conditions: $List$Type<($RecipeCondition$Type)>, isSteam: boolean, isHighPressure: boolean)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "data"(): $CompoundTag
public "conditions"(): $List<($RecipeCondition)>
public "storages"(): $Table<($IO), ($RecipeCapability<(any)>), (any)>
public "progressSupplier"(): $DoubleSupplier
public "isHighPressure"(): boolean
public "isSteam"(): boolean
get "highPressure"(): boolean
get "steam"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTRecipeTypeUI$RecipeHolder$Type = ($GTRecipeTypeUI$RecipeHolder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTRecipeTypeUI$RecipeHolder_ = $GTRecipeTypeUI$RecipeHolder$Type;
}}
declare module "packages/com/gregtechceu/gtceu/core/mixins/$ServerGamePacketListenerImplAccessor" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $ServerGamePacketListenerImplAccessor {

 "setAboveGroundTickCount"(arg0: integer): void

(arg0: integer): void
}

export namespace $ServerGamePacketListenerImplAccessor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerGamePacketListenerImplAccessor$Type = ($ServerGamePacketListenerImplAccessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerGamePacketListenerImplAccessor_ = $ServerGamePacketListenerImplAccessor$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/content/$Content" {
import {$ContentModifier, $ContentModifier$Type} from "packages/com/gregtechceu/gtceu/api/recipe/content/$ContentModifier"
import {$RecipeCapability, $RecipeCapability$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$RecipeCapability"
import {$IGuiTexture, $IGuiTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$IGuiTexture"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $Content {
 "content": any
 "chance": float
 "tierChanceBoost": float
 "slotName": string
 "uiName": string

constructor(content: any, chance: float, tierChanceBoost: float, slotName: string, uiName: string)

public "copy"(capability: $RecipeCapability$Type<(any)>, modifier: $ContentModifier$Type): $Content
public "getContent"(): any
public "createOverlay"(perTick: boolean): $IGuiTexture
public "drawChance"(graphics: $GuiGraphics$Type, x: float, y: float, width: integer, height: integer): void
public "drawTick"(graphics: $GuiGraphics$Type, x: float, y: float, width: integer, height: integer): void
public "drawEmiAmount"(graphics: $GuiGraphics$Type, x: float, y: float, width: integer, height: integer): void
get "content"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Content$Type = ($Content);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Content_ = $Content$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/$StrictShapedRecipe$Serializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$StrictShapedRecipe, $StrictShapedRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$StrictShapedRecipe"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $StrictShapedRecipe$Serializer implements $RecipeSerializer<($StrictShapedRecipe)> {

constructor()

public "fromJson"(recipeId: $ResourceLocation$Type, json: $JsonObject$Type): $StrictShapedRecipe
public "fromNetwork"(recipeId: $ResourceLocation$Type, buffer: $FriendlyByteBuf$Type): $StrictShapedRecipe
public "toNetwork"(buffer: $FriendlyByteBuf$Type, recipe: $StrictShapedRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $StrictShapedRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StrictShapedRecipe$Serializer$Type = ($StrictShapedRecipe$Serializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StrictShapedRecipe$Serializer_ = $StrictShapedRecipe$Serializer$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/fluids/forge/$GTFluidImpl$Source" {
import {$IntegerProperty, $IntegerProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$IntegerProperty"
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$GTFluidImpl, $GTFluidImpl$Type} from "packages/com/gregtechceu/gtceu/api/fluids/forge/$GTFluidImpl"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$FluidType, $FluidType$Type} from "packages/net/minecraftforge/fluids/$FluidType"
import {$FluidState as $FluidState$0, $FluidState$Type as $FluidState$0$Type} from "packages/com/gregtechceu/gtceu/api/fluids/$FluidState"

export class $GTFluidImpl$Source extends $GTFluidImpl {
static readonly "FALLING": $BooleanProperty
static readonly "LEVEL": $IntegerProperty
static readonly "FLUID_STATE_REGISTRY": $IdMapper<($FluidState)>
readonly "stateDefinition": $StateDefinition<($Fluid), ($FluidState)>

constructor(state: $FluidState$0$Type, stillFluid: $Supplier$Type<(any)>, flowingFluid: $Supplier$Type<(any)>, block: $Supplier$Type<(any)>, bucket: $Supplier$Type<(any)>, burnTime: integer, fluidType: $Supplier$Type<($FluidType$Type)>)

public "isSource"(state: $FluidState$Type): boolean
public "getAmount"(state: $FluidState$Type): integer
public "canConvertToSource"(arg0: $FluidState$Type, arg1: $Level$Type, arg2: $BlockPos$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTFluidImpl$Source$Type = ($GTFluidImpl$Source);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTFluidImpl$Source_ = $GTFluidImpl$Source$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pattern/$BlockPattern" {
import {$MultiblockState, $MultiblockState$Type} from "packages/com/gregtechceu/gtceu/api/pattern/$MultiblockState"
import {$BlockInfo, $BlockInfo$Type} from "packages/com/lowdragmc/lowdraglib/utils/$BlockInfo"
import {$RelativeDirection, $RelativeDirection$Type} from "packages/com/gregtechceu/gtceu/api/pattern/util/$RelativeDirection"
import {$TraceabilityPredicate, $TraceabilityPredicate$Type} from "packages/com/gregtechceu/gtceu/api/pattern/$TraceabilityPredicate"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockPattern {
readonly "aisleRepetitions": ((integer)[])[]
readonly "structureDir": ($RelativeDirection)[]

constructor(predicatesIn: ((($TraceabilityPredicate$Type)[])[])[], structureDir: ($RelativeDirection$Type)[], aisleRepetitions: ((integer)[])[], centerOffset: (integer)[])

public "autoBuild"(player: $Player$Type, worldState: $MultiblockState$Type): void
public "checkPatternAt"(worldState: $MultiblockState$Type, centerPos: $BlockPos$Type, frontFacing: $Direction$Type, upwardsFacing: $Direction$Type, isFlipped: boolean, savePredicate: boolean): boolean
public "checkPatternAt"(worldState: $MultiblockState$Type, savePredicate: boolean): boolean
public "getPreview"(repetition: (integer)[]): ((($BlockInfo)[])[])[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPattern$Type = ($BlockPattern);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockPattern_ = $BlockPattern$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pipenet/$IAttachData" {
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"

export interface $IAttachData {

 "setAttached"(arg0: $Direction$Type, arg1: boolean): boolean
 "canAttachTo"(arg0: $Direction$Type): boolean
}

export namespace $IAttachData {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IAttachData$Type = ($IAttachData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IAttachData_ = $IAttachData$Type;
}}
declare module "packages/com/gregtechceu/gtceu/integration/kjs/recipe/$GTRecipeSchema$GTRecipeJS" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$CleanroomType, $CleanroomType$Type} from "packages/com/gregtechceu/gtceu/api/machine/multiblock/$CleanroomType"
import {$ResearchRecipeBuilder$StationRecipeBuilder, $ResearchRecipeBuilder$StationRecipeBuilder$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$ResearchRecipeBuilder$StationRecipeBuilder"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$MedicalCondition, $MedicalCondition$Type} from "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$MedicalCondition"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$ResearchRecipeBuilder$ScannerRecipeBuilder, $ResearchRecipeBuilder$ScannerRecipeBuilder$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$ResearchRecipeBuilder$ScannerRecipeBuilder"
import {$MachineDefinition, $MachineDefinition$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MachineDefinition"
import {$InputFluid, $InputFluid$Type} from "packages/dev/latvian/mods/kubejs/fluid/$InputFluid"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$InputItem, $InputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$InputItem"
import {$RecipeCondition, $RecipeCondition$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$RecipeCondition"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$FluidStackJS, $FluidStackJS$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FluidStackJS"
import {$OutputItem, $OutputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$OutputItem"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$ModifyRecipeResultCallback, $ModifyRecipeResultCallback$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ModifyRecipeResultCallback"
import {$Tag, $Tag$Type} from "packages/net/minecraft/nbt/$Tag"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$GTRecipeComponents$FluidIngredientJS, $GTRecipeComponents$FluidIngredientJS$Type} from "packages/com/gregtechceu/gtceu/integration/kjs/recipe/components/$GTRecipeComponents$FluidIngredientJS"
import {$GTRecipeBuilder$ResearchRecipeEntry, $GTRecipeBuilder$ResearchRecipeEntry$Type} from "packages/com/gregtechceu/gtceu/data/recipe/builder/$GTRecipeBuilder$ResearchRecipeEntry"
import {$RecipeCapability, $RecipeCapability$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$RecipeCapability"
import {$RecipeTypeFunction, $RecipeTypeFunction$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeTypeFunction"
import {$TagPrefix, $TagPrefix$Type} from "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$UnificationEntry, $UnificationEntry$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/stack/$UnificationEntry"

export class $GTRecipeSchema$GTRecipeJS extends $RecipeJS {
 "perTick": boolean
 "chance": float
 "tierChanceBoost": float
 "isFuel": boolean
 "onSave": $Consumer<($GTRecipeSchema$GTRecipeJS)>
static "itemErrors": boolean
 "id": $ResourceLocation
 "type": $RecipeTypeFunction
 "newRecipe": boolean
 "removed": boolean
 "modifyResult": $ModifyRecipeResultCallback
 "originalJson": $JsonObject
 "json": $JsonObject
 "changed": boolean

constructor()

public "input"<T>(capability: $RecipeCapability$Type<(T)>, ...obj: (any)[]): $GTRecipeSchema$GTRecipeJS
public "output"<T>(capability: $RecipeCapability$Type<(T)>, ...obj: (any)[]): $GTRecipeSchema$GTRecipeJS
public "dimension"(dimension: $ResourceLocation$Type): $GTRecipeSchema$GTRecipeJS
public "dimension"(dimension: $ResourceLocation$Type, reverse: boolean): $GTRecipeSchema$GTRecipeJS
public "posY"(min: integer, max: integer): $GTRecipeSchema$GTRecipeJS
public "posY"(min: integer, max: integer, reverse: boolean): $GTRecipeSchema$GTRecipeJS
public "onSave"(onSave: $Consumer$Type<($GTRecipeSchema$GTRecipeJS$Type)>): $GTRecipeSchema$GTRecipeJS
public "chance"(chance: float): $GTRecipeSchema$GTRecipeJS
public "isFuel"(isFuel: boolean): $GTRecipeSchema$GTRecipeJS
public "biome"(biome: $ResourceLocation$Type): $GTRecipeSchema$GTRecipeJS
public "biome"(biome: $ResourceLocation$Type, reverse: boolean): $GTRecipeSchema$GTRecipeJS
public "thunder"(level: float): $GTRecipeSchema$GTRecipeJS
public "thunder"(level: float, reverse: boolean): $GTRecipeSchema$GTRecipeJS
public "rpm"(rpm: float, reverse: boolean): $GTRecipeSchema$GTRecipeJS
public "rpm"(rpm: float): $GTRecipeSchema$GTRecipeJS
public "researchRecipeEntries"(): $Collection<($GTRecipeBuilder$ResearchRecipeEntry)>
public "inputItems"(input: $Item$Type, amount: integer): $GTRecipeSchema$GTRecipeJS
public "inputItems"(machine: $MachineDefinition$Type): $GTRecipeSchema$GTRecipeJS
public "inputItems"(machine: $MachineDefinition$Type, count: integer): $GTRecipeSchema$GTRecipeJS
public "inputItems"(...inputs: ($InputItem$Type)[]): $GTRecipeSchema$GTRecipeJS
public "inputItems"(...inputs: ($ItemStack$Type)[]): $GTRecipeSchema$GTRecipeJS
public "inputItems"(tag: $TagKey$Type<($Item$Type)>, amount: integer): $GTRecipeSchema$GTRecipeJS
public "inputItems"(input: $UnificationEntry$Type): $GTRecipeSchema$GTRecipeJS
public "inputItems"(input: $Supplier$Type<(any)>): $GTRecipeSchema$GTRecipeJS
public "inputItems"(input: $Supplier$Type<(any)>, amount: integer): $GTRecipeSchema$GTRecipeJS
public "inputItems"(orePrefix: $TagPrefix$Type, material: $Material$Type): $GTRecipeSchema$GTRecipeJS
public "inputItems"(orePrefix: $TagPrefix$Type, material: $Material$Type, count: integer): $GTRecipeSchema$GTRecipeJS
public "inputItems"(input: $UnificationEntry$Type, count: integer): $GTRecipeSchema$GTRecipeJS
public "inputItems"(input: $Item$Type): $GTRecipeSchema$GTRecipeJS
public "outputItems"(machine: $MachineDefinition$Type, count: integer): $GTRecipeSchema$GTRecipeJS
public "outputItems"(machine: $MachineDefinition$Type): $GTRecipeSchema$GTRecipeJS
public "outputItems"(orePrefix: $TagPrefix$Type, material: $Material$Type, count: integer): $GTRecipeSchema$GTRecipeJS
public "outputItems"(...outputs: ($OutputItem$Type)[]): $GTRecipeSchema$GTRecipeJS
public "outputItems"(input: $Item$Type, amount: integer): $GTRecipeSchema$GTRecipeJS
public "outputItems"(orePrefix: $TagPrefix$Type, material: $Material$Type): $GTRecipeSchema$GTRecipeJS
public "outputItems"(input: $Item$Type): $GTRecipeSchema$GTRecipeJS
public "perTick"(perTick: boolean): $GTRecipeSchema$GTRecipeJS
public "circuit"(configuration: integer): $GTRecipeSchema$GTRecipeJS
public "rain"(level: float, reverse: boolean): $GTRecipeSchema$GTRecipeJS
public "rain"(level: float): $GTRecipeSchema$GTRecipeJS
public "itemOutputs"(...outputs: ($OutputItem$Type)[]): $GTRecipeSchema$GTRecipeJS
public "outputFluids"(...outputs: ($FluidStackJS$Type)[]): $GTRecipeSchema$GTRecipeJS
public "addData"(key: string, data: $Tag$Type): $GTRecipeSchema$GTRecipeJS
public "addData"(key: string, data: integer): $GTRecipeSchema$GTRecipeJS
public "addData"(key: string, data: long): $GTRecipeSchema$GTRecipeJS
public "addData"(key: string, data: string): $GTRecipeSchema$GTRecipeJS
public "addData"(key: string, data: float): $GTRecipeSchema$GTRecipeJS
public "addData"(key: string, data: boolean): $GTRecipeSchema$GTRecipeJS
public "idWithoutType"(): $ResourceLocation
public "environmentalHazard"(condition: $MedicalCondition$Type): $GTRecipeSchema$GTRecipeJS
public "environmentalHazard"(condition: $MedicalCondition$Type, reverse: boolean): $GTRecipeSchema$GTRecipeJS
public "disableDistilleryRecipes"(flag: boolean): $GTRecipeSchema$GTRecipeJS
public "researchWithoutRecipe"(researchId: string, dataStack: $ItemStack$Type): $GTRecipeSchema$GTRecipeJS
public "researchWithoutRecipe"(researchId: string): $GTRecipeSchema$GTRecipeJS
public "createRecipe"(): $Recipe<(any)>
public "writeInputFluid"(value: $InputFluid$Type): $JsonElement
public "readInputFluid"(from: any): $InputFluid
public "writeInputItem"(value: $InputItem$Type): $JsonElement
public "readInputItem"(from: any): $InputItem
public "readOutputItem"(from: any): $OutputItem
public "writeOutputItem"(value: $OutputItem$Type): $JsonElement
public "inputStress"(stress: float): $GTRecipeSchema$GTRecipeJS
public "outputStress"(stress: float): $GTRecipeSchema$GTRecipeJS
public "chancedFluidInput"(stack: $GTRecipeComponents$FluidIngredientJS$Type, chance: integer, tierChanceBoost: integer): $GTRecipeSchema$GTRecipeJS
public "chancedInput"(stack: $InputItem$Type, chance: integer, tierChanceBoost: integer): $GTRecipeSchema$GTRecipeJS
public "chancedOutput"(tag: $TagPrefix$Type, mat: $Material$Type, chance: integer, tierChanceBoost: integer): $GTRecipeSchema$GTRecipeJS
public "chancedOutput"(tag: $TagPrefix$Type, mat: $Material$Type, count: integer, chance: integer, tierChanceBoost: integer): $GTRecipeSchema$GTRecipeJS
public "chancedOutput"(stack: $OutputItem$Type, chance: integer, tierChanceBoost: integer): $GTRecipeSchema$GTRecipeJS
public "inputFluids"(...inputs: ($GTRecipeComponents$FluidIngredientJS$Type)[]): $GTRecipeSchema$GTRecipeJS
public "chancedFluidOutput"(stack: $FluidStackJS$Type, chance: integer, tierChanceBoost: integer): $GTRecipeSchema$GTRecipeJS
public "solderMultiplier"(multiplier: integer): $GTRecipeSchema$GTRecipeJS
public "fusionStartEU"(eu: long): $GTRecipeSchema$GTRecipeJS
public "explosivesAmount"(explosivesAmount: integer): $GTRecipeSchema$GTRecipeJS
public "cleanroom"(cleanroomType: $CleanroomType$Type): $GTRecipeSchema$GTRecipeJS
public "explosivesType"(explosivesType: $ItemStack$Type): $GTRecipeSchema$GTRecipeJS
public "blastFurnaceTemp"(blastTemp: integer): $GTRecipeSchema$GTRecipeJS
public "researchScan"(isScan: boolean): $GTRecipeSchema$GTRecipeJS
public "scannerResearch"(research: $UnaryOperator$Type<($ResearchRecipeBuilder$ScannerRecipeBuilder$Type)>): $GTRecipeSchema$GTRecipeJS
public "scannerResearch"(researchStack: $ItemStack$Type): $GTRecipeSchema$GTRecipeJS
public "stationResearch"(research: $UnaryOperator$Type<($ResearchRecipeBuilder$StationRecipeBuilder$Type)>): $GTRecipeSchema$GTRecipeJS
public "notConsumableFluid"(fluid: $GTRecipeComponents$FluidIngredientJS$Type): $GTRecipeSchema$GTRecipeJS
public "tierChanceBoost"(tierChanceBoost: float): $GTRecipeSchema$GTRecipeJS
public "addCondition"(condition: $RecipeCondition$Type): $GTRecipeSchema$GTRecipeJS
public "itemInputs"(...inputs: ($InputItem$Type)[]): $GTRecipeSchema$GTRecipeJS
public "itemOutput"(unificationEntry: $UnificationEntry$Type): $GTRecipeSchema$GTRecipeJS
public "itemOutput"(unificationEntry: $UnificationEntry$Type, count: integer): $GTRecipeSchema$GTRecipeJS
public "itemInput"(input: $UnificationEntry$Type): $GTRecipeSchema$GTRecipeJS
public "itemInput"(input: $UnificationEntry$Type, count: integer): $GTRecipeSchema$GTRecipeJS
public "durationIsTotalCWU"(durationIsTotalCWU: boolean): $GTRecipeSchema$GTRecipeJS
public "inputEU"(eu: long): $GTRecipeSchema$GTRecipeJS
public "CWUt"(cwu: integer): $GTRecipeSchema$GTRecipeJS
public "inputCWU"(cwu: integer): $GTRecipeSchema$GTRecipeJS
public "outputEU"(eu: long): $GTRecipeSchema$GTRecipeJS
public "outputCWU"(cwu: integer): $GTRecipeSchema$GTRecipeJS
public "hideDuration"(hideDuration: boolean): $GTRecipeSchema$GTRecipeJS
public "EUt"(eu: long): $GTRecipeSchema$GTRecipeJS
public "totalCWU"(cwu: integer): $GTRecipeSchema$GTRecipeJS
public "notConsumable"(item: $Supplier$Type<(any)>): $GTRecipeSchema$GTRecipeJS
public "notConsumable"(orePrefix: $TagPrefix$Type, material: $Material$Type): $GTRecipeSchema$GTRecipeJS
public "notConsumable"(itemStack: $InputItem$Type): $GTRecipeSchema$GTRecipeJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTRecipeSchema$GTRecipeJS$Type = ($GTRecipeSchema$GTRecipeJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTRecipeSchema$GTRecipeJS_ = $GTRecipeSchema$GTRecipeJS$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/tool/$IToolGridHighLight" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$GTToolType, $GTToolType$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ResourceTexture, $ResourceTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$ResourceTexture"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $IToolGridHighLight {

 "shouldRenderGrid"(player: $Player$Type, held: $ItemStack$Type, toolTypes: $Set$Type<($GTToolType$Type)>): boolean
 "sideTips"(player: $Player$Type, toolTypes: $Set$Type<($GTToolType$Type)>, side: $Direction$Type): $ResourceTexture
}

export namespace $IToolGridHighLight {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IToolGridHighLight$Type = ($IToolGridHighLight);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IToolGridHighLight_ = $IToolGridHighLight$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/feature/$IMachineFeature" {
import {$MetaMachine, $MetaMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MetaMachine"

export interface $IMachineFeature {

 "self"(): $MetaMachine
}

export namespace $IMachineFeature {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMachineFeature$Type = ($IMachineFeature);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMachineFeature_ = $IMachineFeature$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/$VeinGenerator" {
import {$GTOreDefinition, $GTOreDefinition$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTOreDefinition"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $VeinGenerator {
static readonly "REGISTRY_CODEC": $Codec<($Codec<(any)>)>
static readonly "DIRECT_CODEC": $Codec<($VeinGenerator)>

constructor()
constructor(entry: $GTOreDefinition$Type)

public "copy"(): $VeinGenerator
public "codec"(): $Codec<(any)>
public "getAllEntries"(): $List<($Map$Entry<($Either<($BlockState), ($Material)>), (integer)>)>
public "getAllBlocks"(): $List<($BlockState)>
public "getAllMaterials"(): $List<($Material)>
public "getAllChances"(): $List<(integer)>
public "getValidMaterialsChances"(): $List<($Map$Entry<(integer), ($Material)>)>
get "allEntries"(): $List<($Map$Entry<($Either<($BlockState), ($Material)>), (integer)>)>
get "allBlocks"(): $List<($BlockState)>
get "allMaterials"(): $List<($Material)>
get "allChances"(): $List<(integer)>
get "validMaterialsChances"(): $List<($Map$Entry<(integer), ($Material)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VeinGenerator$Type = ($VeinGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VeinGenerator_ = $VeinGenerator$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/bedrockfluid/$BedrockFluidDefinition" {
import {$MapCodec, $MapCodec$Type} from "packages/com/mojang/serialization/$MapCodec"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BiomeWeightModifier, $BiomeWeightModifier$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$BiomeWeightModifier"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$BedrockFluidDefinition$Builder, $BedrockFluidDefinition$Builder$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/bedrockfluid/$BedrockFluidDefinition$Builder"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"

export class $BedrockFluidDefinition {
static readonly "YIELD": $MapCodec<($Pair<(integer), (integer)>)>
static readonly "FULL_CODEC": $Codec<($BedrockFluidDefinition)>
 "dimensionFilter": $Set<($ResourceKey<($Level)>)>

constructor(name: $ResourceLocation$Type, weight: integer, minimumYield: integer, maximumYield: integer, depletionAmount: integer, depletionChance: integer, depletedYield: integer, storedFluid: $Supplier$Type<($Fluid$Type)>, originalModifiers: $List$Type<($BiomeWeightModifier$Type)>, dimensionFilter: $Set$Type<($ResourceKey$Type<($Level$Type)>)>)
constructor(weight: integer, minimumYield: integer, maximumYield: integer, depletionAmount: integer, depletionChance: integer, depletedYield: integer, storedFluid: $Supplier$Type<($Fluid$Type)>, originalModifiers: $List$Type<($BiomeWeightModifier$Type)>, dimensionFilter: $Set$Type<($ResourceKey$Type<($Level$Type)>)>)

public static "builder"(name: $ResourceLocation$Type): $BedrockFluidDefinition$Builder
public "setWeight"(weight: integer): void
public "getWeight"(): integer
public "getStoredFluid"(): $Supplier<($Fluid)>
public "getDepletedYield"(): integer
public "getDepletionChance"(): integer
public "getMinimumYield"(): integer
public "getMaximumYield"(): integer
public "setMinimumYield"(minimumYield: integer): void
public "setStoredFluid"(storedFluid: $Supplier$Type<($Fluid$Type)>): void
public "setMaximumYield"(maximumYield: integer): void
public "setDepletionChance"(depletionChance: integer): void
public "setDimensionFilter"(dimensionFilter: $Set$Type<($ResourceKey$Type<($Level$Type)>)>): void
public "setDepletionAmount"(depletionAmount: integer): void
public "setDepletedYield"(depletedYield: integer): void
public "getDepletionAmount"(): integer
public "getDimensionFilter"(): $Set<($ResourceKey<($Level)>)>
public "setOriginalModifiers"(modifiers: $List$Type<($BiomeWeightModifier$Type)>): void
public "getBiomeWeightModifier"(): $BiomeWeightModifier
set "weight"(value: integer)
get "weight"(): integer
get "storedFluid"(): $Supplier<($Fluid)>
get "depletedYield"(): integer
get "depletionChance"(): integer
get "minimumYield"(): integer
get "maximumYield"(): integer
set "minimumYield"(value: integer)
set "storedFluid"(value: $Supplier$Type<($Fluid$Type)>)
set "maximumYield"(value: integer)
set "depletionChance"(value: integer)
set "dimensionFilter"(value: $Set$Type<($ResourceKey$Type<($Level$Type)>)>)
set "depletionAmount"(value: integer)
set "depletedYield"(value: integer)
get "depletionAmount"(): integer
get "dimensionFilter"(): $Set<($ResourceKey<($Level)>)>
set "originalModifiers"(value: $List$Type<($BiomeWeightModifier$Type)>)
get "biomeWeightModifier"(): $BiomeWeightModifier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BedrockFluidDefinition$Type = ($BedrockFluidDefinition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BedrockFluidDefinition_ = $BedrockFluidDefinition$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/capability/$IControllable" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IControllable {

 "setWorkingEnabled"(arg0: boolean): void
 "isWorkingEnabled"(): boolean
}

export namespace $IControllable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IControllable$Type = ($IControllable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IControllable_ = $IControllable$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/block/$ICoilType" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$Lazy, $Lazy$Type} from "packages/net/minecraftforge/common/util/$Lazy"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $ICoilType {

 "getName"(): string
 "getLevel"(): integer
 "getTexture"(): $ResourceLocation
 "getTier"(): integer
 "getMaterial"(): $Material
 "getEnergyDiscount"(): integer
 "getCoilTemperature"(): integer
}

export namespace $ICoilType {
const ALL_COILS_TEMPERATURE_SORTED: $Lazy<(($ICoilType)[])>
function getMinRequiredType(requiredTemperature: integer): $ICoilType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICoilType$Type = ($ICoilType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICoilType_ = $ICoilType$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/fluids/store/$FluidStorageKey" {
import {$MaterialIconType, $MaterialIconType$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/info/$MaterialIconType"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/com/gregtechceu/gtceu/api/fluids/$FluidState"

export class $FluidStorageKey {

constructor(resourceLocation: $ResourceLocation$Type, iconType: $MaterialIconType$Type, registryNameOperator: $UnaryOperator$Type<(string)>, translationKeyFunction: $Function$Type<($Material$Type), (string)>, defaultFluidState: $FluidState$Type, registrationPriority: integer)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "getByName"(location: $ResourceLocation$Type): $FluidStorageKey
public static "allKeys"(): $Collection<($FluidStorageKey)>
public "getResourceLocation"(): $ResourceLocation
public "getRegistryNameFor"(baseName: string): string
public "getIconType"(): $MaterialIconType
public "getTranslationKeyFor"(material: $Material$Type): string
public "getRegistrationPriority"(): integer
public "getDefaultFluidState"(): $FluidState
get "resourceLocation"(): $ResourceLocation
get "iconType"(): $MaterialIconType
get "registrationPriority"(): integer
get "defaultFluidState"(): $FluidState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidStorageKey$Type = ($FluidStorageKey);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidStorageKey_ = $FluidStorageKey$Type;
}}
declare module "packages/com/gregtechceu/gtceu/core/mixins/$ClientLevelAccessor" {
import {$Object2ObjectArrayMap, $Object2ObjectArrayMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectArrayMap"
import {$BlockTintCache, $BlockTintCache$Type} from "packages/net/minecraft/client/color/block/$BlockTintCache"
import {$ColorResolver, $ColorResolver$Type} from "packages/net/minecraft/world/level/$ColorResolver"

export interface $ClientLevelAccessor {

 "getTintCaches"(): $Object2ObjectArrayMap<($ColorResolver), ($BlockTintCache)>

(): $Object2ObjectArrayMap<($ColorResolver), ($BlockTintCache)>
}

export namespace $ClientLevelAccessor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientLevelAccessor$Type = ($ClientLevelAccessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientLevelAccessor_ = $ClientLevelAccessor$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$GemProperty" {
import {$IMaterialProperty, $IMaterialProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IMaterialProperty"
import {$MaterialProperties, $MaterialProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$MaterialProperties"

export class $GemProperty implements $IMaterialProperty<($GemProperty)> {

constructor()

public "verifyProperty"(properties: $MaterialProperties$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GemProperty$Type = ($GemProperty);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GemProperty_ = $GemProperty$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/block/$IAppearance" {
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export interface $IAppearance {

 "getBlockAppearance"(state: $BlockState$Type, level: $BlockAndTintGetter$Type, pos: $BlockPos$Type, side: $Direction$Type, sourceState: $BlockState$Type, sourcePos: $BlockPos$Type): $BlockState
}

export namespace $IAppearance {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IAppearance$Type = ($IAppearance);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IAppearance_ = $IAppearance$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/multiblock/$CleanroomType" {
import {$Set, $Set$Type} from "packages/java/util/$Set"

export class $CleanroomType {
static readonly "CLEANROOM": $CleanroomType
static readonly "STERILE_CLEANROOM": $CleanroomType

constructor(name: string, translationKey: string)

public "getName"(): string
public static "getByName"(name: string): $CleanroomType
public "getTranslationKey"(): string
public static "getByNameOrDefault"(name: string): $CleanroomType
public static "getAllTypes"(): $Set<($CleanroomType)>
get "name"(): string
get "translationKey"(): string
get "allTypes"(): $Set<($CleanroomType)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CleanroomType$Type = ($CleanroomType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CleanroomType_ = $CleanroomType$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/item/$ItemNetHandler" {
import {$ItemPipeNet, $ItemPipeNet$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/item/$ItemPipeNet"
import {$IItemTransfer, $IItemTransfer$Type} from "packages/com/lowdragmc/lowdraglib/side/item/$IItemTransfer"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CoverBehavior, $CoverBehavior$Type} from "packages/com/gregtechceu/gtceu/api/cover/$CoverBehavior"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ItemPipeBlockEntity, $ItemPipeBlockEntity$Type} from "packages/com/gregtechceu/gtceu/common/blockentity/$ItemPipeBlockEntity"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ItemRoutePath, $ItemRoutePath$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/item/$ItemRoutePath"
import {$RobotArmCover, $RobotArmCover$Type} from "packages/com/gregtechceu/gtceu/common/cover/$RobotArmCover"

export class $ItemNetHandler implements $IItemTransfer {

constructor(net: $ItemPipeNet$Type, pipe: $ItemPipeBlockEntity$Type, facing: $Direction$Type)

public "insert"(handler: $ItemRoutePath$Type, stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "insert"(routePath: $ItemRoutePath$Type, stack: $ItemStack$Type, simulate: boolean, ignoreLimit: boolean): $ItemStack
public "insertFirst"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "getFacing"(): $Direction
public "getSlots"(): integer
public "extractItem"(slot: integer, amount: integer, simulate: boolean, notifyChanges: boolean): $ItemStack
public "getSlotLimit"(i: integer): integer
public "getStackInSlot"(i: integer): $ItemStack
public "insertItem"(slot: integer, stack: $ItemStack$Type, simulate: boolean, notifyChanges: boolean): $ItemStack
public "isItemValid"(slot: integer, stack: $ItemStack$Type): boolean
public "createSnapshot"(): any
public "updateNetwork"(net: $ItemPipeNet$Type): void
public "restoreFromSnapshot"(snapshot: any): void
public "getNet"(): $ItemPipeNet
public static "checkImportCover"(cover: $CoverBehavior$Type, onPipe: boolean, stack: $ItemStack$Type): boolean
public "updatePipe"(pipe: $ItemPipeBlockEntity$Type): void
public "insertRoundRobin"(stack: $ItemStack$Type, simulate: boolean, global: boolean): $ItemStack
public static "countStack"(handler: $IItemTransfer$Type, stack: $ItemStack$Type, arm: $RobotArmCover$Type, isStackSpecific: boolean): integer
public "insertOverRobotArm"(handler: $IItemTransfer$Type, arm: $RobotArmCover$Type, stack: $ItemStack$Type, simulate: boolean, allowed: integer, ignoreLimit: boolean): $ItemStack
public "getCoverOnNeighbour"(pos: $BlockPos$Type, handlerFacing: $Direction$Type): $CoverBehavior
public "setStackInSlot"(index: integer, stack: $ItemStack$Type): void
public "onContentsChanged"(): void
public "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
public "insertItem"(slot: integer, stack: $ItemStack$Type, simulate: boolean): $ItemStack
get "facing"(): $Direction
get "slots"(): integer
get "net"(): $ItemPipeNet
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemNetHandler$Type = ($ItemNetHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemNetHandler_ = $ItemNetHandler$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/gui/fancy/$VerticalTabsWidget" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IFancyUIProvider, $IFancyUIProvider$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$IFancyUIProvider"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$TabsWidget, $TabsWidget$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$TabsWidget"

export class $VerticalTabsWidget extends $TabsWidget {

constructor(onTabClick: $Consumer$Type<($IFancyUIProvider$Type)>, x: integer, y: integer, width: integer, height: integer)

public "drawInBackground"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
public "hasButton"(): boolean
public "getHoveredTab"(mouseX: double, mouseY: double): $IFancyUIProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VerticalTabsWidget$Type = ($VerticalTabsWidget);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VerticalTabsWidget_ = $VerticalTabsWidget$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/cover/filter/$ItemFilter" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Filter, $Filter$Type} from "packages/com/gregtechceu/gtceu/api/cover/filter/$Filter"
import {$WidgetGroup, $WidgetGroup$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$WidgetGroup"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $ItemFilter extends $Filter<($ItemStack), ($ItemFilter)> {

 "testItemCount"(arg0: $ItemStack$Type): integer
 "supportsAmounts"(): boolean
 "openConfigurator"(arg0: integer, arg1: integer): $WidgetGroup
 "setOnUpdated"(arg0: $Consumer$Type<($ItemFilter$Type)>): void
 "saveFilter"(): $CompoundTag
 "isBlackList"(): boolean
 "test"(arg0: $ItemStack$Type): boolean
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<($ItemStack)>
 "negate"(): $Predicate<($ItemStack)>
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<($ItemStack)>
}

export namespace $ItemFilter {
const FILTERS: $Map<($ItemLike), ($Function<($ItemStack), ($ItemFilter)>)>
const EMPTY: $ItemFilter
function loadFilter(itemStack: $ItemStack$Type): $ItemFilter
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<($ItemStack)>
function isEqual<T>(arg0: any): $Predicate<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemFilter$Type = ($ItemFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemFilter_ = $ItemFilter$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/registry/registrate/$CompassNode" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Position, $Position$Type} from "packages/com/lowdragmc/lowdraglib/utils/$Position"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$IGuiTexture, $IGuiTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$IGuiTexture"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$CompassSection, $CompassSection$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$CompassSection"

export class $CompassNode {


public "position"(x: integer, y: integer): $CompassNode
public "position"(position: $Position$Type): $CompassNode
public "size"(size: integer): $CompassNode
public "lang"(lang: string): $CompassNode
public "lang"(): string
public static "getOrCreate"(section: $CompassSection$Type, nodeID: string): $CompassNode
public static "getOrCreate"(sectionID: $ResourceLocation$Type, nodeID: string): $CompassNode
public static "getOrCreate"(section: $CompassSection$Type, item: $Supplier$Type<(any)>): $CompassNode
public "addItem"(item: $Supplier$Type<(any)>): $CompassNode
public "icon"(icon: $Supplier$Type<($IGuiTexture$Type)>): $CompassNode
public "addTag"(...tags: ($TagKey$Type<($Item$Type)>)[]): $CompassNode
public "nodeID"(): $ResourceLocation
public "sectionID"(): $ResourceLocation
public "addPreNode"(...node: ($CompassNode$Type)[]): $CompassNode
public "addPreNode"(...nodeID: ($ResourceLocation$Type)[]): $CompassNode
public "page"(page: $ResourceLocation$Type): $CompassNode
public "getUnlocalizedKey"(): string
public "iconIfNull"(icon: $Supplier$Type<($IGuiTexture$Type)>): $CompassNode
get "unlocalizedKey"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompassNode$Type = ($CompassNode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompassNode_ = $CompassNode$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/capability/recipe/$IRecipeCapabilityHolder" {
import {$IRecipeHandler, $IRecipeHandler$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IRecipeHandler"
import {$Table, $Table$Type} from "packages/com/google/common/collect/$Table"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RecipeCapability, $RecipeCapability$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$RecipeCapability"
import {$IO, $IO$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IO"

export interface $IRecipeCapabilityHolder {

 "hasProxies"(): boolean
 "getCapabilitiesProxy"(): $Table<($IO), ($RecipeCapability<(any)>), ($List<($IRecipeHandler<(any)>)>)>
 "getChanceTier"(): integer

(): boolean
}

export namespace $IRecipeCapabilityHolder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRecipeCapabilityHolder$Type = ($IRecipeCapabilityHolder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRecipeCapabilityHolder_ = $IRecipeCapabilityHolder$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$PolymerProperty" {
import {$IMaterialProperty, $IMaterialProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IMaterialProperty"
import {$MaterialProperties, $MaterialProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$MaterialProperties"

export class $PolymerProperty implements $IMaterialProperty<($PolymerProperty)> {

constructor()

public "verifyProperty"(properties: $MaterialProperties$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PolymerProperty$Type = ($PolymerProperty);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PolymerProperty_ = $PolymerProperty$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/$ChemicalHelper" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$MaterialStack, $MaterialStack$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/stack/$MaterialStack"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$TagPrefix, $TagPrefix$Type} from "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$ItemMaterialInfo, $ItemMaterialInfo$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/stack/$ItemMaterialInfo"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ArrayList, $ArrayList$Type} from "packages/java/util/$ArrayList"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"
import {$UnificationEntry, $UnificationEntry$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/stack/$UnificationEntry"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $ChemicalHelper {
static readonly "ITEM_MATERIAL_INFO": $Map<($ItemLike), ($ItemMaterialInfo)>
static readonly "ITEM_UNIFICATION_ENTRY": $Set<($Map$Entry<($Supplier<(any)>), ($UnificationEntry)>)>
static readonly "ITEM_UNIFICATION_ENTRY_COLLECTED": $Map<($ItemLike), ($UnificationEntry)>
static readonly "TAG_UNIFICATION_ENTRY": $Map<($TagKey<($Item)>), ($UnificationEntry)>
static readonly "FLUID_MATERIAL": $Map<($Fluid), ($Material)>
static readonly "UNIFICATION_ENTRY_ITEM": $Map<($UnificationEntry), ($ArrayList<($Supplier<(any)>)>)>
static readonly "UNIFICATION_ENTRY_BLOCK": $Map<($UnificationEntry), ($ArrayList<($Supplier<(any)>)>)>
static readonly "ORES_INVERSE": $Map<($Supplier<($BlockState)>), ($TagPrefix)>

constructor()

public static "get"(orePrefix: $TagPrefix$Type, material: $Material$Type, stackSize: integer): $ItemStack
public static "get"(unificationEntry: $UnificationEntry$Type, size: integer): $ItemStack
public static "get"(orePrefix: $TagPrefix$Type, material: $Material$Type): $ItemStack
public static "getTag"(orePrefix: $TagPrefix$Type, material: $Material$Type): $TagKey<($Item)>
public static "getBlock"(unificationEntry: $UnificationEntry$Type): $Block
public static "getBlock"(orePrefix: $TagPrefix$Type, material: $Material$Type): $Block
public static "getPrefix"(itemLike: $ItemLike$Type): $TagPrefix
public static "getBlocks"(unificationEntry: $UnificationEntry$Type): $List<($Block)>
public static "getTags"(orePrefix: $TagPrefix$Type, material: $Material$Type): ($TagKey<($Item)>)[]
public static "getItems"(unificationEntry: $UnificationEntry$Type): $List<($ItemLike)>
public static "getMaterialInfo"(item: $ItemLike$Type): $ItemMaterialInfo
public static "getMaterial"(fluid: $Fluid$Type): $Material
public static "getMaterial"(entry: $UnificationEntry$Type): $MaterialStack
public static "getMaterial"(itemStack: $ItemStack$Type): $MaterialStack
public static "getMaterial"(itemLike: $ItemLike$Type): $MaterialStack
public static "registerMaterialInfo"(item: $ItemLike$Type, materialInfo: $ItemMaterialInfo$Type): void
public static "reinitializeUnification"(): void
public static "registerUnificationItems"(tagPrefix: $TagPrefix$Type, material: $Material$Type, ...items: ($Supplier$Type<(any)>)[]): void
public static "registerUnificationItems"(unificationEntry: $UnificationEntry$Type, ...items: ($Supplier$Type<(any)>)[]): void
public static "registerUnificationItems"(tagPrefix: $TagPrefix$Type, material: $Material$Type, ...items: ($ItemLike$Type)[]): void
public static "getGem"(materialStack: $MaterialStack$Type): $ItemStack
public static "getBlockTag"(orePrefix: $TagPrefix$Type, material: $Material$Type): $TagKey<($Block)>
public static "getDust"(materialStack: $MaterialStack$Type): $ItemStack
public static "getDust"(material: $Material$Type, materialAmount: long): $ItemStack
public static "getIngotOrDust"(materialStack: $MaterialStack$Type): $ItemStack
public static "getIngotOrDust"(material: $Material$Type, materialAmount: long): $ItemStack
public static "getIngot"(material: $Material$Type, materialAmount: long): $ItemStack
public static "getOrePrefix"(state: $BlockState$Type): $Optional<($TagPrefix)>
public static "getAllItemInfos"(): $List<($Map$Entry<($ItemStack), ($ItemMaterialInfo)>)>
public static "getUnificationEntry"(tag: $TagKey$Type<($Item$Type)>): $UnificationEntry
public static "getUnificationEntry"(itemLike: $ItemLike$Type): $UnificationEntry
get "allItemInfos"(): $List<($Map$Entry<($ItemStack), ($ItemMaterialInfo)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalHelper$Type = ($ChemicalHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalHelper_ = $ChemicalHelper$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/tool/$GTAxeItem" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$AxeItem, $AxeItem$Type} from "packages/net/minecraft/world/item/$AxeItem"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$FoodProperties, $FoodProperties$Type} from "packages/net/minecraft/world/food/$FoodProperties"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IGTTool, $IGTTool$Type} from "packages/com/gregtechceu/gtceu/api/item/$IGTTool"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$DustProperty, $DustProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$DustProperty"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$IGTToolDefinition, $IGTToolDefinition$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$IGTToolDefinition"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$HeldItemUIFactory$HeldItemHolder, $HeldItemUIFactory$HeldItemHolder$Type} from "packages/com/lowdragmc/lowdraglib/gui/factory/$HeldItemUIFactory$HeldItemHolder"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$ItemColor, $ItemColor$Type} from "packages/net/minecraft/client/color/item/$ItemColor"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$GTToolType, $GTToolType$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$MaterialToolTier, $MaterialToolTier$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$MaterialToolTier"
import {$ModularUI, $ModularUI$Type} from "packages/com/lowdragmc/lowdraglib/gui/modular/$ModularUI"
import {$ToolProperty, $ToolProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$ToolProperty"
import {$SoundEntry, $SoundEntry$Type} from "packages/com/gregtechceu/gtceu/api/sound/$SoundEntry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GTAxeItem extends $AxeItem implements $IGTTool {
static "STRIPPABLES": $Map<($Block), ($Block)>
 "speed": float
 "defaultModifiers": $Multimap<($Attribute), ($AttributeModifier)>
 "tier": $Tier
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "descriptionId": string
 "foodProperties": $FoodProperties
readonly "canRepair": boolean
 "renderProperties": any
 "moonlight$clientAnimationProvider": any


public static "create"(toolType: $GTToolType$Type, tier: $MaterialToolTier$Type, material: $Material$Type, toolStats: $IGTToolDefinition$Type, properties: $Item$Properties$Type): $GTAxeItem
public "getDamage"(stack: $ItemStack$Type): integer
public "appendHoverText"(stack: $ItemStack$Type, level: $Level$Type, tooltipComponents: $List$Type<($Component$Type)>, isAdvanced: $TooltipFlag$Type): void
public "getName"(stack: $ItemStack$Type): $Component
public "shouldCauseReequipAnimation"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type, slotChanged: boolean): boolean
public "isCorrectToolForDrops"(stack: $ItemStack$Type, state: $BlockState$Type): boolean
public "getCraftingRemainingItem"(itemStack: $ItemStack$Type): $ItemStack
public "hasCraftingRemainingItem"(stack: $ItemStack$Type): boolean
public "getAttributeModifiers"(slot: $EquipmentSlot$Type, stack: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "use"(level: $Level$Type, player: $Player$Type, usedHand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "useOn"(context: $UseOnContext$Type): $InteractionResult
public "getDestroySpeed"(stack: $ItemStack$Type, state: $BlockState$Type): float
public "hurtEnemy"(stack: $ItemStack$Type, target: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
public "getMaxDamage"(stack: $ItemStack$Type): integer
public "mineBlock"(stack: $ItemStack$Type, level: $Level$Type, state: $BlockState$Type, pos: $BlockPos$Type, miningEntity: $LivingEntity$Type): boolean
public "getDescription"(): $Component
public "hasCraftingRemainingItem"(): boolean
public "isValidRepairItem"(stack: $ItemStack$Type, repairCandidate: $ItemStack$Type): boolean
public "doesSneakBypassUse"(stack: $ItemStack$Type, level: $LevelReader$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "onItemUseFirst"(itemStack: $ItemStack$Type, context: $UseOnContext$Type): $InteractionResult
public "onBlockStartBreak"(stack: $ItemStack$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "isDamaged"(stack: $ItemStack$Type): boolean
public "setDamage"(stack: $ItemStack$Type, damage: integer): void
public "getSound"(): $SoundEntry
public "canDisableShield"(stack: $ItemStack$Type, shield: $ItemStack$Type, entity: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
public "getEnchantmentValue"(stack: $ItemStack$Type): integer
public "shouldCauseBlockBreakReset"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type): boolean
public "canApplyAtEnchantingTable"(stack: $ItemStack$Type, enchantment: $Enchantment$Type): boolean
public "getDescriptionId"(): string
public "getDefaultInstance"(): $ItemStack
public "initCapabilities"(stack: $ItemStack$Type, nbt: $CompoundTag$Type): $ICapabilityProvider
public "isElectric"(): boolean
public "getMaterial"(): $Material
public "playSoundOnBlockDestroy"(): boolean
public "getToolStats"(): $IGTToolDefinition
public "getElectricTier"(): integer
public "getToolType"(): $GTToolType
public "getToolClasses"(stack: $ItemStack$Type): $Set<($GTToolType)>
public "get"(defaultMaxCharge: long): $ItemStack
public "get"(): $ItemStack
public "get"(defaultCharge: long, defaultMaxCharge: long): $ItemStack
public "getRaw"(): $ItemStack
public "getColor"(stack: $ItemStack$Type, tintIndex: integer): integer
public "createUI"(entityPlayer: $Player$Type, holder: $HeldItemUIFactory$HeldItemHolder$Type): $ModularUI
public static "tintColor"(): $ItemColor
public "definition$canApplyAtEnchantingTable"(stack: $ItemStack$Type, enchantment: $Enchantment$Type): boolean
public "definition$shouldCauseReequipAnimation"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type, slotChanged: boolean): boolean
public "definition$getDefaultAttributeModifiers"(equipmentSlot: $EquipmentSlot$Type, stack: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "definition$shouldCauseBlockBreakReset"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type): boolean
public "definition$getCraftingRemainingItem"(stack: $ItemStack$Type): $ItemStack
public "definition$hasCraftingRemainingItem"(stack: $ItemStack$Type): boolean
public "definition$canDestroyBlockInCreative"(world: $Level$Type, pos: $BlockPos$Type, stack: $ItemStack$Type, player: $Player$Type): boolean
public "getCharge"(stack: $ItemStack$Type): long
public "playSound"(player: $Player$Type): void
public "asItem"(): $Item
public "definition$isDamaged"(stack: $ItemStack$Type): boolean
public "getToolMaterial"(stack: $ItemStack$Type): $Material
public "getMaxCharge"(stack: $ItemStack$Type): long
public "getTotalToolSpeed"(stack: $ItemStack$Type): float
public "getToolProperty"(stack: $ItemStack$Type): $ToolProperty
public "getDustProperty"(stack: $ItemStack$Type): $DustProperty
public "playCraftingSound"(player: $Player$Type, stack: $ItemStack$Type): void
public "definition$use"(world: $Level$Type, player: $Player$Type, hand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "definition$init"(): void
public "canPlaySound"(stack: $ItemStack$Type): boolean
public "getToolClassNames"(stack: $ItemStack$Type): $Set<(string)>
public "definition$getDestroySpeed"(stack: $ItemStack$Type, state: $BlockState$Type): float
public "getTotalAttackDamage"(stack: $ItemStack$Type): float
public "getTotalAttackSpeed"(stack: $ItemStack$Type): float
public "definition$hurtEnemy"(stack: $ItemStack$Type, target: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
public "getTotalHarvestLevel"(stack: $ItemStack$Type): integer
public "getMaterialAttackSpeed"(stack: $ItemStack$Type): float
public "definition$onBlockStartBreak"(stack: $ItemStack$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "definition$mineBlock"(stack: $ItemStack$Type, worldIn: $Level$Type, state: $BlockState$Type, pos: $BlockPos$Type, entityLiving: $LivingEntity$Type): boolean
public "definition$isValidRepairItem"(toRepair: $ItemStack$Type, repair: $ItemStack$Type): boolean
public "definition$getHarvestLevel"(stack: $ItemStack$Type, toolClass: $GTToolType$Type, player: $Player$Type, blockState: $BlockState$Type): integer
public "getMaterialAttackDamage"(stack: $ItemStack$Type): float
public "definition$canDisableShield"(stack: $ItemStack$Type, shield: $ItemStack$Type, entity: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
public "definition$doesSneakBypassUse"(stack: $ItemStack$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "getMaterialEnchantability"(stack: $ItemStack$Type): integer
public "definition$onEntitySwing"(entityLiving: $LivingEntity$Type, stack: $ItemStack$Type): boolean
public "getTotalEnchantability"(stack: $ItemStack$Type): integer
public "getMaterialDurability"(stack: $ItemStack$Type): integer
public "definition$getDamage"(stack: $ItemStack$Type): integer
public "getTotalMaxDurability"(stack: $ItemStack$Type): integer
public "getMaterialToolSpeed"(stack: $ItemStack$Type): float
public "getMaterialHarvestLevel"(stack: $ItemStack$Type): integer
public "definition$getMaxDamage"(stack: $ItemStack$Type): integer
public "definition$setDamage"(stack: $ItemStack$Type, durability: integer): void
public "definition$getDurabilityForDisplay"(stack: $ItemStack$Type): double
public "definition$onItemUse"(context: $UseOnContext$Type): $InteractionResult
public "setLastCraftingSoundTime"(stack: $ItemStack$Type): void
public "definition$initCapabilities"(stack: $ItemStack$Type, nbt: $CompoundTag$Type): $ICapabilityProvider
public "definition$appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "definition$shouldOpenUIAfterUse"(context: $UseOnContext$Type): boolean
public "definition$fillItemCategory"(category: $CreativeModeTab$Type, items: $NonNullList$Type<($ItemStack$Type)>): void
public "definition$onItemUseFirst"(stack: $ItemStack$Type, context: $UseOnContext$Type): $InteractionResult
public "definition$isCorrectToolForDrops"(stack: $ItemStack$Type, state: $BlockState$Type): boolean
get "description"(): $Component
get "sound"(): $SoundEntry
get "descriptionId"(): string
get "defaultInstance"(): $ItemStack
get "electric"(): boolean
get "material"(): $Material
get "toolStats"(): $IGTToolDefinition
get "electricTier"(): integer
get "toolType"(): $GTToolType
get "raw"(): $ItemStack
set "lastCraftingSoundTime"(value: $ItemStack$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTAxeItem$Type = ($GTAxeItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTAxeItem_ = $GTAxeItem$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/feature/$IRecipeLogicMachine" {
import {$GTRecipeType, $GTRecipeType$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipeType"
import {$IRecipeHandler, $IRecipeHandler$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IRecipeHandler"
import {$RecipeLogic$Status, $RecipeLogic$Status$Type} from "packages/com/gregtechceu/gtceu/api/machine/trait/$RecipeLogic$Status"
import {$Table, $Table$Type} from "packages/com/google/common/collect/$Table"
import {$IMachineFeature, $IMachineFeature$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/$IMachineFeature"
import {$GTRecipe, $GTRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe"
import {$IWorkable, $IWorkable$Type} from "packages/com/gregtechceu/gtceu/api/capability/$IWorkable"
import {$RecipeCapability, $RecipeCapability$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$RecipeCapability"
import {$IO, $IO$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IO"
import {$IRecipeCapabilityHolder, $IRecipeCapabilityHolder$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IRecipeCapabilityHolder"
import {$IVoidable, $IVoidable$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/$IVoidable"
import {$ICleanroomProvider, $ICleanroomProvider$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/$ICleanroomProvider"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MetaMachine, $MetaMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MetaMachine"
import {$RecipeLogic, $RecipeLogic$Type} from "packages/com/gregtechceu/gtceu/api/machine/trait/$RecipeLogic"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$ICleanroomReceiver, $ICleanroomReceiver$Type} from "packages/com/gregtechceu/gtceu/api/capability/$ICleanroomReceiver"

export interface $IRecipeLogicMachine extends $IRecipeCapabilityHolder, $IMachineFeature, $IWorkable, $ICleanroomReceiver, $IVoidable {

 "isActive"(): boolean
 "getRecipeType"(): $GTRecipeType
 "getRecipeTypes"(): ($GTRecipeType)[]
 "getProgress"(): integer
 "alwaysTryModifyRecipe"(): boolean
 "onWorking"(): boolean
 "afterWorking"(): void
 "onWaiting"(): void
 "beforeWorking"(recipe: $GTRecipe$Type): boolean
 "setWorkingEnabled"(isWorkingAllowed: boolean): void
 "isWorkingEnabled"(): boolean
 "doModifyRecipe"(recipe: $GTRecipe$Type): $GTRecipe
 "getChanceTier"(): integer
 "fullModifyRecipe"(recipe: $GTRecipe$Type): $GTRecipe
 "getMaxProgress"(): integer
 "getRecipeLogic"(): $RecipeLogic
 "keepSubscribing"(): boolean
 "dampingWhenWaiting"(): boolean
 "shouldWorkingPlaySound"(): boolean
 "getActiveRecipeType"(): integer
 "notifyStatusChanged"(oldStatus: $RecipeLogic$Status$Type, newStatus: $RecipeLogic$Status$Type): void
 "isRecipeLogicAvailable"(): boolean
 "setActiveRecipeType"(arg0: integer): void
 "hasProxies"(): boolean
 "getCapabilitiesProxy"(): $Table<($IO), ($RecipeCapability<(any)>), ($List<($IRecipeHandler<(any)>)>)>
 "self"(): $MetaMachine
 "getCleanroom"(): $ICleanroomProvider
 "setCleanroom"(arg0: $ICleanroomProvider$Type): void
 "getOutputLimits"(): $Map<($RecipeCapability<(any)>), (integer)>
 "canVoidRecipeOutputs"(capability: $RecipeCapability$Type<(any)>): boolean
}

export namespace $IRecipeLogicMachine {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRecipeLogicMachine$Type = ($IRecipeLogicMachine);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRecipeLogicMachine_ = $IRecipeLogicMachine$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/$FluidPipeBlock" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$PipeModel, $PipeModel$Type} from "packages/com/gregtechceu/gtceu/client/model/$PipeModel"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$IPipeNode, $IPipeNode$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeNode"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$MaterialPipeBlock, $MaterialPipeBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$MaterialPipeBlock"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$PipeBlockRenderer, $PipeBlockRenderer$Type} from "packages/com/gregtechceu/gtceu/client/renderer/block/$PipeBlockRenderer"
import {$LevelFluidPipeNet, $LevelFluidPipeNet$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/fluidpipe/$LevelFluidPipeNet"
import {$IPipeType, $IPipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeType"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$FluidPipeType, $FluidPipeType$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/fluidpipe/$FluidPipeType"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$FluidPipeProperties, $FluidPipeProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$FluidPipeProperties"

export class $FluidPipeBlock extends $MaterialPipeBlock<($FluidPipeType), ($FluidPipeProperties), ($LevelFluidPipeNet)> {
readonly "material": $Material
readonly "renderer": $PipeBlockRenderer
readonly "model": $PipeModel
readonly "pipeType": PipeType
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, fluidPipeType: $FluidPipeType$Type, material: $Material$Type)

public "getBlockEntityType"(): $BlockEntityType<(any)>
public "appendHoverText"(stack: $ItemStack$Type, level: $BlockGetter$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "entityInside"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, entity: $Entity$Type): void
public "canPipeConnectToBlock"(selfTile: $IPipeNode$Type<($FluidPipeType$Type), ($FluidPipeProperties$Type)>, side: $Direction$Type, tile: $BlockEntity$Type): boolean
public "canPipesConnect"(selfTile: $IPipeNode$Type<($FluidPipeType$Type), ($FluidPipeProperties$Type)>, side: $Direction$Type, sideTile: $IPipeNode$Type<($FluidPipeType$Type), ($FluidPipeProperties$Type)>): boolean
get "blockEntityType"(): $BlockEntityType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidPipeBlock$Type = ($FluidPipeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidPipeBlock_ = $FluidPipeBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/item/$PortableScannerBehavior$DisplayMode" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $PortableScannerBehavior$DisplayMode extends $Enum<($PortableScannerBehavior$DisplayMode)> {
static readonly "SHOW_ALL": $PortableScannerBehavior$DisplayMode
static readonly "SHOW_BLOCK_INFO": $PortableScannerBehavior$DisplayMode
static readonly "SHOW_MACHINE_INFO": $PortableScannerBehavior$DisplayMode
static readonly "SHOW_ELECTRICAL_INFO": $PortableScannerBehavior$DisplayMode
static readonly "SHOW_RECIPE_INFO": $PortableScannerBehavior$DisplayMode
static readonly "SHOW_ENVIRONMENTAL_INFO": $PortableScannerBehavior$DisplayMode


public static "values"(): ($PortableScannerBehavior$DisplayMode)[]
public static "valueOf"(name: string): $PortableScannerBehavior$DisplayMode
public "getLangKey"(): string
get "langKey"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PortableScannerBehavior$DisplayMode$Type = (("show_machine_info") | ("show_block_info") | ("show_recipe_info") | ("show_electrical_info") | ("show_all") | ("show_environmental_info")) | ($PortableScannerBehavior$DisplayMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PortableScannerBehavior$DisplayMode_ = $PortableScannerBehavior$DisplayMode$Type;
}}
declare module "packages/com/gregtechceu/gtceu/integration/kjs/$GTRegistryInfo" {
import {$GTRecipeType, $GTRecipeType$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipeType"
import {$MaterialIconType, $MaterialIconType$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/info/$MaterialIconType"
import {$DimensionMarker, $DimensionMarker$Type} from "packages/com/gregtechceu/gtceu/api/data/$DimensionMarker"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$GTRegistryInfo$BuilderType, $GTRegistryInfo$BuilderType$Type} from "packages/com/gregtechceu/gtceu/integration/kjs/$GTRegistryInfo$BuilderType"
import {$TagPrefix, $TagPrefix$Type} from "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$MaterialIconSet, $MaterialIconSet$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/info/$MaterialIconSet"
import {$IWorldGenLayer, $IWorldGenLayer$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$IWorldGenLayer"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$MachineDefinition, $MachineDefinition$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MachineDefinition"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$GTRegistryInfo$BuilderFactory, $GTRegistryInfo$BuilderFactory$Type} from "packages/com/gregtechceu/gtceu/integration/kjs/$GTRegistryInfo$BuilderFactory"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BuilderBase, $BuilderBase$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$BuilderBase"
import {$Element, $Element$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/$Element"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$GTRegistry, $GTRegistry$Type} from "packages/com/gregtechceu/gtceu/api/registry/$GTRegistry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GTRegistryInfo<K, V> {
static readonly "MAP": $Map<($ResourceLocation), ($GTRegistryInfo<(any), (any)>)>
static readonly "EXTRA_IDS": $Set<($ResourceLocation)>
static readonly "POST_AT": $Map<($ResourceLocation), ($List<($GTRegistryInfo<(any), (any)>)>)>
static readonly "ALL_BUILDERS": $List<($BuilderBase<(any)>)>
static readonly "ELEMENT": $GTRegistryInfo<(string), ($Element)>
static readonly "MATERIAL": $GTRegistryInfo<(string), ($Material)>
static readonly "RECIPE_TYPE": $GTRegistryInfo<($ResourceLocation), ($GTRecipeType)>
static readonly "MACHINE": $GTRegistryInfo<($ResourceLocation), ($MachineDefinition)>
static readonly "MATERIAL_ICON_SET": $GTRegistryInfo<(string), ($MaterialIconSet)>
static readonly "MATERIAL_ICON_TYPE": $GTRegistryInfo<(string), ($MaterialIconType)>
static readonly "WORLD_GEN_LAYER": $GTRegistryInfo<(string), ($IWorldGenLayer)>
static readonly "TAG_PREFIX": $GTRegistryInfo<(string), ($TagPrefix)>
static readonly "DIMENSION_MARKER": $GTRegistryInfo<($ResourceLocation), ($DimensionMarker)>
readonly "registryKey": $ResourceLocation
readonly "objectBaseClass": $Class<(V)>
readonly "types": $Map<(string), ($GTRegistryInfo$BuilderType<(V)>)>
readonly "objects": $Map<($ResourceLocation), ($BuilderBase<(any)>)>
readonly "registryValues": $Supplier<($Map<(K), (V)>)>
 "current": $BuilderBase<(any)>


public static "add"<K, V>(key: $GTRegistry$Type<(K), (V)>, baseClass: $Class$Type<(any)>): $GTRegistryInfo<(K), (V)>
public static "add"<K, V>(id: $ResourceLocation$Type, registryValues: $Supplier$Type<($Map$Type<(K), (V)>)>, baseClass: $Class$Type<(any)>): $GTRegistryInfo<(K), (V)>
public "addType"(type: string, builderType: $Class$Type<(any)>, factory: $GTRegistryInfo$BuilderFactory$Type<(V)>, isDefault: boolean): void
public "getDefaultType"(): $GTRegistryInfo$BuilderType<(V)>
public "postEvent"(): void
public "addBuilder"(builder: $BuilderBase$Type<(any)>): void
public static "registerFor"(registry: $ResourceLocation$Type): void
get "defaultType"(): $GTRegistryInfo$BuilderType<(V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTRegistryInfo$Type<K, V> = ($GTRegistryInfo<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTRegistryInfo_<K, V> = $GTRegistryInfo$Type<(K), (V)>;
}}
declare module "packages/com/gregtechceu/gtceu/api/gui/widget/$EnumSelectorWidget$SelectableEnum" {
import {$IGuiTexture, $IGuiTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$IGuiTexture"

export interface $EnumSelectorWidget$SelectableEnum {

 "getIcon"(): $IGuiTexture
 "getTooltip"(): string
}

export namespace $EnumSelectorWidget$SelectableEnum {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnumSelectorWidget$SelectableEnum$Type = ($EnumSelectorWidget$SelectableEnum);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnumSelectorWidget$SelectableEnum_ = $EnumSelectorWidget$SelectableEnum$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/worldgen/feature/configurations/$FluidSproutConfiguration" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ConfiguredFeature, $ConfiguredFeature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$ConfiguredFeature"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$IntProvider, $IntProvider$Type} from "packages/net/minecraft/util/valueproviders/$IntProvider"
import {$FeatureConfiguration, $FeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$FeatureConfiguration"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $FluidSproutConfiguration extends $Record implements $FeatureConfiguration {
static readonly "CODEC": $Codec<($FluidSproutConfiguration)>

constructor(fluid: $Fluid$Type, size: $IntProvider$Type, surfaceOffset: $IntProvider$Type, sproutChance: float)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "size"(): $IntProvider
public "fluid"(): $Fluid
public "surfaceOffset"(): $IntProvider
public "sproutChance"(): float
public "getFeatures"(): $Stream<($ConfiguredFeature<(any), (any)>)>
get "features"(): $Stream<($ConfiguredFeature<(any), (any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidSproutConfiguration$Type = ($FluidSproutConfiguration);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidSproutConfiguration_ = $FluidSproutConfiguration$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/item/$ItemRoutePath" {
import {$ItemPipeProperties, $ItemPipeProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$ItemPipeProperties"
import {$IItemTransfer, $IItemTransfer$Type} from "packages/com/lowdragmc/lowdraglib/side/item/$IItemTransfer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$FacingPos, $FacingPos$Type} from "packages/com/gregtechceu/gtceu/utils/$FacingPos"
import {$ItemPipeBlockEntity, $ItemPipeBlockEntity$Type} from "packages/com/gregtechceu/gtceu/common/blockentity/$ItemPipeBlockEntity"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$IRoutePath, $IRoutePath$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IRoutePath"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $ItemRoutePath implements $IRoutePath<($IItemTransfer)> {

constructor(targetPipe: $ItemPipeBlockEntity$Type, facing: $Direction$Type, distance: integer, properties: $ItemPipeProperties$Type, filters: $List$Type<($Predicate$Type<($ItemStack$Type)>)>)

public "getProperties"(): $ItemPipeProperties
public "getHandler"(world: $Level$Type): $IItemTransfer
public "getDistance"(): integer
public "getTargetPipePos"(): $BlockPos
public "getTargetFacing"(): $Direction
public "matchesFilters"(stack: $ItemStack$Type): boolean
public "getTargetPipe"(): $ItemPipeBlockEntity
public "toFacingPos"(): $FacingPos
public "getTargetBlockEntity"(level: $Level$Type): $BlockEntity
public "getTargetCapability"<I>(capability: $Capability$Type<(I)>, level: $Level$Type): I
get "properties"(): $ItemPipeProperties
get "distance"(): integer
get "targetPipePos"(): $BlockPos
get "targetFacing"(): $Direction
get "targetPipe"(): $ItemPipeBlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemRoutePath$Type = ($ItemRoutePath);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemRoutePath_ = $ItemRoutePath$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/registry/$GTRegistry$RL" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Tag, $Tag$Type} from "packages/net/minecraft/nbt/$Tag"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GTRegistry, $GTRegistry$Type} from "packages/com/gregtechceu/gtceu/api/registry/$GTRegistry"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GTRegistry$RL<V> extends $GTRegistry<($ResourceLocation), (V)> {
static readonly "REGISTERED": $Map<($ResourceLocation), ($GTRegistry<(any), (any)>)>

constructor(registryName: $ResourceLocation$Type)

public "codec"(): $Codec<(V)>
public "readBuf"(buf: $FriendlyByteBuf$Type): V
public "loadFromNBT"(tag: $Tag$Type): V
public "saveToNBT"(value: V): $Tag
public "writeBuf"(value: V, buf: $FriendlyByteBuf$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTRegistry$RL$Type<V> = ($GTRegistry$RL<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTRegistry$RL_<V> = $GTRegistry$RL$Type<(V)>;
}}
declare module "packages/com/gregtechceu/gtceu/common/blockentity/$CableBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ResourceTexture, $ResourceTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$ResourceTexture"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$IDataInfoProvider, $IDataInfoProvider$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/$IDataInfoProvider"
import {$PipeBlockEntity, $PipeBlockEntity$Type} from "packages/com/gregtechceu/gtceu/api/blockentity/$PipeBlockEntity"
import {$IEnergyContainer, $IEnergyContainer$Type} from "packages/com/gregtechceu/gtceu/api/capability/$IEnergyContainer"
import {$AttachmentTarget, $AttachmentTarget$Type} from "packages/net/fabricmc/fabric/api/attachment/v1/$AttachmentTarget"
import {$ManagedFieldHolder, $ManagedFieldHolder$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/field/$ManagedFieldHolder"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$WireProperties, $WireProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$WireProperties"
import {$Insulation, $Insulation$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/cable/$Insulation"
import {$GTToolType, $GTToolType$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$PortableScannerBehavior$DisplayMode, $PortableScannerBehavior$DisplayMode$Type} from "packages/com/gregtechceu/gtceu/common/item/$PortableScannerBehavior$DisplayMode"

export class $CableBlockEntity extends $PipeBlockEntity<($Insulation), ($WireProperties)> implements $IDataInfoProvider {
static readonly "MANAGED_FIELD_HOLDER": $ManagedFieldHolder
 "level": $Level
 "worldPosition": $BlockPos
 "remove": boolean
 "hasComparators": byte

constructor(type: $BlockEntityType$Type<(any)>, pos: $BlockPos$Type, blockState: $BlockState$Type)

public static "create"(type: $BlockEntityType$Type<(any)>, pos: $BlockPos$Type, blockState: $BlockState$Type): $CableBlockEntity
public "onLoad"(): void
public "getCapability"<T>(cap: $Capability$Type<(T)>, side: $Direction$Type): $LazyOptional<(T)>
public "getTemperature"(): integer
public "setTemperature"(temperature: integer): void
public "getEnergyContainer"(side: $Direction$Type): $IEnergyContainer
public static "onBlockEntityRegister"(cableBlockEntityBlockEntityType: $BlockEntityType$Type<($CableBlockEntity$Type)>): void
public "canAttachTo"(side: $Direction$Type): boolean
public "canHaveBlockedFaces"(): boolean
public "getMaxVoltage"(): long
public "getCurrentMaxVoltage"(): long
public "getPipeTexture"(isBlock: boolean): $ResourceTexture
public "getAverageVoltage"(): double
public "checkNetwork"(): void
public "getMaxAmperage"(): long
public "getDefaultTemp"(): integer
public static "getMeltTemp"(): integer
public "incrementAmperage"(amps: long, voltage: long): boolean
public "applyHeat"(amount: integer): void
public "getPipeTuneTool"(): $GTToolType
public "getAverageAmperage"(): double
public "getFieldHolder"(): $ManagedFieldHolder
public "getDataInfo"(mode: $PortableScannerBehavior$DisplayMode$Type): $List<($Component)>
public "getDebugInfo"(player: $Player$Type, logLevel: integer, mode: $PortableScannerBehavior$DisplayMode$Type): $List<($Component)>
public static "transfer"(original: $AttachmentTarget$Type, target: $AttachmentTarget$Type, isDeath: boolean): void
get "temperature"(): integer
set "temperature"(value: integer)
get "maxVoltage"(): long
get "currentMaxVoltage"(): long
get "averageVoltage"(): double
get "maxAmperage"(): long
get "defaultTemp"(): integer
get "meltTemp"(): integer
get "pipeTuneTool"(): $GTToolType
get "averageAmperage"(): double
get "fieldHolder"(): $ManagedFieldHolder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CableBlockEntity$Type = ($CableBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CableBlockEntity_ = $CableBlockEntity$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/$ShapedEnergyTransferRecipe$Serializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ShapedEnergyTransferRecipe, $ShapedEnergyTransferRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$ShapedEnergyTransferRecipe"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $ShapedEnergyTransferRecipe$Serializer implements $RecipeSerializer<($ShapedEnergyTransferRecipe)> {

constructor()

public "fromJson"(recipeId: $ResourceLocation$Type, json: $JsonObject$Type): $ShapedEnergyTransferRecipe
public "fromNetwork"(recipeId: $ResourceLocation$Type, buffer: $FriendlyByteBuf$Type): $ShapedEnergyTransferRecipe
public "toNetwork"(buffer: $FriendlyByteBuf$Type, recipe: $ShapedEnergyTransferRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $ShapedEnergyTransferRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapedEnergyTransferRecipe$Serializer$Type = ($ShapedEnergyTransferRecipe$Serializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShapedEnergyTransferRecipe$Serializer_ = $ShapedEnergyTransferRecipe$Serializer$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pattern/$MultiblockShapeInfo$ShapeInfoBuilder" {
import {$BlockInfo, $BlockInfo$Type} from "packages/com/lowdragmc/lowdraglib/utils/$BlockInfo"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$MultiblockShapeInfo, $MultiblockShapeInfo$Type} from "packages/com/gregtechceu/gtceu/api/pattern/$MultiblockShapeInfo"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Builder, $Builder$Type} from "packages/com/lowdragmc/lowdraglib/utils/$Builder"
import {$IMachineBlock, $IMachineBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$IMachineBlock"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $MultiblockShapeInfo$ShapeInfoBuilder extends $Builder<($BlockInfo), ($MultiblockShapeInfo$ShapeInfoBuilder)> {

constructor()

public "build"(): $MultiblockShapeInfo
public "where"(symbol: character, machine: $Supplier$Type<(any)>, facing: $Direction$Type): $MultiblockShapeInfo$ShapeInfoBuilder
public "where"(symbol: character, machine: $IMachineBlock$Type, facing: $Direction$Type): $MultiblockShapeInfo$ShapeInfoBuilder
public "where"(symbol: character, blockState: $BlockState$Type): $MultiblockShapeInfo$ShapeInfoBuilder
public "where"(symbol: character, block: $Block$Type): $MultiblockShapeInfo$ShapeInfoBuilder
public "where"(symbol: character, block: $Supplier$Type<(any)>): $MultiblockShapeInfo$ShapeInfoBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiblockShapeInfo$ShapeInfoBuilder$Type = ($MultiblockShapeInfo$ShapeInfoBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiblockShapeInfo$ShapeInfoBuilder_ = $MultiblockShapeInfo$ShapeInfoBuilder$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/content/$ContentModifier" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ContentModifier {

constructor(multiplier: double, addition: double)

public "apply"(number: number): number
public static "of"(multiplier: double, addition: double): $ContentModifier
public static "multiplier"(multiplier: double): $ContentModifier
public static "addition"(addition: double): $ContentModifier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContentModifier$Type = ($ContentModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContentModifier_ = $ContentModifier$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$MaterialProperties" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$IMaterialProperty, $IMaterialProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IMaterialProperty"
import {$PropertyKey, $PropertyKey$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$PropertyKey"

export class $MaterialProperties {

constructor()

public "getProperty"<T extends $IMaterialProperty<(T)>>(key: $PropertyKey$Type<(T)>): T
public "toString"(): string
public "isEmpty"(): boolean
public "setProperty"<T extends $IMaterialProperty<(T)>>(key: $PropertyKey$Type<(T)>, value: $IMaterialProperty$Type<(T)>): void
public "verify"(): void
public "hasProperty"<T extends $IMaterialProperty<(T)>>(key: $PropertyKey$Type<(T)>): boolean
public "removeProperty"<T extends $IMaterialProperty<(T)>>(property: $PropertyKey$Type<(T)>): void
public "setMaterial"(material: $Material$Type): void
public "getMaterial"(): $Material
public "ensureSet"<T extends $IMaterialProperty<(T)>>(key: $PropertyKey$Type<(T)>): void
public "ensureSet"<T extends $IMaterialProperty<(T)>>(key: $PropertyKey$Type<(T)>, verify: boolean): void
public static "addBaseType"(baseTypeKey: $PropertyKey$Type<(any)>): void
get "empty"(): boolean
set "material"(value: $Material$Type)
get "material"(): $Material
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialProperties$Type = ($MaterialProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialProperties_ = $MaterialProperties$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pattern/error/$PatternError" {
import {$MultiblockState, $MultiblockState$Type} from "packages/com/gregtechceu/gtceu/api/pattern/$MultiblockState"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $PatternError {

constructor()

public "getPos"(): $BlockPos
public "getErrorInfo"(): $Component
public "getWorld"(): $Level
public "getCandidates"(): $List<($List<($ItemStack)>)>
public "setWorldState"(worldState: $MultiblockState$Type): void
get "pos"(): $BlockPos
get "errorInfo"(): $Component
get "world"(): $Level
get "candidates"(): $List<($List<($ItemStack)>)>
set "worldState"(value: $MultiblockState$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PatternError$Type = ($PatternError);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PatternError_ = $PatternError$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/explosive/$GTExplosiveBlock" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$LootParams$Builder, $LootParams$Builder$Type} from "packages/net/minecraft/world/level/storage/loot/$LootParams$Builder"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$Explosion, $Explosion$Type} from "packages/net/minecraft/world/level/$Explosion"

export class $GTExplosiveBlock extends $Block {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, canRedstoneActivate: boolean, explodeOnMine: boolean, fuseLength: integer)

public "wasExploded"(level: $Level$Type, pos: $BlockPos$Type, explosion: $Explosion$Type): void
public "dropFromExplosion"(explosion: $Explosion$Type): boolean
public "appendHoverText"(stack: $ItemStack$Type, level: $BlockGetter$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "neighborChanged"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, neighborBlock: $Block$Type, neighborPos: $BlockPos$Type, movedByPiston: boolean): void
public "onPlace"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, oldState: $BlockState$Type, movedByPiston: boolean): void
public "use"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
public "getDrops"(state: $BlockState$Type, params: $LootParams$Builder$Type): $List<($ItemStack)>
public "isCollisionShapeFullBlock"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type): boolean
public "entityInside"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, entity: $Entity$Type): void
public "explode"(world: $Level$Type, pos: $BlockPos$Type, exploder: $LivingEntity$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTExplosiveBlock$Type = ($GTExplosiveBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTExplosiveBlock_ = $GTExplosiveBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/data/$GTRecipeModifiers" {
import {$RecipeModifier, $RecipeModifier$Type} from "packages/com/gregtechceu/gtceu/api/recipe/modifier/$RecipeModifier"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$OverclockingLogic, $OverclockingLogic$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$OverclockingLogic"
import {$GTRecipe, $GTRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe"
import {$MetaMachine, $MetaMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MetaMachine"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$MedicalCondition, $MedicalCondition$Type} from "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$MedicalCondition"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"

export class $GTRecipeModifiers {
static readonly "ELECTRIC_OVERCLOCK": $Function<($OverclockingLogic), ($RecipeModifier)>
static readonly "PARALLEL_HATCH": $RecipeModifier
static readonly "SUBTICK_PARALLEL": $RecipeModifier
static readonly "ENVIRONMENT_REQUIREMENT": $BiFunction<($MedicalCondition), (integer), ($RecipeModifier)>
static readonly "DEFAULT_ENVIRONMENT_REQUIREMENT": $RecipeModifier

constructor()

public static "subtickParallel"(machine: $MetaMachine$Type, recipe: $GTRecipe$Type, modifyDuration: boolean): $GTRecipe
public static "hatchParallel"(machine: $MetaMachine$Type, recipe: $GTRecipe$Type, modifyDuration: boolean): $Pair<($GTRecipe), (integer)>
public static "multiSmelterParallel"(machine: $MetaMachine$Type, recipe: $GTRecipe$Type): $GTRecipe
public static "pyrolyseOvenOverclock"(machine: $MetaMachine$Type, recipe: $GTRecipe$Type): $GTRecipe
public static "fastParallel"(machine: $MetaMachine$Type, recipe: $GTRecipe$Type, maxParallel: integer, modifyDuration: boolean): $Pair<($GTRecipe), (integer)>
public static "accurateParallel"(machine: $MetaMachine$Type, recipe: $GTRecipe$Type, maxParallel: integer, modifyDuration: boolean): $Pair<($GTRecipe), (integer)>
public static "ebfOverclock"(machine: $MetaMachine$Type, recipe: $GTRecipe$Type): $GTRecipe
public static "crackerOverclock"(machine: $MetaMachine$Type, recipe: $GTRecipe$Type): $GTRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTRecipeModifiers$Type = ($GTRecipeModifiers);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTRecipeModifiers_ = $GTRecipeModifiers$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/gui/fancy/$TooltipsPanel" {
import {$IFancyTooltip, $IFancyTooltip$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$IFancyTooltip"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Widget, $Widget$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$Widget"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export class $TooltipsPanel extends $Widget {

constructor()

public "clear"(): void
public "getTooltips"(): $List<($IFancyTooltip)>
public "drawInForeground"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
public "drawInBackground"(graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, partialTicks: float): void
public "attachTooltips"(...tooltips: ($IFancyTooltip$Type)[]): void
get "tooltips"(): $List<($IFancyTooltip)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipsPanel$Type = ($TooltipsPanel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipsPanel_ = $TooltipsPanel$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/$GTWallHangingSignBlock" {
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$WoodType, $WoodType$Type} from "packages/net/minecraft/world/level/block/state/properties/$WoodType"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$WallHangingSignBlock, $WallHangingSignBlock$Type} from "packages/net/minecraft/world/level/block/$WallHangingSignBlock"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"

export class $GTWallHangingSignBlock extends $WallHangingSignBlock {
static readonly "FACING": $DirectionProperty
static readonly "PLANK_NORTHSOUTH": $VoxelShape
static readonly "PLANK_EASTWEST": $VoxelShape
static readonly "SHAPE_NORTHSOUTH": $VoxelShape
static readonly "SHAPE_EASTWEST": $VoxelShape
static readonly "WATERLOGGED": $BooleanProperty
static readonly "AABB_OFFSET": float
static readonly "SHAPE": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, type: $WoodType$Type)

public "getTicker"<T extends $BlockEntity>(level: $Level$Type, state: $BlockState$Type, blockEntityType: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(pos: $BlockPos$Type, state: $BlockState$Type): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTWallHangingSignBlock$Type = ($GTWallHangingSignBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTWallHangingSignBlock_ = $GTWallHangingSignBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/$ResearchRecipeBuilder$StationRecipeBuilder" {
import {$GTRecipeBuilder$ResearchRecipeEntry, $GTRecipeBuilder$ResearchRecipeEntry$Type} from "packages/com/gregtechceu/gtceu/data/recipe/builder/$GTRecipeBuilder$ResearchRecipeEntry"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResearchRecipeBuilder, $ResearchRecipeBuilder$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$ResearchRecipeBuilder"

export class $ResearchRecipeBuilder$StationRecipeBuilder extends $ResearchRecipeBuilder<($ResearchRecipeBuilder$StationRecipeBuilder)> {
static readonly "DEFAULT_STATION_EUT": integer
static readonly "DEFAULT_STATION_TOTAL_CWUT": integer

constructor()

public "build"(): $GTRecipeBuilder$ResearchRecipeEntry
public "getDefaultDataItem"(): $ItemStack
public "CWUt"(cwut: integer, totalCWU: integer): $ResearchRecipeBuilder$StationRecipeBuilder
public "CWUt"(cwut: integer): $ResearchRecipeBuilder$StationRecipeBuilder
get "defaultDataItem"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResearchRecipeBuilder$StationRecipeBuilder$Type = ($ResearchRecipeBuilder$StationRecipeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResearchRecipeBuilder$StationRecipeBuilder_ = $ResearchRecipeBuilder$StationRecipeBuilder$Type;
}}
declare module "packages/com/gregtechceu/gtceu/client/renderer/block/$PipeBlockRenderer" {
import {$ICoverable, $ICoverable$Type} from "packages/com/gregtechceu/gtceu/api/capability/$ICoverable"
import {$ModelState, $ModelState$Type} from "packages/net/minecraft/client/resources/model/$ModelState"
import {$IRenderer, $IRenderer$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IRenderer"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$PipeModel, $PipeModel$Type} from "packages/com/gregtechceu/gtceu/client/model/$PipeModel"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$ICoverableRenderer, $ICoverableRenderer$Type} from "packages/com/gregtechceu/gtceu/client/renderer/cover/$ICoverableRenderer"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ItemDisplayContext, $ItemDisplayContext$Type} from "packages/net/minecraft/world/item/$ItemDisplayContext"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"
import {$BakedQuad, $BakedQuad$Type} from "packages/net/minecraft/client/renderer/block/model/$BakedQuad"

export class $PipeBlockRenderer implements $IRenderer, $ICoverableRenderer {

constructor(pipeModel: $PipeModel$Type)

public "onPrepareTextureAtlas"(atlasName: $ResourceLocation$Type, register: $Consumer$Type<($ResourceLocation$Type)>): void
public "getParticleTexture"(): $TextureAtlasSprite
public "useAO"(): boolean
public "useBlockLight"(stack: $ItemStack$Type): boolean
public "renderItem"(stack: $ItemStack$Type, transformType: $ItemDisplayContext$Type, leftHand: boolean, matrixStack: $PoseStack$Type, buffer: $MultiBufferSource$Type, combinedLight: integer, combinedOverlay: integer, model: $BakedModel$Type): void
public "renderModel"(level: $BlockAndTintGetter$Type, pos: $BlockPos$Type, state: $BlockState$Type, side: $Direction$Type, rand: $RandomSource$Type): $List<($BakedQuad)>
public "getPipeModel"(): $PipeModel
public "render"(blockEntity: $BlockEntity$Type, partialTicks: float, stack: $PoseStack$Type, buffer: $MultiBufferSource$Type, combinedLight: integer, combinedOverlay: integer): void
public "isRaw"(): boolean
public "shouldRender"(blockEntity: $BlockEntity$Type, cameraPos: $Vec3$Type): boolean
public "reBakeCustomQuadsOffset"(): float
public "reBakeCustomQuads"(): boolean
public "isGui3d"(): boolean
public "isGlobalRenderer"(blockEntity: $BlockEntity$Type): boolean
public "hasTESR"(blockEntity: $BlockEntity$Type): boolean
public "useAO"(state: $BlockState$Type): boolean
public "getViewDistance"(): integer
public "registerEvent"(): void
public "onAdditionalModel"(registry: $Consumer$Type<($ResourceLocation$Type)>): void
public "renderCovers"(quads: $List$Type<($BakedQuad$Type)>, side: $Direction$Type, rand: $RandomSource$Type, coverable: $ICoverable$Type, modelFacing: $Direction$Type, pos: $BlockPos$Type, level: $BlockAndTintGetter$Type, modelState: $ModelState$Type): void
get "particleTexture"(): $TextureAtlasSprite
get "pipeModel"(): $PipeModel
get "raw"(): boolean
get "gui3d"(): boolean
get "viewDistance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PipeBlockRenderer$Type = ($PipeBlockRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PipeBlockRenderer_ = $PipeBlockRenderer$Type;
}}
declare module "packages/com/gregtechceu/gtceu/core/mixins/$LootPoolAccessor" {
import {$LootPoolEntryContainer, $LootPoolEntryContainer$Type} from "packages/net/minecraft/world/level/storage/loot/entries/$LootPoolEntryContainer"

export interface $LootPoolAccessor {

 "getEntries"(): ($LootPoolEntryContainer)[]
 "setEntries"(arg0: ($LootPoolEntryContainer$Type)[]): void
}

export namespace $LootPoolAccessor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootPoolAccessor$Type = ($LootPoolAccessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LootPoolAccessor_ = $LootPoolAccessor$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$DustProperty" {
import {$IMaterialProperty, $IMaterialProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IMaterialProperty"
import {$MaterialProperties, $MaterialProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$MaterialProperties"

export class $DustProperty implements $IMaterialProperty<($DustProperty)> {

constructor(harvestLevel: integer, burnTime: integer)
constructor()

public "setBurnTime"(burnTime: integer): void
public "getBurnTime"(): integer
public "verifyProperty"(properties: $MaterialProperties$Type): void
public "getHarvestLevel"(): integer
public "setHarvestLevel"(harvestLevel: integer): void
set "burnTime"(value: integer)
get "burnTime"(): integer
get "harvestLevel"(): integer
set "harvestLevel"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DustProperty$Type = ($DustProperty);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DustProperty_ = $DustProperty$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/registry/registrate/$GTRegistrate" {
import {$IEventBus, $IEventBus$Type} from "packages/net/minecraftforge/eventbus/api/$IEventBus"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$CreativeModeTab$Builder, $CreativeModeTab$Builder$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$Builder"
import {$MultiblockMachineBuilder, $MultiblockMachineBuilder$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$MultiblockMachineBuilder"
import {$MachineDefinition, $MachineDefinition$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MachineDefinition"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Registrate, $Registrate$Type} from "packages/com/tterrag/registrate/$Registrate"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$TriFunction, $TriFunction$Type} from "packages/org/apache/commons/lang3/function/$TriFunction"
import {$IMachineBlockEntity, $IMachineBlockEntity$Type} from "packages/com/gregtechceu/gtceu/api/machine/$IMachineBlockEntity"
import {$MetaMachine, $MetaMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MetaMachine"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$MachineBuilder, $MachineBuilder$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$MachineBuilder"
import {$IMachineBlock, $IMachineBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$IMachineBlock"
import {$MetaMachineItem, $MetaMachineItem$Type} from "packages/com/gregtechceu/gtceu/api/item/$MetaMachineItem"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$NoConfigBuilder, $NoConfigBuilder$Type} from "packages/com/tterrag/registrate/builders/$NoConfigBuilder"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemBuilder, $ItemBuilder$Type} from "packages/com/tterrag/registrate/builders/$ItemBuilder"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$SoundEntryBuilder, $SoundEntryBuilder$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$SoundEntryBuilder"
import {$IGTFluidBuilder, $IGTFluidBuilder$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$IGTFluidBuilder"
import {$MultiblockMachineDefinition, $MultiblockMachineDefinition$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MultiblockMachineDefinition"
import {$RegistryEntry, $RegistryEntry$Type} from "packages/com/tterrag/registrate/util/entry/$RegistryEntry"
import {$NonNullFunction, $NonNullFunction$Type} from "packages/com/tterrag/registrate/util/nullness/$NonNullFunction"

export class $GTRegistrate extends $Registrate {


public static "create"(modId: string): $GTRegistrate
public "item"<T extends $Item>(name: string, factory: $NonNullFunction$Type<($Item$Properties$Type), (T)>): $ItemBuilder<(T), ($Registrate)>
public static "fluid"(parent: $GTRegistrate$Type, material: $Material$Type, name: string, langKey: string, stillTexture: $ResourceLocation$Type, flowingTexture: $ResourceLocation$Type): $IGTFluidBuilder
public "registerRegistrate"(): void
public "multiblock"(name: string, metaMachine: $Function$Type<($IMachineBlockEntity$Type), (any)>, blockFactory: $BiFunction$Type<($BlockBehaviour$Properties$Type), ($MultiblockMachineDefinition$Type), ($IMachineBlock$Type)>, itemFactory: $BiFunction$Type<($IMachineBlock$Type), ($Item$Properties$Type), ($MetaMachineItem$Type)>, blockEntityFactory: $TriFunction$Type<($BlockEntityType$Type<(any)>), ($BlockPos$Type), ($BlockState$Type), ($IMachineBlockEntity$Type)>): $MultiblockMachineBuilder
public "multiblock"(name: string, metaMachine: $Function$Type<($IMachineBlockEntity$Type), (any)>): $MultiblockMachineBuilder
public "machine"(name: string, metaMachine: $Function$Type<($IMachineBlockEntity$Type), ($MetaMachine$Type)>): $MachineBuilder<($MachineDefinition)>
public "machine"<DEFINITION extends $MachineDefinition>(name: string, definitionFactory: $Function$Type<($ResourceLocation$Type), (DEFINITION)>, metaMachine: $Function$Type<($IMachineBlockEntity$Type), ($MetaMachine$Type)>, blockFactory: $BiFunction$Type<($BlockBehaviour$Properties$Type), (DEFINITION), ($IMachineBlock$Type)>, itemFactory: $BiFunction$Type<($IMachineBlock$Type), ($Item$Properties$Type), ($MetaMachineItem$Type)>, blockEntityFactory: $TriFunction$Type<($BlockEntityType$Type<(any)>), ($BlockPos$Type), ($BlockState$Type), ($IMachineBlockEntity$Type)>): $MachineBuilder<(DEFINITION)>
public "machine"(name: string, metaMachine: $BiFunction$Type<($IMachineBlockEntity$Type), (integer), ($MetaMachine$Type)>, ...tiers: (integer)[]): $Stream<($MachineBuilder<($MachineDefinition)>)>
public "defaultCreativeTab"<P>(parent: P, name: string, config: $Consumer$Type<($CreativeModeTab$Builder$Type)>): $NoConfigBuilder<($CreativeModeTab), ($CreativeModeTab), (P)>
public "sound"(name: $ResourceLocation$Type): $SoundEntryBuilder
public "sound"(name: string): $SoundEntryBuilder
public "registerEventListeners"(bus: $IEventBus$Type): $Registrate
public "setCreativeTab"(entry: $RegistryEntry$Type<(any)>, tab: $RegistryEntry$Type<($CreativeModeTab$Type)>): void
public "creativeModeTab"(currentTab: $RegistryEntry$Type<($CreativeModeTab$Type)>): void
public "creativeModeTab"(currentTab: $Supplier$Type<($RegistryEntry$Type<($CreativeModeTab$Type)>)>): void
public "isInCreativeTab"(entry: $RegistryEntry$Type<(any)>, tab: $RegistryEntry$Type<($CreativeModeTab$Type)>): boolean
public "createFluid"(name: string, langKey: string, material: $Material$Type, stillTexture: $ResourceLocation$Type, flowingTexture: $ResourceLocation$Type): $IGTFluidBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTRegistrate$Type = ($GTRegistrate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTRegistrate_ = $GTRegistrate$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$PropertyKey" {
import {$FluidProperty, $FluidProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$FluidProperty"
import {$ItemPipeProperties, $ItemPipeProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$ItemPipeProperties"
import {$IMaterialProperty, $IMaterialProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IMaterialProperty"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$IngotProperty, $IngotProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IngotProperty"
import {$BlastProperty, $BlastProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$BlastProperty"
import {$WireProperties, $WireProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$WireProperties"
import {$OreProperty, $OreProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$OreProperty"
import {$AlloyBlastProperty, $AlloyBlastProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$AlloyBlastProperty"
import {$GemProperty, $GemProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$GemProperty"
import {$WoodProperty, $WoodProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$WoodProperty"
import {$ToolProperty, $ToolProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$ToolProperty"
import {$PolymerProperty, $PolymerProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$PolymerProperty"
import {$DustProperty, $DustProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$DustProperty"
import {$FluidPipeProperties, $FluidPipeProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$FluidPipeProperties"
import {$RotorProperty, $RotorProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$RotorProperty"
import {$PropertyKey$EmptyProperty, $PropertyKey$EmptyProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$PropertyKey$EmptyProperty"
import {$HazardProperty, $HazardProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$HazardProperty"

export class $PropertyKey<T extends $IMaterialProperty<(T)>> {
static readonly "BLAST": $PropertyKey<($BlastProperty)>
static readonly "ALLOY_BLAST": $PropertyKey<($AlloyBlastProperty)>
static readonly "DUST": $PropertyKey<($DustProperty)>
static readonly "FLUID_PIPE": $PropertyKey<($FluidPipeProperties)>
static readonly "FLUID": $PropertyKey<($FluidProperty)>
static readonly "GEM": $PropertyKey<($GemProperty)>
static readonly "INGOT": $PropertyKey<($IngotProperty)>
static readonly "POLYMER": $PropertyKey<($PolymerProperty)>
static readonly "ITEM_PIPE": $PropertyKey<($ItemPipeProperties)>
static readonly "ORE": $PropertyKey<($OreProperty)>
static readonly "TOOL": $PropertyKey<($ToolProperty)>
static readonly "ROTOR": $PropertyKey<($RotorProperty)>
static readonly "WIRE": $PropertyKey<($WireProperties)>
static readonly "WOOD": $PropertyKey<($WoodProperty)>
static readonly "HAZARD": $PropertyKey<($HazardProperty)>
static readonly "EMPTY": $PropertyKey<($PropertyKey$EmptyProperty)>

constructor(key: string, type: $Class$Type<(T)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "cast"(property: $IMaterialProperty$Type<(any)>): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PropertyKey$Type<T> = ($PropertyKey<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PropertyKey_<T> = $PropertyKey$Type<(T)>;
}}
declare module "packages/com/gregtechceu/gtceu/core/mixins/$RecipeManagerAccessor" {
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $RecipeManagerAccessor {

 "getRawRecipes"(): $Map<($RecipeType<(any)>), ($Map<($ResourceLocation), ($Recipe<(any)>)>)>
 "setRawRecipes"(arg0: $Map$Type<($RecipeType$Type<(any)>), ($Map$Type<($ResourceLocation$Type), ($Recipe$Type<(any)>)>)>): void
}

export namespace $RecipeManagerAccessor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeManagerAccessor$Type = ($RecipeManagerAccessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeManagerAccessor_ = $RecipeManagerAccessor$Type;
}}
declare module "packages/com/gregtechceu/gtceu/core/mixins/$ITrunkPlacerTypeAccessor" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $ITrunkPlacerTypeAccessor {

}

export namespace $ITrunkPlacerTypeAccessor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITrunkPlacerTypeAccessor$Type = ($ITrunkPlacerTypeAccessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITrunkPlacerTypeAccessor_ = $ITrunkPlacerTypeAccessor$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/feature/$ICleanroomProvider" {
import {$CleanroomType, $CleanroomType$Type} from "packages/com/gregtechceu/gtceu/api/machine/multiblock/$CleanroomType"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$IMachineFeature, $IMachineFeature$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/$IMachineFeature"
import {$MetaMachine, $MetaMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MetaMachine"

export interface $ICleanroomProvider extends $IMachineFeature {

 "getTypes"(): $Set<($CleanroomType)>
 "isClean"(): boolean
 "self"(): $MetaMachine
}

export namespace $ICleanroomProvider {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICleanroomProvider$Type = ($ICleanroomProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICleanroomProvider_ = $ICleanroomProvider$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/block/$PipeBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$EntityBlock, $EntityBlock$Type} from "packages/net/minecraft/world/level/block/$EntityBlock"
import {$AppearanceBlock, $AppearanceBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$AppearanceBlock"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$IPipeNode, $IPipeNode$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeNode"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$PipeBlockRenderer, $PipeBlockRenderer$Type} from "packages/com/gregtechceu/gtceu/client/renderer/block/$PipeBlockRenderer"
import {$IPipeType, $IPipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeType"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$IBlockRendererProvider, $IBlockRendererProvider$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IBlockRendererProvider"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$PipeBlockEntity, $PipeBlockEntity$Type} from "packages/com/gregtechceu/gtceu/api/blockentity/$PipeBlockEntity"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$LootParams$Builder, $LootParams$Builder$Type} from "packages/net/minecraft/world/level/storage/loot/$LootParams$Builder"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$LevelPipeNet, $LevelPipeNet$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$LevelPipeNet"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export class $PipeBlock<PipeType extends ($Enum<(PipeType)>) & ($IPipeType<(NodeDataType)>), NodeDataType, WorldPipeNetType extends $LevelPipeNet<(NodeDataType), (any)>> extends $AppearanceBlock implements $EntityBlock, $IBlockRendererProvider, $SimpleWaterloggedBlock {
readonly "pipeType": PipeType
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, pipeType: PipeType)

public "createProperties"(arg0: $IPipeNode$Type<(PipeType), (NodeDataType)>): NodeDataType
public "createProperties"(state: $BlockState$Type, stack: $ItemStack$Type): NodeDataType
public "getBlockEntityType"(): $BlockEntityType<(any)>
public "getTicker"<T extends $BlockEntity>(level: $Level$Type, state: $BlockState$Type, blockEntityType: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "destroy"(level: $LevelAccessor$Type, pos: $BlockPos$Type, state: $BlockState$Type): void
public "setPlacedBy"(level: $Level$Type, pos: $BlockPos$Type, state: $BlockState$Type, placer: $LivingEntity$Type, stack: $ItemStack$Type): void
public "neighborChanged"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, block: $Block$Type, fromPos: $BlockPos$Type, isMoving: boolean): void
public "onPlace"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, oldState: $BlockState$Type, isMoving: boolean): void
public "updateShape"(state: $BlockState$Type, direction: $Direction$Type, neighborState: $BlockState$Type, level: $LevelAccessor$Type, pos: $BlockPos$Type, neighborPos: $BlockPos$Type): $BlockState
public "getFluidState"(state: $BlockState$Type): $FluidState
public "use"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
public "onRemove"(pState: $BlockState$Type, pLevel: $Level$Type, pPos: $BlockPos$Type, pNewState: $BlockState$Type, pIsMoving: boolean): void
public "getDrops"(state: $BlockState$Type, builder: $LootParams$Builder$Type): $List<($ItemStack)>
public "getCollisionShape"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type, context: $CollisionContext$Type): $VoxelShape
public "isCollisionShapeFullBlock"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type): boolean
public "getShape"(pState: $BlockState$Type, pLevel: $BlockGetter$Type, pPos: $BlockPos$Type, context: $CollisionContext$Type): $VoxelShape
public "tick"(state: $BlockState$Type, level: $ServerLevel$Type, pos: $BlockPos$Type, random: $RandomSource$Type): void
public "entityInside"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, entity: $Entity$Type): void
public "getRenderer"(arg0: $BlockState$Type): $PipeBlockRenderer
public "canConnect"(selfTile: $IPipeNode$Type<(PipeType), (NodeDataType)>, facing: $Direction$Type): boolean
public "newBlockEntity"(pos: $BlockPos$Type, state: $BlockState$Type): $PipeBlockEntity<(PipeType), (NodeDataType)>
public "onNeighborChange"(state: $BlockState$Type, level: $LevelReader$Type, pos: $BlockPos$Type, neighbor: $BlockPos$Type): void
public "getBlockAppearance"(state: $BlockState$Type, level: $BlockAndTintGetter$Type, pos: $BlockPos$Type, side: $Direction$Type, sourceState: $BlockState$Type, sourcePos: $BlockPos$Type): $BlockState
public "updateActiveNodeStatus"(worldIn: $Level$Type, pos: $BlockPos$Type, pipeTile: $IPipeNode$Type<(PipeType), (NodeDataType)>): void
public "canPipeConnectToBlock"(arg0: $IPipeNode$Type<(PipeType), (NodeDataType)>, arg1: $Direction$Type, arg2: $BlockEntity$Type): boolean
public "getPipeTile"(level: $BlockGetter$Type, pos: $BlockPos$Type): $IPipeNode<(PipeType), (NodeDataType)>
public "getWorldPipeNet"(arg0: $ServerLevel$Type): WorldPipeNetType
public "createRawData"(arg0: $BlockState$Type, arg1: $ItemStack$Type): NodeDataType
public "getFallbackType"(): NodeDataType
public "canPipesConnect"(arg0: $IPipeNode$Type<(PipeType), (NodeDataType)>, arg1: $Direction$Type, arg2: $IPipeNode$Type<(PipeType), (NodeDataType)>): boolean
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
public "getLightMap"(world: $BlockAndTintGetter$Type, state: $BlockState$Type, pos: $BlockPos$Type): integer
public "canPlaceLiquid"(arg0: $BlockGetter$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $Fluid$Type): boolean
public "pickupBlock"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type): $ItemStack
public "placeLiquid"(arg0: $LevelAccessor$Type, arg1: $BlockPos$Type, arg2: $BlockState$Type, arg3: $FluidState$Type): boolean
public "getPickupSound"(): $Optional<($SoundEvent)>
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "blockEntityType"(): $BlockEntityType<(any)>
get "fallbackType"(): NodeDataType
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PipeBlock$Type<PipeType, NodeDataType, WorldPipeNetType> = ($PipeBlock<(PipeType), (NodeDataType), (WorldPipeNetType)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PipeBlock_<PipeType, NodeDataType, WorldPipeNetType> = $PipeBlock$Type<(PipeType), (NodeDataType), (WorldPipeNetType)>;
}}
declare module "packages/com/gregtechceu/gtceu/api/capability/$IEnergyContainer" {
import {$IEnergyInfoProvider, $IEnergyInfoProvider$Type} from "packages/com/gregtechceu/gtceu/api/capability/$IEnergyInfoProvider"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IEnergyInfoProvider$EnergyInfo, $IEnergyInfoProvider$EnergyInfo$Type} from "packages/com/gregtechceu/gtceu/api/capability/$IEnergyInfoProvider$EnergyInfo"

export interface $IEnergyContainer extends $IEnergyInfoProvider {

 "getEnergyStored"(): long
 "getEnergyInfo"(): $IEnergyInfoProvider$EnergyInfo
 "supportsBigIntEnergyValues"(): boolean
 "getEnergyCanBeInserted"(): long
 "getEnergyCapacity"(): long
 "getInputAmperage"(): long
 "getOutputAmperage"(): long
 "changeEnergy"(arg0: long): long
 "addEnergy"(energyToAdd: long): long
 "inputsEnergy"(arg0: $Direction$Type): boolean
 "isOneProbeHidden"(): boolean
 "getInputPerSec"(): long
 "getOutputPerSec"(): long
 "outputsEnergy"(side: $Direction$Type): boolean
 "removeEnergy"(energyToRemove: long): long
 "getOutputVoltage"(): long
 "getInputVoltage"(): long
 "acceptEnergyFromNetwork"(arg0: $Direction$Type, arg1: long, arg2: long): long
}

export namespace $IEnergyContainer {
const DEFAULT: $IEnergyContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEnergyContainer$Type = ($IEnergyContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IEnergyContainer_ = $IEnergyContainer$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/$LaserPipeBlock" {
import {$BlockColor, $BlockColor$Type} from "packages/net/minecraft/client/color/block/$BlockColor"
import {$LaserPipeType, $LaserPipeType$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/laser/$LaserPipeType"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$PipeModel, $PipeModel$Type} from "packages/com/gregtechceu/gtceu/client/model/$PipeModel"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$LaserPipeProperties, $LaserPipeProperties$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/laser/$LaserPipeProperties"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$LevelLaserPipeNet, $LevelLaserPipeNet$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/laser/$LevelLaserPipeNet"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$IPipeNode, $IPipeNode$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeNode"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$PipeBlock, $PipeBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$PipeBlock"
import {$PipeBlockRenderer, $PipeBlockRenderer$Type} from "packages/com/gregtechceu/gtceu/client/renderer/block/$PipeBlockRenderer"
import {$IPipeType, $IPipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeType"

export class $LaserPipeBlock extends $PipeBlock<($LaserPipeType), ($LaserPipeProperties), ($LevelLaserPipeNet)> {
readonly "renderer": $PipeBlockRenderer
readonly "model": $PipeModel
readonly "pipeType": PipeType
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, type: $LaserPipeType$Type)

public "createProperties"(pipeTile: $IPipeNode$Type<($LaserPipeType$Type), ($LaserPipeProperties$Type)>): $LaserPipeProperties
public "getBlockEntityType"(): $BlockEntityType<(any)>
public "getRenderer"(state: $BlockState$Type): $PipeBlockRenderer
public "canPipeConnectToBlock"(selfTile: $IPipeNode$Type<($LaserPipeType$Type), ($LaserPipeProperties$Type)>, side: $Direction$Type, tile: $BlockEntity$Type): boolean
public static "tintedColor"(): $BlockColor
public "canPipesConnect"(selfTile: $IPipeNode$Type<($LaserPipeType$Type), ($LaserPipeProperties$Type)>, side: $Direction$Type, sideTile: $IPipeNode$Type<($LaserPipeType$Type), ($LaserPipeProperties$Type)>): boolean
get "blockEntityType"(): $BlockEntityType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LaserPipeBlock$Type = ($LaserPipeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LaserPipeBlock_ = $LaserPipeBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/core/mixins/$AbstractRegistrateAccessor" {
import {$ProviderType, $ProviderType$Type} from "packages/com/tterrag/registrate/providers/$ProviderType"
import {$NonNullConsumer, $NonNullConsumer$Type} from "packages/com/tterrag/registrate/util/nullness/$NonNullConsumer"
import {$ListMultimap, $ListMultimap$Type} from "packages/com/google/common/collect/$ListMultimap"
import {$NonNullSupplier, $NonNullSupplier$Type} from "packages/com/tterrag/registrate/util/nullness/$NonNullSupplier"

export interface $AbstractRegistrateAccessor {

 "getDoDatagen"(): $NonNullSupplier<(boolean)>
 "getDatagens"(): $ListMultimap<($ProviderType<(any)>), ($NonNullConsumer<(any)>)>
}

export namespace $AbstractRegistrateAccessor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractRegistrateAccessor$Type = ($AbstractRegistrateAccessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractRegistrateAccessor_ = $AbstractRegistrateAccessor$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$FluidStorageKey, $FluidStorageKey$Type} from "packages/com/gregtechceu/gtceu/api/fluids/store/$FluidStorageKey"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$MaterialStack, $MaterialStack$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/stack/$MaterialStack"
import {$IMaterialProperty, $IMaterialProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IMaterialProperty"
import {$MaterialProperties, $MaterialProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$MaterialProperties"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Material$MaterialInfo, $Material$MaterialInfo$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material$MaterialInfo"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"
import {$MaterialIconSet, $MaterialIconSet$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/info/$MaterialIconSet"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$FluidStack, $FluidStack$Type} from "packages/com/lowdragmc/lowdraglib/side/fluid/$FluidStack"
import {$ImmutableList, $ImmutableList$Type} from "packages/com/google/common/collect/$ImmutableList"
import {$MaterialFlag, $MaterialFlag$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/info/$MaterialFlag"
import {$MaterialToolTier, $MaterialToolTier$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$MaterialToolTier"
import {$FluidBuilder, $FluidBuilder$Type} from "packages/com/gregtechceu/gtceu/api/fluids/$FluidBuilder"
import {$Element, $Element$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/$Element"
import {$PropertyKey, $PropertyKey$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$PropertyKey"

export class $Material implements $Comparable<($Material)> {


public "getName"(): string
public "getProperty"<T extends $IMaterialProperty<(T)>>(key: $PropertyKey$Type<(T)>): T
public "toString"(): string
public "compareTo"(material: $Material$Type): integer
public "setProperty"<T extends $IMaterialProperty<(T)>>(key: $PropertyKey$Type<(T)>, property: $IMaterialProperty$Type<(T)>): void
public "getProperties"(): $MaterialProperties
public "multiply"(amount: long): $MaterialStack
public "getLocalizedName"(): $MutableComponent
public "getElement"(): $Element
public "hasProperty"<T extends $IMaterialProperty<(T)>>(key: $PropertyKey$Type<(T)>): boolean
public "setComponents"(...components: ($MaterialStack$Type)[]): $Material
public "hasFlags"(...flags: ($MaterialFlag$Type)[]): boolean
public "getMass"(): long
public "getToolTier"(): $MaterialToolTier
public "addFlags"(...flags: ($MaterialFlag$Type)[]): void
public "getFluid"(key: $FluidStorageKey$Type, amount: long): $FluidStack
public "getFluid"(amount: long): $FluidStack
public "getFluid"(): $Fluid
public "getFluid"(key: $FluidStorageKey$Type): $Fluid
public "getBucket"(): $Item
public "isSolid"(): boolean
public "hasFluid"(): boolean
public "hasFlag"(flag: $MaterialFlag$Type): boolean
public "getResourceLocation"(): $ResourceLocation
public "getModid"(): string
public "verifyMaterial"(): void
public "setFormula"(formula: string): $Material
public "setFormula"(formula: string, withFormatting: boolean): $Material
public "getChemicalFormula"(): string
public "getFluidTag"(): $TagKey<($Fluid)>
public "getFluidBuilder"(): $FluidBuilder
public "getFluidBuilder"(key: $FluidStorageKey$Type): $FluidBuilder
public "hasAnyOfFlags"(...flags: ($MaterialFlag$Type)[]): boolean
public "isElement"(): boolean
public "getProtons"(): long
public "setMaterialIconSet"(materialIconSet: $MaterialIconSet$Type): void
public "hasFluidColor"(): boolean
public "getMaterialARGB"(index: integer): integer
public "getMaterialARGB"(): integer
public "getHotFluid"(amount: long): $FluidStack
public "getHotFluid"(): $Fluid
public "getMaterialRGB"(): integer
public "getMaterialRGB"(index: integer): integer
public "getLayerARGB"(layerIndex: integer): integer
public "getMaterialIconSet"(): $MaterialIconSet
public "setMaterialARGB"(materialRGB: integer): void
public "isRadioactive"(): boolean
public "getNeutrons"(): long
public "getUnlocalizedName"(): string
public "toCamelCaseString"(): string
public "getMaterialInfo"(): $Material$MaterialInfo
public "getMaterialComponents"(): $ImmutableList<($MaterialStack)>
public "setMaterialSecondaryARGB"(materialRGB: integer): void
public "getBlastTemperature"(): integer
public "getMaterialSecondaryRGB"(): integer
public "getBlockHarvestLevel"(): integer
public "getMaterialSecondaryARGB"(): integer
public "getToolHarvestLevel"(): integer
get "name"(): string
get "properties"(): $MaterialProperties
get "localizedName"(): $MutableComponent
get "element"(): $Element
set "components"(value: ($MaterialStack$Type)[])
get "mass"(): long
get "toolTier"(): $MaterialToolTier
get "fluid"(): $Fluid
get "bucket"(): $Item
get "solid"(): boolean
get "resourceLocation"(): $ResourceLocation
get "modid"(): string
set "formula"(value: string)
get "chemicalFormula"(): string
get "fluidTag"(): $TagKey<($Fluid)>
get "fluidBuilder"(): $FluidBuilder
get "element"(): boolean
get "protons"(): long
set "materialIconSet"(value: $MaterialIconSet$Type)
get "materialARGB"(): integer
get "hotFluid"(): $Fluid
get "materialRGB"(): integer
get "materialIconSet"(): $MaterialIconSet
set "materialARGB"(value: integer)
get "radioactive"(): boolean
get "neutrons"(): long
get "unlocalizedName"(): string
get "materialInfo"(): $Material$MaterialInfo
get "materialComponents"(): $ImmutableList<($MaterialStack)>
set "materialSecondaryARGB"(value: integer)
get "blastTemperature"(): integer
get "materialSecondaryRGB"(): integer
get "blockHarvestLevel"(): integer
get "materialSecondaryARGB"(): integer
get "toolHarvestLevel"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Material$Type = ($Material);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Material_ = $Material$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/item/longdistance/$LDItemPipeType" {
import {$LongDistancePipeType, $LongDistancePipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/longdistance/$LongDistancePipeType"

export class $LDItemPipeType extends $LongDistancePipeType {
static readonly "INSTANCE": $LDItemPipeType


public "getMinLength"(): integer
get "minLength"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LDItemPipeType$Type = ($LDItemPipeType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LDItemPipeType_ = $LDItemPipeType$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/$WorldGenLayers" {
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$Type} from "packages/net/minecraft/util/$StringRepresentable$EnumCodec"
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$RuleTest, $RuleTest$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$RuleTest"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IWorldGenLayer, $IWorldGenLayer$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$IWorldGenLayer"

export class $WorldGenLayers extends $Enum<($WorldGenLayers)> implements $IWorldGenLayer, $StringRepresentable {
static readonly "STONE": $WorldGenLayers
static readonly "DEEPSLATE": $WorldGenLayers
static readonly "NETHERRACK": $WorldGenLayers
static readonly "ENDSTONE": $WorldGenLayers


public static "values"(): ($WorldGenLayers)[]
public static "valueOf"(name: string): $WorldGenLayers
public "getTarget"(): $RuleTest
public "setTarget"(target: $RuleTest$Type): void
public static "getByName"(name: string): $IWorldGenLayer
public "getLevels"(): $Set<($ResourceLocation)>
public "setLevels"(levels: $Set$Type<($ResourceLocation$Type)>): void
public static "registerAll"(): void
public "getSerializedName"(): string
public "isApplicableForLevel"(level: $ResourceLocation$Type): boolean
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>, arg1: $Function$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$Type)[]): $Keyable
get "target"(): $RuleTest
set "target"(value: $RuleTest$Type)
get "levels"(): $Set<($ResourceLocation)>
set "levels"(value: $Set$Type<($ResourceLocation$Type)>)
get "serializedName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldGenLayers$Type = (("deepslate") | ("endstone") | ("netherrack") | ("stone")) | ($WorldGenLayers);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WorldGenLayers_ = $WorldGenLayers$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pipenet/longdistance/$LongDistancePipeType" {
import {$ILDEndpoint, $ILDEndpoint$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/longdistance/$ILDEndpoint"
import {$LDFluidPipeType, $LDFluidPipeType$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/fluidpipe/longdistance/$LDFluidPipeType"
import {$LongDistanceNetwork$WorldData, $LongDistanceNetwork$WorldData$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/longdistance/$LongDistanceNetwork$WorldData"
import {$ILDNetworkPart, $ILDNetworkPart$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/longdistance/$ILDNetworkPart"
import {$LDItemPipeType, $LDItemPipeType$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/item/longdistance/$LDItemPipeType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$LongDistanceNetwork, $LongDistanceNetwork$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/longdistance/$LongDistanceNetwork"

export class $LongDistancePipeType {


public "getName"(): string
public static "item"(): $LDItemPipeType
public "getMinLength"(): integer
public static "fluid"(): $LDFluidPipeType
public static "getPipeType"(name: string): $LongDistancePipeType
public "isValidPart"(networkPart: $ILDNetworkPart$Type): boolean
public "createNetwork"(worldData: $LongDistanceNetwork$WorldData$Type): $LongDistanceNetwork
public "createNetwork"(world: $Level$Type): $LongDistanceNetwork
public "satisfiesMinLength"(endpoint1: $ILDEndpoint$Type, endpoint2: $ILDEndpoint$Type): boolean
get "name"(): string
get "minLength"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongDistancePipeType$Type = ($LongDistancePipeType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongDistancePipeType_ = $LongDistancePipeType$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/bedrockore/$BedrockOreDefinition" {
import {$MapCodec, $MapCodec$Type} from "packages/com/mojang/serialization/$MapCodec"
import {$BiomeWeightModifier, $BiomeWeightModifier$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$BiomeWeightModifier"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$BedrockOreDefinition$Builder, $BedrockOreDefinition$Builder$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/bedrockore/$BedrockOreDefinition$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IntProvider, $IntProvider$Type} from "packages/net/minecraft/util/valueproviders/$IntProvider"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"

export class $BedrockOreDefinition {
static readonly "MATERIAL": $MapCodec<($Pair<($Material), (integer)>)>
static readonly "FULL_CODEC": $Codec<($BedrockOreDefinition)>
 "dimensionFilter": $Set<($ResourceKey<($Level)>)>

constructor(name: $ResourceLocation$Type, size: integer, weight: integer, arg3: $IntProvider$Type, depletionAmount: integer, depletionChance: integer, depletedYield: integer, materials: $List$Type<($Pair$Type<($Material$Type), (integer)>)>, originalModifiers: $List$Type<($BiomeWeightModifier$Type)>, dimensionFilter: $Set$Type<($ResourceKey$Type<($Level$Type)>)>)
constructor(weight: integer, size: integer, arg2: $IntProvider$Type, depletionAmount: integer, depletionChance: integer, depletedYield: integer, materials: $List$Type<($Pair$Type<($Material$Type), (integer)>)>, originalModifiers: $List$Type<($BiomeWeightModifier$Type)>, dimensionFilter: $Set$Type<($ResourceKey$Type<($Level$Type)>)>)

public "size"(size: integer): $BedrockOreDefinition
public "size"(): integer
public static "builder"(name: $ResourceLocation$Type): $BedrockOreDefinition$Builder
public "yield"(): $IntProvider
public "yield"(arg0: $IntProvider$Type): $BedrockOreDefinition
public "weight"(): integer
public "weight"(weight: integer): $BedrockOreDefinition
public "materials"(): $List<($Pair<($Material), (integer)>)>
public "materials"(materials: $List$Type<($Pair$Type<($Material$Type), (integer)>)>): $BedrockOreDefinition
public "biomeWeightModifier"(): $BiomeWeightModifier
public "dimensionFilter"(dimensionFilter: $Set$Type<($ResourceKey$Type<($Level$Type)>)>): $BedrockOreDefinition
public "dimensionFilter"(): $Set<($ResourceKey<($Level)>)>
public "depletedYield"(depletedYield: integer): $BedrockOreDefinition
public "depletedYield"(): integer
public "depletionAmount"(depletionAmount: integer): $BedrockOreDefinition
public "depletionAmount"(): integer
public "depletionChance"(depletionChance: integer): $BedrockOreDefinition
public "depletionChance"(): integer
public "setOriginalModifiers"(modifiers: $List$Type<($BiomeWeightModifier$Type)>): void
set "originalModifiers"(value: $List$Type<($BiomeWeightModifier$Type)>)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BedrockOreDefinition$Type = ($BedrockOreDefinition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BedrockOreDefinition_ = $BedrockOreDefinition$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTOreDefinition" {
import {$HolderSet, $HolderSet$Type} from "packages/net/minecraft/core/$HolderSet"
import {$BiomeWeightModifier, $BiomeWeightModifier$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$BiomeWeightModifier"
import {$SurfaceIndicatorGenerator, $SurfaceIndicatorGenerator$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/indicators/$SurfaceIndicatorGenerator"
import {$VeinedVeinGenerator, $VeinedVeinGenerator$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$VeinedVeinGenerator"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$IndicatorGenerator, $IndicatorGenerator$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/$IndicatorGenerator"
import {$IWorldGenLayer, $IWorldGenLayer$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$IWorldGenLayer"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$GeodeVeinGenerator, $GeodeVeinGenerator$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$GeodeVeinGenerator"
import {$Biome, $Biome$Type} from "packages/net/minecraft/world/level/biome/$Biome"
import {$IntProvider, $IntProvider$Type} from "packages/net/minecraft/util/valueproviders/$IntProvider"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$LayeredVeinGenerator, $LayeredVeinGenerator$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$LayeredVeinGenerator"
import {$StandardVeinGenerator, $StandardVeinGenerator$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$StandardVeinGenerator"
import {$ClassicVeinGenerator, $ClassicVeinGenerator$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$ClassicVeinGenerator"
import {$CuboidVeinGenerator, $CuboidVeinGenerator$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$CuboidVeinGenerator"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$HeightRangePlacement, $HeightRangePlacement$Type} from "packages/net/minecraft/world/level/levelgen/placement/$HeightRangePlacement"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$DikeVeinGenerator, $DikeVeinGenerator$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$DikeVeinGenerator"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$VeinGenerator, $VeinGenerator$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/$VeinGenerator"

export class $GTOreDefinition {
static readonly "CODEC": $Codec<($GTOreDefinition)>
static readonly "FULL_CODEC": $Codec<($GTOreDefinition)>

constructor(other: $GTOreDefinition$Type)
constructor(clusterSize: $IntProvider$Type, density: float, weight: integer, layer: $IWorldGenLayer$Type, dimensionFilter: $Set$Type<($ResourceKey$Type<($Level$Type)>)>, range: $HeightRangePlacement$Type, discardChanceOnAirExposure: float, biomes: $Supplier$Type<($HolderSet$Type<($Biome$Type)>)>, biomeWeightModifier: $BiomeWeightModifier$Type, veinGenerator: $VeinGenerator$Type, indicatorGenerators: $List$Type<($IndicatorGenerator$Type)>)

public "dimensions"(...dimensions: ($ResourceLocation$Type)[]): $GTOreDefinition
public "layer"(): $IWorldGenLayer
public "layer"(layer: $IWorldGenLayer$Type): $GTOreDefinition
public "range"(range: $HeightRangePlacement$Type): $GTOreDefinition
public "range"(): $HeightRangePlacement
public "weight"(weight: integer): $GTOreDefinition
public "weight"(): integer
public "density"(density: float): $GTOreDefinition
public "density"(): float
public "discardChanceOnAirExposure"(): float
public "discardChanceOnAirExposure"(discardChanceOnAirExposure: float): $GTOreDefinition
public "biomes"(first: string, ...biomes: (string)[]): $GTOreDefinition
public "biomes"(biomes: $TagKey$Type<($Biome$Type)>): $GTOreDefinition
public "biomes"(biomes: $Supplier$Type<($HolderSet$Type<($Biome$Type)>)>): $GTOreDefinition
public "biomes"(): $Supplier<($HolderSet<($Biome)>)>
public "heightRangeTriangle"(min: integer, max: integer): $GTOreDefinition
public "cuboidVeinGenerator"(config: $Consumer$Type<($CuboidVeinGenerator$Type)>): $GTOreDefinition
public "veinedVeinGenerator"(config: $Consumer$Type<($VeinedVeinGenerator$Type)>): $GTOreDefinition
public "layeredVeinGenerator"(config: $Consumer$Type<($LayeredVeinGenerator$Type)>): $GTOreDefinition
public "classicVeinGenerator"(config: $Consumer$Type<($ClassicVeinGenerator$Type)>): $GTOreDefinition
public "indicatorGenerators"(): $List<($IndicatorGenerator)>
public "indicatorGenerators"(indicatorGenerators: $List$Type<($IndicatorGenerator$Type)>): $GTOreDefinition
public "biomeWeightModifier"(): $BiomeWeightModifier
public "biomeWeightModifier"(biomeWeightModifier: $BiomeWeightModifier$Type): $GTOreDefinition
public "surfaceIndicatorGenerator"(config: $Consumer$Type<($SurfaceIndicatorGenerator$Type)>): $GTOreDefinition
public "standardVeinGenerator"(config: $Consumer$Type<($StandardVeinGenerator$Type)>): $GTOreDefinition
public "clusterSize"(): $IntProvider
public "clusterSize"(clusterSize: $IntProvider$Type): $GTOreDefinition
public "clusterSize"(clusterSize: integer): $GTOreDefinition
public "dimensionFilter"(): $Set<($ResourceKey<($Level)>)>
public "dimensionFilter"(dimensionFilter: $Set$Type<($ResourceKey$Type<($Level$Type)>)>): $GTOreDefinition
public "heightRange"(range: $HeightRangePlacement$Type): $GTOreDefinition
public "heightRangeUniform"(min: integer, max: integer): $GTOreDefinition
public "veinGenerator"(): $VeinGenerator
public "veinGenerator"(id: $ResourceLocation$Type): $VeinGenerator
public "veinGenerator"(veinGenerator: $VeinGenerator$Type): $GTOreDefinition
public "dikeVeinGenerator"(config: $Consumer$Type<($DikeVeinGenerator$Type)>): $GTOreDefinition
public "geodeVeinGenerator"(config: $Consumer$Type<($GeodeVeinGenerator$Type)>): $GTOreDefinition
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTOreDefinition$Type = ($GTOreDefinition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTOreDefinition_ = $GTOreDefinition$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/component/$ICustomDescriptionId" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IItemComponent, $IItemComponent$Type} from "packages/com/gregtechceu/gtceu/api/item/component/$IItemComponent"

export interface $ICustomDescriptionId extends $IItemComponent {

 "getItemName"(stack: $ItemStack$Type): $Component
 "getItemDescriptionId"(itemStack: $ItemStack$Type): string
 "onAttached"(item: $Item$Type): void
}

export namespace $ICustomDescriptionId {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICustomDescriptionId$Type = ($ICustomDescriptionId);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICustomDescriptionId_ = $ICustomDescriptionId$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/feature/multiblock/$IWorkableMultiController" {
import {$IRecipeHandler, $IRecipeHandler$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IRecipeHandler"
import {$RecipeLogic$Status, $RecipeLogic$Status$Type} from "packages/com/gregtechceu/gtceu/api/machine/trait/$RecipeLogic$Status"
import {$IMultiPart, $IMultiPart$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/multiblock/$IMultiPart"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IMultiController, $IMultiController$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/multiblock/$IMultiController"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$RecipeLogic, $RecipeLogic$Type} from "packages/com/gregtechceu/gtceu/api/machine/trait/$RecipeLogic"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$GTRecipeType, $GTRecipeType$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipeType"
import {$MultiblockState, $MultiblockState$Type} from "packages/com/gregtechceu/gtceu/api/pattern/$MultiblockState"
import {$Table, $Table$Type} from "packages/com/google/common/collect/$Table"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$GTRecipe, $GTRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Lock, $Lock$Type} from "packages/java/util/concurrent/locks/$Lock"
import {$RecipeCapability, $RecipeCapability$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$RecipeCapability"
import {$IO, $IO$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IO"
import {$ICleanroomProvider, $ICleanroomProvider$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/$ICleanroomProvider"
import {$IRecipeLogicMachine, $IRecipeLogicMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/$IRecipeLogicMachine"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$BlockPattern, $BlockPattern$Type} from "packages/com/gregtechceu/gtceu/api/pattern/$BlockPattern"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $IWorkableMultiController extends $IMultiController, $IRecipeLogicMachine {

 "checkPattern"(): boolean
 "getPattern"(): $BlockPattern
 "getParts"(): $List<($IMultiPart)>
 "isFormed"(): boolean
 "onUse"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
 "getMultiblockState"(): $MultiblockState
 "asyncCheckPattern"(arg0: long): void
 "onStructureFormed"(): void
 "onStructureInvalid"(): void
 "getPatternLock"(): $Lock
 "getPartAppearance"(part: $IMultiPart$Type, side: $Direction$Type, sourceState: $BlockState$Type, sourcePos: $BlockPos$Type): $BlockState
 "hasFrontFacing"(): boolean
 "onPartUnload"(): void
 "checkPatternWithTryLock"(): boolean
 "checkPatternWithLock"(): boolean
 "shouldAddPartToController"(part: $IMultiPart$Type): boolean
 "isActive"(): boolean
 "getRecipeType"(): $GTRecipeType
 "getRecipeTypes"(): ($GTRecipeType)[]
 "getProgress"(): integer
 "alwaysTryModifyRecipe"(): boolean
 "onWorking"(): boolean
 "afterWorking"(): void
 "onWaiting"(): void
 "beforeWorking"(recipe: $GTRecipe$Type): boolean
 "setWorkingEnabled"(isWorkingAllowed: boolean): void
 "isWorkingEnabled"(): boolean
 "doModifyRecipe"(recipe: $GTRecipe$Type): $GTRecipe
 "getChanceTier"(): integer
 "fullModifyRecipe"(recipe: $GTRecipe$Type): $GTRecipe
 "getMaxProgress"(): integer
 "getRecipeLogic"(): $RecipeLogic
 "keepSubscribing"(): boolean
 "dampingWhenWaiting"(): boolean
 "shouldWorkingPlaySound"(): boolean
 "getActiveRecipeType"(): integer
 "notifyStatusChanged"(oldStatus: $RecipeLogic$Status$Type, newStatus: $RecipeLogic$Status$Type): void
 "isRecipeLogicAvailable"(): boolean
 "setActiveRecipeType"(arg0: integer): void
 "onLeftClick"(player: $Player$Type, world: $Level$Type, hand: $InteractionHand$Type, pos: $BlockPos$Type, direction: $Direction$Type): boolean
 "hasProxies"(): boolean
 "getCapabilitiesProxy"(): $Table<($IO), ($RecipeCapability<(any)>), ($List<($IRecipeHandler<(any)>)>)>
 "getCleanroom"(): $ICleanroomProvider
 "setCleanroom"(arg0: $ICleanroomProvider$Type): void
 "getOutputLimits"(): $Map<($RecipeCapability<(any)>), (integer)>
 "canVoidRecipeOutputs"(capability: $RecipeCapability$Type<(any)>): boolean
}

export namespace $IWorkableMultiController {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IWorkableMultiController$Type = ($IWorkableMultiController);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IWorkableMultiController_ = $IWorkableMultiController$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$HazardProperty$HazardTrigger" {
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$Type} from "packages/net/minecraft/util/$StringRepresentable$EnumCodec"
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$TagPrefix, $TagPrefix$Type} from "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix"
import {$HazardProperty$ProtectionType, $HazardProperty$ProtectionType$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$HazardProperty$ProtectionType"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $HazardProperty$HazardTrigger extends $Record implements $StringRepresentable {
static readonly "ALL_TRIGGERS": $Map<(string), ($HazardProperty$HazardTrigger)>
static readonly "INHALATION": $HazardProperty$HazardTrigger
static readonly "ANY": $HazardProperty$HazardTrigger
static readonly "SKIN_CONTACT": $HazardProperty$HazardTrigger
static readonly "NONE": $HazardProperty$HazardTrigger

constructor(name: string, protectionType: $HazardProperty$ProtectionType$Type, affectedTagPrefixes: $Set$Type<($TagPrefix$Type)>)
constructor(name: string, protectionType: $HazardProperty$ProtectionType$Type, ...tagPrefixes: ($TagPrefix$Type)[])

public "name"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getSerializedName"(): string
public "isAffected"(prefix: $TagPrefix$Type): boolean
public "protectionType"(): $HazardProperty$ProtectionType
public "affectedTagPrefixes"(): $Set<($TagPrefix)>
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>, arg1: $Function$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$Type)[]): $Keyable
get "serializedName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HazardProperty$HazardTrigger$Type = ($HazardProperty$HazardTrigger);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HazardProperty$HazardTrigger_ = $HazardProperty$HazardTrigger$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/fluidpipe/$FluidPipeNet" {
import {$PipeNet, $PipeNet$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$PipeNet"
import {$LevelPipeNet, $LevelPipeNet$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$LevelPipeNet"
import {$FluidPipeProperties, $FluidPipeProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$FluidPipeProperties"

export class $FluidPipeNet extends $PipeNet<($FluidPipeProperties)> {

constructor(world: $LevelPipeNet$Type<($FluidPipeProperties$Type), ($FluidPipeNet$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidPipeNet$Type = ($FluidPipeNet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidPipeNet_ = $FluidPipeNet$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/tool/$ToolDefinitionBuilder" {
import {$AoESymmetrical, $AoESymmetrical$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/aoe/$AoESymmetrical"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$IToolBehavior, $IToolBehavior$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/behavior/$IToolBehavior"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$IGTToolDefinition, $IGTToolDefinition$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$IGTToolDefinition"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$EnchantmentCategory, $EnchantmentCategory$Type} from "packages/net/minecraft/world/item/enchantment/$EnchantmentCategory"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $ToolDefinitionBuilder {

constructor()

public "build"(): $IGTToolDefinition
public "aoe"(additionalColumns: integer, additionalRows: integer, additionalDepth: integer): $ToolDefinitionBuilder
public "aoe"(aoe: $AoESymmetrical$Type): $ToolDefinitionBuilder
public "attackDamage"(attackDamage: float): $ToolDefinitionBuilder
public "attackSpeed"(attackSpeed: float): $ToolDefinitionBuilder
public "attacking"(): $ToolDefinitionBuilder
public "behaviors"(...behaviours: ($IToolBehavior$Type)[]): $ToolDefinitionBuilder
public "crafting"(): $ToolDefinitionBuilder
public "canApplyEnchantment"(...enchantmentTypes: ($EnchantmentCategory$Type)[]): $ToolDefinitionBuilder
public "canApplyEnchantment"(canApplyEnchantment: $BiPredicate$Type<($ItemStack$Type), ($Enchantment$Type)>): $ToolDefinitionBuilder
public "cannotAttack"(): $ToolDefinitionBuilder
public "sneakBypassUse"(): $ToolDefinitionBuilder
public "blockBreaking"(): $ToolDefinitionBuilder
public "baseEfficiency"(baseEfficiency: float): $ToolDefinitionBuilder
public "defaultEnchantment"(enchantment: $Enchantment$Type, level: integer, growth: integer): $ToolDefinitionBuilder
public "defaultEnchantment"(enchantment: $Enchantment$Type, level: integer): $ToolDefinitionBuilder
public "durabilityMultiplier"(durabilityMultiplier: float): $ToolDefinitionBuilder
public "damagePerCraftingAction"(damagePerCraftingAction: integer): $ToolDefinitionBuilder
public "brokenStack"(brokenStack: $Supplier$Type<($ItemStack$Type)>): $ToolDefinitionBuilder
public "noEnchant"(): $ToolDefinitionBuilder
public "damagePerAction"(damagePerAction: integer): $ToolDefinitionBuilder
public "effectiveStates"(effectiveStates: $Predicate$Type<($BlockState$Type)>): $ToolDefinitionBuilder
public "baseDurability"(baseDurability: integer): $ToolDefinitionBuilder
public "baseQuality"(baseQuality: integer): $ToolDefinitionBuilder
public "baseQuality"(): $ToolDefinitionBuilder
public "effectiveBlocks"(...blocks: ($Block$Type)[]): $ToolDefinitionBuilder
public "efficiencyMultiplier"(efficiencyMultiplier: float): $ToolDefinitionBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToolDefinitionBuilder$Type = ($ToolDefinitionBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ToolDefinitionBuilder_ = $ToolDefinitionBuilder$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/fluidpipe/longdistance/$LDFluidPipeType" {
import {$LongDistancePipeType, $LongDistancePipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/longdistance/$LongDistancePipeType"

export class $LDFluidPipeType extends $LongDistancePipeType {
static readonly "INSTANCE": $LDFluidPipeType


public "getMinLength"(): integer
get "minLength"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LDFluidPipeType$Type = ($LDFluidPipeType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LDFluidPipeType_ = $LDFluidPipeType$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$VeinedVeinGenerator$VeinBlockDefinition" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$OreConfiguration$TargetBlockState, $OreConfiguration$TargetBlockState$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$OreConfiguration$TargetBlockState"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $VeinedVeinGenerator$VeinBlockDefinition extends $Record {
static readonly "CODEC": $Codec<($VeinedVeinGenerator$VeinBlockDefinition)>

constructor(block: $Either$Type<($List$Type<($OreConfiguration$TargetBlockState$Type)>), ($Material$Type)>, weight: integer)
constructor(block: $List$Type<($OreConfiguration$TargetBlockState$Type)>, weight: integer)
constructor(block: $Material$Type, weight: integer)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "block"(): $Either<($List<($OreConfiguration$TargetBlockState)>), ($Material)>
public "weight"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VeinedVeinGenerator$VeinBlockDefinition$Type = ($VeinedVeinGenerator$VeinBlockDefinition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VeinedVeinGenerator$VeinBlockDefinition_ = $VeinedVeinGenerator$VeinBlockDefinition$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$WireProperties" {
import {$IMaterialProperty, $IMaterialProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IMaterialProperty"
import {$MaterialProperties, $MaterialProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$MaterialProperties"

export class $WireProperties implements $IMaterialProperty<($WireProperties)> {

constructor()
constructor(voltage: integer, baseAmperage: integer, lossPerBlock: integer, isSuperCon: boolean, criticalTemperature: integer)
constructor(voltage: integer, baseAmperage: integer, lossPerBlock: integer, isSuperCon: boolean)
constructor(voltage: integer, baseAmperage: integer, lossPerBlock: integer)

public "equals"(o: any): boolean
public "hashCode"(): integer
public "copy"(): $WireProperties
public "getSuperconductorCriticalTemperature"(): integer
public "setSuperconductorCriticalTemperature"(criticalTemperature: integer): void
public "verifyProperty"(properties: $MaterialProperties$Type): void
public "setLossPerBlock"(lossPerBlock: integer): void
public "setSuperconductor"(isSuperconductor: boolean): void
public "setAmperage"(amperage: integer): void
public "setVoltage"(voltage: integer): void
public "isSuperconductor"(): boolean
public "getLossPerBlock"(): integer
public "getVoltage"(): integer
public "getAmperage"(): integer
get "superconductorCriticalTemperature"(): integer
set "superconductorCriticalTemperature"(value: integer)
set "lossPerBlock"(value: integer)
set "superconductor"(value: boolean)
set "amperage"(value: integer)
set "voltage"(value: integer)
get "superconductor"(): boolean
get "lossPerBlock"(): integer
get "voltage"(): integer
get "amperage"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WireProperties$Type = ($WireProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WireProperties_ = $WireProperties$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/cover/$CoverDefinition$CoverBehaviourProvider" {
import {$ICoverable, $ICoverable$Type} from "packages/com/gregtechceu/gtceu/api/capability/$ICoverable"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CoverBehavior, $CoverBehavior$Type} from "packages/com/gregtechceu/gtceu/api/cover/$CoverBehavior"
import {$CoverDefinition, $CoverDefinition$Type} from "packages/com/gregtechceu/gtceu/api/cover/$CoverDefinition"

export interface $CoverDefinition$CoverBehaviourProvider {

 "create"(arg0: $CoverDefinition$Type, arg1: $ICoverable$Type, arg2: $Direction$Type): $CoverBehavior

(arg0: $CoverDefinition$Type, arg1: $ICoverable$Type, arg2: $Direction$Type): $CoverBehavior
}

export namespace $CoverDefinition$CoverBehaviourProvider {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoverDefinition$CoverBehaviourProvider$Type = ($CoverDefinition$CoverBehaviourProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CoverDefinition$CoverBehaviourProvider_ = $CoverDefinition$CoverBehaviourProvider$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/$CableBlock" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$PipeModel, $PipeModel$Type} from "packages/com/gregtechceu/gtceu/client/model/$PipeModel"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$IPipeNode, $IPipeNode$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeNode"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$MaterialPipeBlock, $MaterialPipeBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$MaterialPipeBlock"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$PipeBlockRenderer, $PipeBlockRenderer$Type} from "packages/com/gregtechceu/gtceu/client/renderer/block/$PipeBlockRenderer"
import {$IPipeType, $IPipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeType"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$LevelEnergyNet, $LevelEnergyNet$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/cable/$LevelEnergyNet"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$WireProperties, $WireProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$WireProperties"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$Insulation, $Insulation$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/cable/$Insulation"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export class $CableBlock extends $MaterialPipeBlock<($Insulation), ($WireProperties), ($LevelEnergyNet)> {
readonly "material": $Material
readonly "renderer": $PipeBlockRenderer
readonly "model": $PipeModel
readonly "pipeType": PipeType
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, insulation: $Insulation$Type, material: $Material$Type)

public "getBlockEntityType"(): $BlockEntityType<(any)>
public "tinted"(blockState: $BlockState$Type, blockAndTintGetter: $BlockAndTintGetter$Type, blockPos: $BlockPos$Type, index: integer): integer
public "appendHoverText"(stack: $ItemStack$Type, level: $BlockGetter$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "entityInside"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, entity: $Entity$Type): void
public "canPipeConnectToBlock"(selfTile: $IPipeNode$Type<($Insulation$Type), ($WireProperties$Type)>, side: $Direction$Type, tile: $BlockEntity$Type): boolean
public "canPipesConnect"(selfTile: $IPipeNode$Type<($Insulation$Type), ($WireProperties$Type)>, side: $Direction$Type, sideTile: $IPipeNode$Type<($Insulation$Type), ($WireProperties$Type)>): boolean
get "blockEntityType"(): $BlockEntityType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CableBlock$Type = ($CableBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CableBlock_ = $CableBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/core/mixins/$BlockPropertiesAccessor" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$MapColor, $MapColor$Type} from "packages/net/minecraft/world/level/material/$MapColor"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BlockBehaviour$StatePredicate, $BlockBehaviour$StatePredicate$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$StatePredicate"
import {$NoteBlockInstrument, $NoteBlockInstrument$Type} from "packages/net/minecraft/world/level/block/state/properties/$NoteBlockInstrument"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$PushReaction, $PushReaction$Type} from "packages/net/minecraft/world/level/material/$PushReaction"
import {$BlockBehaviour$OffsetFunction, $BlockBehaviour$OffsetFunction$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$OffsetFunction"

export interface $BlockPropertiesAccessor {

 "setOffsetFunction"(arg0: $Optional$Type<($BlockBehaviour$OffsetFunction$Type)>): void
 "isForceSolidOff"(): boolean
 "getDestroyTime"(): float
 "getSpeedFactor"(): float
 "isIgnitedByLava"(): boolean
 "isCanOcclude"(): boolean
 "isHasCollision"(): boolean
 "isDynamicShape"(): boolean
 "isLiquid"(): boolean
 "getPushReaction"(): $PushReaction
 "getOffsetFunction"(): $Optional<($BlockBehaviour$OffsetFunction)>
 "isReplaceable"(): boolean
 "isIsAir"(): boolean
 "isForceSolidOn"(): boolean
 "getRequiredFeatures"(): $FeatureFlagSet
 "isIsRandomlyTicking"(): boolean
 "isRequiresCorrectToolForDrops"(): boolean
 "isSpawnParticlesOnBreak"(): boolean
 "getEmissiveRendering"(): $BlockBehaviour$StatePredicate
 "setRequiredFeatures"(arg0: $FeatureFlagSet$Type): void
 "getMapColor"(): $Function<($BlockState), ($MapColor)>
 "getFriction"(): float
 "getSoundType"(): $SoundType
 "getLightEmission"(): $ToIntFunction<($BlockState)>
 "getExplosionResistance"(): float
 "getInstrument"(): $NoteBlockInstrument
}

export namespace $BlockPropertiesAccessor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPropertiesAccessor$Type = ($BlockPropertiesAccessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockPropertiesAccessor_ = $BlockPropertiesAccessor$Type;
}}
declare module "packages/com/gregtechceu/gtceu/integration/kjs/events/$GTOreVeinEventJS" {
import {$GTOreDefinition, $GTOreDefinition$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTOreDefinition"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $GTOreVeinEventJS extends $EventJS {

constructor()

public "add"(id: $ResourceLocation$Type, consumer: $Consumer$Type<($GTOreDefinition$Type)>): void
public "remove"(id: $ResourceLocation$Type): void
public "removeAll"(): void
public "removeAll"(predicate: $BiPredicate$Type<($ResourceLocation$Type), ($GTOreDefinition$Type)>): void
public "modify"(id: $ResourceLocation$Type, consumer: $Consumer$Type<($GTOreDefinition$Type)>): void
public "modifyAll"(consumer: $BiConsumer$Type<($ResourceLocation$Type), ($GTOreDefinition$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTOreVeinEventJS$Type = ($GTOreVeinEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTOreVeinEventJS_ = $GTOreVeinEventJS$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe$ActionResult" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $GTRecipe$ActionResult extends $Record {
static readonly "SUCCESS": $GTRecipe$ActionResult
static readonly "FAIL_NO_REASON": $GTRecipe$ActionResult

constructor(isSuccess: boolean, reason: $Supplier$Type<($Component$Type)>, expectingRate: float)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "fail"(component: $Supplier$Type<($Component$Type)>, expectingRate: float): $GTRecipe$ActionResult
public static "fail"(component: $Supplier$Type<($Component$Type)>): $GTRecipe$ActionResult
public "reason"(): $Supplier<($Component)>
public "isSuccess"(): boolean
public "expectingRate"(): float
get "success"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTRecipe$ActionResult$Type = ($GTRecipe$ActionResult);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTRecipe$ActionResult_ = $GTRecipe$ActionResult$Type;
}}
declare module "packages/com/gregtechceu/gtceu/utils/$GTUtil" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$FluidStack, $FluidStack$Type} from "packages/com/lowdragmc/lowdraglib/side/fluid/$FluidStack"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$DyeColor, $DyeColor$Type} from "packages/net/minecraft/world/item/$DyeColor"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Biome, $Biome$Type} from "packages/net/minecraft/world/level/biome/$Biome"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$Tuple, $Tuple$Type} from "packages/net/minecraft/util/$Tuple"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $GTUtil {
static readonly "DIRECTIONS": ($Direction)[]

constructor()

public static "copy"(...stacks: ($ItemStack$Type)[]): $ItemStack
public static "getItem"<M>(list: $List$Type<(any)>, index: integer, replacement: M): M
public static "getItemBurnTime"(item: $Item$Type): integer
public static "getMoltenFluid"(material: $Material$Type): $Fluid
public static "isAltDown"(): boolean
public static "isShiftDown"(): boolean
public static "isCtrlDown"(): boolean
public static "isItemStackCountDivisible"(itemStack: $ItemStack$Type, divisor: integer): boolean
public static "getActualTypeParameter"<T, R>(thisClass: $Class$Type<(any)>, index: integer): $Class<(T)>
public static "isFluidStackAmountDivisible"(fluidStack: $FluidStack$Type, divisor: integer): boolean
public static "getPumpBiomeModifier"(biome: $Holder$Type<($Biome$Type)>): long
public static "appendHazardTooltips"(material: $Material$Type, tooltipComponents: $List$Type<($Component$Type)>): void
public static "determineWrenchingSide"(facing: $Direction$Type, x: float, y: float, z: float): $Direction
public static "nearestLesserOrEqual"(array: (long)[], value: long): integer
public static "getFluidFromContainer"(ingredient: any): $FluidStack
public static "getRandomItem"<T>(random: $RandomSource$Type, randomList: $List$Type<(any)>, size: integer): integer
public static "getRandomItem"<T>(randomList: $List$Type<(any)>, size: integer): integer
public static "convertRGBtoARGB"(colorValue: integer, opacity: integer): integer
public static "convertRGBtoARGB"(colorValue: integer): integer
public static "getFacingToNeighbor"(main: $BlockPos$Type, neighbor: $BlockPos$Type): $Direction
public static "getFakeVoltageTier"(voltage: long): integer
public static "getTierByVoltage"(voltage: long): byte
public static "canSeeSunClearly"(world: $Level$Type, blockPos: $BlockPos$Type): boolean
public static "getFloorTierByVoltage"(voltage: long): byte
public static "getVoltageFromFakeTier"(tier: integer): long
public static "copyAmount"(amount: integer, ...stacks: ($ItemStack$Type)[]): $ItemStack
public static "copyAmount"(amount: integer, fluidStack: $FluidStack$Type): $FluidStack
public static "getExplosionPower"(voltage: long): float
public static "determineDyeColor"(rgbColor: integer): $DyeColor
public static "saveItemStack"(itemStack: $ItemStack$Type, compoundTag: $CompoundTag$Type): $CompoundTag
public static "selectItemInList"<M>(index: integer, replacement: M, list: $List$Type<(M)>, minClass: $Class$Type<(M)>): M
public static "nearestLesser"(array: (long)[], value: long): integer
public static "loadItemStack"(compoundTag: $CompoundTag$Type): $ItemStack
public static "getMaintenanceText"(flag: byte): $Tuple<($ItemStack), ($MutableComponent)>
get "altDown"(): boolean
get "shiftDown"(): boolean
get "ctrlDown"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTUtil$Type = ($GTUtil);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTUtil_ = $GTUtil$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/indicators/$SurfaceIndicatorGenerator$IndicatorPlacement" {
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$Type} from "packages/net/minecraft/util/$StringRepresentable$EnumCodec"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$WorldGenLevel, $WorldGenLevel$Type} from "packages/net/minecraft/world/level/$WorldGenLevel"
import {$BulkSectionAccess, $BulkSectionAccess$Type} from "packages/net/minecraft/world/level/chunk/$BulkSectionAccess"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$TriFunction, $TriFunction$Type} from "packages/org/apache/commons/lang3/function/$TriFunction"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $SurfaceIndicatorGenerator$IndicatorPlacement extends $Enum<($SurfaceIndicatorGenerator$IndicatorPlacement)> implements $StringRepresentable {
static readonly "SURFACE": $SurfaceIndicatorGenerator$IndicatorPlacement
static readonly "ABOVE": $SurfaceIndicatorGenerator$IndicatorPlacement
static readonly "BELOW": $SurfaceIndicatorGenerator$IndicatorPlacement
static readonly "CODEC": $Codec<($SurfaceIndicatorGenerator$IndicatorPlacement)>
readonly "resolver": $TriFunction<($WorldGenLevel), ($BulkSectionAccess), ($BlockPos), ($BlockPos)>
readonly "stateTransformer": $Function<($Either<($BlockState), ($Material)>), ($BlockState)>


public static "values"(): ($SurfaceIndicatorGenerator$IndicatorPlacement)[]
public static "valueOf"(name: string): $SurfaceIndicatorGenerator$IndicatorPlacement
public static "getByName"(name: string): $SurfaceIndicatorGenerator$IndicatorPlacement
public "getSerializedName"(): string
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>, arg1: $Function$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$Type)[]): $Keyable
get "serializedName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SurfaceIndicatorGenerator$IndicatorPlacement$Type = (("surface") | ("below") | ("above")) | ($SurfaceIndicatorGenerator$IndicatorPlacement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SurfaceIndicatorGenerator$IndicatorPlacement_ = $SurfaceIndicatorGenerator$IndicatorPlacement$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/$LaserPipeBlockItem" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$IRenderer, $IRenderer$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IRenderer"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$ItemColor, $ItemColor$Type} from "packages/net/minecraft/client/color/item/$ItemColor"
import {$FoodProperties, $FoodProperties$Type} from "packages/net/minecraft/world/food/$FoodProperties"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$Type} from "packages/net/mehvahdjukaar/moonlight/api/item/additional_placements/$AdditionalItemPlacement"
import {$PipeBlock, $PipeBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$PipeBlock"
import {$IItemRendererProvider, $IItemRendererProvider$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IItemRendererProvider"
import {$PipeBlockItem, $PipeBlockItem$Type} from "packages/com/gregtechceu/gtceu/api/item/$PipeBlockItem"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $LaserPipeBlockItem extends $PipeBlockItem implements $IItemRendererProvider {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "descriptionId": string
 "foodProperties": $FoodProperties
readonly "canRepair": boolean
 "renderProperties": any
 "moonlight$clientAnimationProvider": any

constructor(block: $PipeBlock$Type<(any), (any), (any)>, properties: $Item$Properties$Type)

public static "tintColor"(): $ItemColor
public "getRenderer"(stack: $ItemStack$Type): $IRenderer
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public "moonlight$addAdditionalBehavior"(arg0: $AdditionalItemPlacement$Type): void
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LaserPipeBlockItem$Type = ($LaserPipeBlockItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LaserPipeBlockItem_ = $LaserPipeBlockItem$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/capability/$IToolable" {
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$GTToolType, $GTToolType$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $IToolable {

 "onToolClick"(arg0: $Set$Type<($GTToolType$Type)>, arg1: $ItemStack$Type, arg2: $UseOnContext$Type): $Pair<($GTToolType), ($InteractionResult)>

(arg0: $Set$Type<($GTToolType$Type)>, arg1: $ItemStack$Type, arg2: $UseOnContext$Type): $Pair<($GTToolType), ($InteractionResult)>
}

export namespace $IToolable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IToolable$Type = ($IToolable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IToolable_ = $IToolable$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$StandardVeinGenerator" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$GTOreDefinition, $GTOreDefinition$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTOreDefinition"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NonNullSupplier, $NonNullSupplier$Type} from "packages/com/tterrag/registrate/util/nullness/$NonNullSupplier"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$OreConfiguration$TargetBlockState, $OreConfiguration$TargetBlockState$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$OreConfiguration$TargetBlockState"
import {$VeinGenerator, $VeinGenerator$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/$VeinGenerator"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $StandardVeinGenerator extends $VeinGenerator {
static readonly "CODEC_SEPARATE": $Codec<($StandardVeinGenerator)>
static readonly "CODEC_LIST": $Codec<($StandardVeinGenerator)>
static readonly "CODEC": $Codec<($StandardVeinGenerator)>
 "block": $NonNullSupplier<(any)>
 "deepBlock": $NonNullSupplier<(any)>
 "netherBlock": $NonNullSupplier<(any)>
 "blocks": $Either<($List<($OreConfiguration$TargetBlockState)>), ($Material)>
static readonly "REGISTRY_CODEC": $Codec<($Codec<(any)>)>
static readonly "DIRECT_CODEC": $Codec<($VeinGenerator)>

constructor(blocks: $Either$Type<($List$Type<($OreConfiguration$TargetBlockState$Type)>), ($Material$Type)>)
constructor(block: $Block$Type, deepBlock: $Block$Type, netherBlock: $Block$Type)
constructor(entry: $GTOreDefinition$Type)

public "copy"(): $VeinGenerator
public "codec"(): $Codec<(any)>
public "getAllEntries"(): $List<($Map$Entry<($Either<($BlockState), ($Material)>), (integer)>)>
public "withMaterial"(material: $Material$Type): $StandardVeinGenerator
public "withNetherBlock"(block: $NonNullSupplier$Type<(any)>): $StandardVeinGenerator
public "withBlock"(block: $NonNullSupplier$Type<(any)>): $StandardVeinGenerator
get "allEntries"(): $List<($Map$Entry<($Either<($BlockState), ($Material)>), (integer)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StandardVeinGenerator$Type = ($StandardVeinGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StandardVeinGenerator_ = $StandardVeinGenerator$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/$MetaMachine" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IToolable, $IToolable$Type} from "packages/com/gregtechceu/gtceu/api/capability/$IToolable"
import {$IFieldUpdateListener, $IFieldUpdateListener$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$IFieldUpdateListener"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ResourceTexture, $ResourceTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$ResourceTexture"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IFluidTransfer, $IFluidTransfer$Type} from "packages/com/lowdragmc/lowdraglib/side/fluid/$IFluidTransfer"
import {$IAppearance, $IAppearance$Type} from "packages/com/gregtechceu/gtceu/api/block/$IAppearance"
import {$TickableSubscription, $TickableSubscription$Type} from "packages/com/gregtechceu/gtceu/api/machine/$TickableSubscription"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$MachineDefinition, $MachineDefinition$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MachineDefinition"
import {$TooltipComponent, $TooltipComponent$Type} from "packages/net/minecraft/world/inventory/tooltip/$TooltipComponent"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$MachineCoverContainer, $MachineCoverContainer$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MachineCoverContainer"
import {$IFancyTooltip, $IFancyTooltip$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$IFancyTooltip"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IMachineBlockEntity, $IMachineBlockEntity$Type} from "packages/com/gregtechceu/gtceu/api/machine/$IMachineBlockEntity"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IRedstoneSignalMachine, $IRedstoneSignalMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/$IRedstoneSignalMachine"
import {$ISubscription, $ISubscription$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$ISubscription"
import {$ITickSubscription, $ITickSubscription$Type} from "packages/com/gregtechceu/gtceu/api/blockentity/$ITickSubscription"
import {$IItemTransfer, $IItemTransfer$Type} from "packages/com/lowdragmc/lowdraglib/side/item/$IItemTransfer"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$MachineTrait, $MachineTrait$Type} from "packages/com/gregtechceu/gtceu/api/machine/trait/$MachineTrait"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IRef, $IRef$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/managed/$IRef"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$ManagedFieldHolder, $ManagedFieldHolder$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/field/$ManagedFieldHolder"
import {$IToolGridHighLight, $IToolGridHighLight$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$IToolGridHighLight"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$IEnhancedManaged, $IEnhancedManaged$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$IEnhancedManaged"
import {$GTToolType, $GTToolType$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$IGuiTexture, $IGuiTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$IGuiTexture"
import {$IPaintable, $IPaintable$Type} from "packages/com/gregtechceu/gtceu/api/blockentity/$IPaintable"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export class $MetaMachine implements $IEnhancedManaged, $IToolable, $ITickSubscription, $IAppearance, $IToolGridHighLight, $IFancyTooltip, $IPaintable, $IRedstoneSignalMachine {
readonly "holder": $IMachineBlockEntity
 "isFirstDummyWorldTick": boolean

constructor(holder: $IMachineBlockEntity$Type)

public "getDefinition"(): $MachineDefinition
public "getLevel"(): $Level
public "onLoad"(): void
public "unsubscribe"(current: $TickableSubscription$Type): void
public "getPos"(): $BlockPos
public "onNeighborChanged"(block: $Block$Type, fromPos: $BlockPos$Type, isMoving: boolean): void
public "tintColor"(index: integer): integer
public "isRemote"(): boolean
public "canConnectRedstone"(side: $Direction$Type): boolean
public "onRotated"(oldFacing: $Direction$Type, newFacing: $Direction$Type): void
public "getBlockState"(): $BlockState
public "clientTick"(): void
public "animateTick"(random: $RandomSource$Type): void
public "getHolder"(): $IMachineBlockEntity
public "getTraits"(): $List<($MachineTrait)>
public "serverTick"(): void
public "markDirty"(): void
public "onUnload"(): void
public "onChanged"(): void
public "notifyBlockUpdate"(): void
public "getDefaultPaintingColor"(): integer
public static "getMachine"(level: $BlockGetter$Type, pos: $BlockPos$Type): $MetaMachine
public "getBlockAppearance"(state: $BlockState$Type, level: $BlockAndTintGetter$Type, pos: $BlockPos$Type, side: $Direction$Type, sourceState: $BlockState$Type, sourcePos: $BlockPos$Type): $BlockState
public "loadCustomPersistedData"(tag: $CompoundTag$Type): void
public "saveCustomPersistedData"(tag: $CompoundTag$Type, forDrop: boolean): void
public "scheduleRenderUpdate"(): void
public "scheduleNeighborShapeUpdate"(): void
public "subscribeServerTick"(runnable: $Runnable$Type): $TickableSubscription
public "getFrontFacing"(): $Direction
public "getCoverContainer"(): $MachineCoverContainer
public "onToolClick"(toolType: $Set$Type<($GTToolType$Type)>, itemStack: $ItemStack$Type, context: $UseOnContext$Type): $Pair<($GTToolType), ($InteractionResult)>
public "getOffsetTimer"(): long
public "getFieldHolder"(): $ManagedFieldHolder
public "isInValid"(): boolean
public "hasFrontFacing"(): boolean
public "isFacingValid"(facing: $Direction$Type): boolean
public "setFrontFacing"(facing: $Direction$Type): void
public static "clearInventory"(itemBuffer: $List$Type<($ItemStack$Type)>, inventory: $IItemTransfer$Type): void
public "attachTraits"(trait: $MachineTrait$Type): void
public "shouldRenderGrid"(player: $Player$Type, held: $ItemStack$Type, toolTypes: $Set$Type<($GTToolType$Type)>): boolean
public "sideTips"(player: $Player$Type, toolTypes: $Set$Type<($GTToolType$Type)>, side: $Direction$Type): $ResourceTexture
public "getItemTransferCap"(side: $Direction$Type, useCoverCapability: boolean): $IItemTransfer
public "canSetIoOnSide"(direction: $Direction$Type): boolean
public "getOutputSignal"(side: $Direction$Type): integer
public "getPaintingColor"(): integer
public "showFancyTooltip"(): boolean
public "setPaintingColor"(paintingColor: integer): void
public "getFancyTooltip"(): $List<($Component)>
public "getFancyTooltipIcon"(): $IGuiTexture
public "addCollisionBoundingBox"(collisionList: $List$Type<($VoxelShape$Type)>): void
public "onAddFancyInformationTooltip"(tooltips: $List$Type<($Component$Type)>): void
public "getFluidTransferCap"(side: $Direction$Type, useCoverCapability: boolean): $IFluidTransfer
public "scheduleRender"(fieldName: string, newValue: any, oldValue: any): void
public "subscribeServerTick"(last: $TickableSubscription$Type, runnable: $Runnable$Type): $TickableSubscription
public "getFancyComponent"(): $TooltipComponent
public "isPainted"(): boolean
public "getRealColor"(): integer
public "updateSignal"(): void
public "getAnalogOutputSignal"(): integer
public "getOutputDirectSignal"(direction: $Direction$Type): integer
public "markDirty"(name: string): void
public "onPersistedChanged"(ref: $IRef$Type, isDirty: boolean): void
public "onSyncChanged"(ref: $IRef$Type, isDirty: boolean): void
public "addSyncUpdateListener"<T>(name: string, listener: $IFieldUpdateListener$Type<(T)>): $ISubscription
public "self"(): $MetaMachine
get "definition"(): $MachineDefinition
get "level"(): $Level
get "pos"(): $BlockPos
get "remote"(): boolean
get "blockState"(): $BlockState
get "holder"(): $IMachineBlockEntity
get "traits"(): $List<($MachineTrait)>
get "defaultPaintingColor"(): integer
get "frontFacing"(): $Direction
get "coverContainer"(): $MachineCoverContainer
get "offsetTimer"(): long
get "fieldHolder"(): $ManagedFieldHolder
get "inValid"(): boolean
set "frontFacing"(value: $Direction$Type)
get "paintingColor"(): integer
set "paintingColor"(value: integer)
get "fancyTooltip"(): $List<($Component)>
get "fancyTooltipIcon"(): $IGuiTexture
get "fancyComponent"(): $TooltipComponent
get "painted"(): boolean
get "realColor"(): integer
get "analogOutputSignal"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MetaMachine$Type = ($MetaMachine);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MetaMachine_ = $MetaMachine$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pattern/util/$RelativeDirection" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Vec3i, $Vec3i$Type} from "packages/net/minecraft/core/$Vec3i"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Direction$Axis, $Direction$Axis$Type} from "packages/net/minecraft/core/$Direction$Axis"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $RelativeDirection extends $Enum<($RelativeDirection)> {
static readonly "UP": $RelativeDirection
static readonly "DOWN": $RelativeDirection
static readonly "LEFT": $RelativeDirection
static readonly "RIGHT": $RelativeDirection
static readonly "FRONT": $RelativeDirection
static readonly "BACK": $RelativeDirection
readonly "axis": $Direction$Axis


public static "values"(): ($RelativeDirection)[]
public static "valueOf"(name: string): $RelativeDirection
public static "offsetPos"(pos: $BlockPos$Type, frontFacing: $Direction$Type, upwardsFacing: $Direction$Type, isFlipped: boolean, upOffset: integer, leftOffset: integer, forwardOffset: integer): $BlockPos
public "getRelativeFacing"(frontFacing: $Direction$Type, upwardsFacing: $Direction$Type, isFlipped: boolean): $Direction
public "isSameAxis"(dir: $RelativeDirection$Type): boolean
public "applyVec3i"(facing: $Direction$Type): $Vec3i
public "getSorter"(frontFacing: $Direction$Type, upwardsFacing: $Direction$Type, isFlipped: boolean): $Function<($BlockPos), (integer)>
public "getActualFacing"(facing: $Direction$Type): $Direction
public static "simulateAxisRotation"(newFrontFacing: $Direction$Type, oldFrontFacing: $Direction$Type, upwardsFacing: $Direction$Type): $Direction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RelativeDirection$Type = (("left") | ("back") | ("up") | ("right") | ("front") | ("down")) | ($RelativeDirection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RelativeDirection_ = $RelativeDirection$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/cover/filter/$Filter" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$WidgetGroup, $WidgetGroup$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$WidgetGroup"

export interface $Filter<T, S extends $Filter<(T), (S)>> extends $Predicate<(T)> {

 "openConfigurator"(arg0: integer, arg1: integer): $WidgetGroup
 "setOnUpdated"(arg0: $Consumer$Type<(S)>): void
 "saveFilter"(): $CompoundTag
 "isBlackList"(): boolean
 "test"(arg0: T): boolean
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(T)>
 "negate"(): $Predicate<(T)>
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(T)>
}

export namespace $Filter {
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(T)>
function isEqual<T>(arg0: any): $Predicate<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Filter$Type<T, S> = ($Filter<(T), (S)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Filter_<T, S> = $Filter$Type<(T), (S)>;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/duct/$DuctPipeType" {
import {$DuctPipeProperties, $DuctPipeProperties$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/duct/$DuctPipeProperties"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$Type} from "packages/net/minecraft/util/$StringRepresentable$EnumCodec"
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$PipeModel, $PipeModel$Type} from "packages/com/gregtechceu/gtceu/client/model/$PipeModel"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IPipeType, $IPipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeType"

export class $DuctPipeType extends $Enum<($DuctPipeType)> implements $IPipeType<($DuctPipeProperties)>, $StringRepresentable {
static readonly "SMALL": $DuctPipeType
static readonly "NORMAL": $DuctPipeType
static readonly "LARGE": $DuctPipeType
static readonly "HUGE": $DuctPipeType
static readonly "TYPE_ID": $ResourceLocation
static readonly "VALUES": ($DuctPipeType)[]
readonly "name": string


public "getName"(): string
public "type"(): $ResourceLocation
public static "values"(): ($DuctPipeType)[]
public static "valueOf"(name: string): $DuctPipeType
public "getSerializedName"(): string
public "getThickness"(): float
public "modifyProperties"(baseProperties: $DuctPipeProperties$Type): $DuctPipeProperties
public "isPaintable"(): boolean
public "createPipeModel"(): $PipeModel
public "getRateMultiplier"(): float
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>, arg1: $Function$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$Type)[]): $Keyable
get "name"(): string
get "serializedName"(): string
get "thickness"(): float
get "paintable"(): boolean
get "rateMultiplier"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DuctPipeType$Type = (("small") | ("normal") | ("large") | ("huge")) | ($DuctPipeType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DuctPipeType_ = $DuctPipeType$Type;
}}
declare module "packages/com/gregtechceu/gtceu/core/mixins/ae2/$GenericStackInvAccessor" {
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export interface $GenericStackInvAccessor {

 "getListener"(): $Runnable
 "setListener"(arg0: $Runnable$Type): void
}

export namespace $GenericStackInvAccessor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GenericStackInvAccessor$Type = ($GenericStackInvAccessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GenericStackInvAccessor_ = $GenericStackInvAccessor$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/block/$MaterialPipeBlock" {
import {$IMaterialPipeType, $IMaterialPipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IMaterialPipeType"
import {$BlockColor, $BlockColor$Type} from "packages/net/minecraft/client/color/block/$BlockColor"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$PipeModel, $PipeModel$Type} from "packages/com/gregtechceu/gtceu/client/model/$PipeModel"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$IPipeNode, $IPipeNode$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeNode"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$PipeBlock, $PipeBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$PipeBlock"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$PipeBlockRenderer, $PipeBlockRenderer$Type} from "packages/com/gregtechceu/gtceu/client/renderer/block/$PipeBlockRenderer"
import {$LevelPipeNet, $LevelPipeNet$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$LevelPipeNet"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"
import {$IPipeType, $IPipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeType"

export class $MaterialPipeBlock<PipeType extends ($Enum<(PipeType)>) & ($IPipeType<(NodeDataType)>) & ($IMaterialPipeType<(NodeDataType)>), NodeDataType, WorldPipeNetType extends $LevelPipeNet<(NodeDataType), (any)>> extends $PipeBlock<(PipeType), (NodeDataType), (WorldPipeNetType)> {
readonly "material": $Material
readonly "renderer": $PipeBlockRenderer
readonly "model": $PipeModel
readonly "pipeType": PipeType
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, pipeType: PipeType, material: $Material$Type)

public "createProperties"(pipeTile: $IPipeNode$Type<(PipeType), (NodeDataType)>): NodeDataType
public "getDescriptionId"(): string
public "getName"(): $MutableComponent
public "tinted"(blockState: $BlockState$Type, blockAndTintGetter: $BlockAndTintGetter$Type, blockPos: $BlockPos$Type, index: integer): integer
public "getRenderer"(state: $BlockState$Type): $PipeBlockRenderer
public static "tintedColor"(): $BlockColor
public "createRawData"(pState: $BlockState$Type, pStack: $ItemStack$Type): NodeDataType
public "getFallbackType"(): NodeDataType
get "descriptionId"(): string
get "name"(): $MutableComponent
get "fallbackType"(): NodeDataType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialPipeBlock$Type<PipeType, NodeDataType, WorldPipeNetType> = ($MaterialPipeBlock<(PipeType), (NodeDataType), (WorldPipeNetType)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialPipeBlock_<PipeType, NodeDataType, WorldPipeNetType> = $MaterialPipeBlock$Type<(PipeType), (NodeDataType), (WorldPipeNetType)>;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$HazardProperty" {
import {$HazardProperty$HazardTrigger, $HazardProperty$HazardTrigger$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$HazardProperty$HazardTrigger"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$IMaterialProperty, $IMaterialProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IMaterialProperty"
import {$MaterialProperties, $MaterialProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$MaterialProperties"
import {$MedicalCondition, $MedicalCondition$Type} from "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$MedicalCondition"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $HazardProperty implements $IMaterialProperty<($HazardProperty)> {
readonly "condition": $MedicalCondition
readonly "hazardTrigger": $HazardProperty$HazardTrigger
readonly "applyToDerivatives": boolean
readonly "progressionMultiplier": float

constructor(hazardTrigger: $HazardProperty$HazardTrigger$Type, condition: $MedicalCondition$Type, progressionMultiplier: float, applyToDerivatives: boolean)

public "verifyProperty"(properties: $MaterialProperties$Type): void
public static "getValidHazardMaterial"(item: $ItemStack$Type): $Material
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HazardProperty$Type = ($HazardProperty);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HazardProperty_ = $HazardProperty$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/$StrictShapedRecipe" {
import {$ShapedRecipe, $ShapedRecipe$Type} from "packages/net/minecraft/world/item/crafting/$ShapedRecipe"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$CraftingContainer, $CraftingContainer$Type} from "packages/net/minecraft/world/inventory/$CraftingContainer"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$CraftingBookCategory, $CraftingBookCategory$Type} from "packages/net/minecraft/world/item/crafting/$CraftingBookCategory"

export class $StrictShapedRecipe extends $ShapedRecipe {
static readonly "SERIALIZER": $RecipeSerializer<($StrictShapedRecipe)>
static "MAX_WIDTH": integer
static "MAX_HEIGHT": integer
readonly "width": integer
readonly "height": integer
readonly "recipeItems": $NonNullList<($Ingredient)>
readonly "result": $ItemStack
readonly "group": string
readonly "category": $CraftingBookCategory
readonly "showNotification": boolean

constructor(id: $ResourceLocation$Type, group: string, category: $CraftingBookCategory$Type, width: integer, height: integer, recipeItems: $NonNullList$Type<($Ingredient$Type)>, result: $ItemStack$Type)

public "matches"(inv: $CraftingContainer$Type, level: $Level$Type): boolean
public "getSerializer"(): $RecipeSerializer<(any)>
get "serializer"(): $RecipeSerializer<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StrictShapedRecipe$Type = ($StrictShapedRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StrictShapedRecipe_ = $StrictShapedRecipe$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/registry/$GTRegistry" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Tag, $Tag$Type} from "packages/net/minecraft/nbt/$Tag"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $GTRegistry<K, V> implements $Iterable<(V)> {
static readonly "REGISTERED": $Map<($ResourceLocation), ($GTRegistry<(any), (any)>)>

constructor(registryName: $ResourceLocation$Type)

public "remove"(name: K): boolean
public "get"(key: K): V
public "values"(): $Set<(V)>
public "replace"(key: K, value: V): V
public "iterator"(): $Iterator<(V)>
public "getKey"(value: V): K
public "register"(key: K, value: V): void
public "keys"(): $Set<(K)>
public "getOrDefault"(key: K, defaultValue: V): V
public "entries"(): $Set<($Map$Entry<(K), (V)>)>
public "isFrozen"(): boolean
public "freeze"(): void
public "registry"(): $Map<(K), (V)>
public "codec"(): $Codec<(V)>
public "readBuf"(arg0: $FriendlyByteBuf$Type): V
public "loadFromNBT"(arg0: $Tag$Type): V
public "saveToNBT"(arg0: V): $Tag
public "unfreeze"(): void
public "getRegistryName"(): $ResourceLocation
public "containKey"(key: K): boolean
public "writeBuf"(arg0: V, arg1: $FriendlyByteBuf$Type): void
public "getOrDefaultKey"(key: V, defaultKey: K): K
public "containValue"(value: V): boolean
public "registerOrOverride"(key: K, value: V): V
public "spliterator"(): $Spliterator<(V)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<V>;
get "frozen"(): boolean
get "registryName"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTRegistry$Type<K, V> = ($GTRegistry<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTRegistry_<K, V> = $GTRegistry$Type<(K), (V)>;
}}
declare module "packages/com/gregtechceu/gtceu/api/capability/$IEnergyInfoProvider$EnergyInfo" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$BigInteger, $BigInteger$Type} from "packages/java/math/$BigInteger"

export class $IEnergyInfoProvider$EnergyInfo extends $Record {

constructor(capacity: $BigInteger$Type, stored: $BigInteger$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "capacity"(): $BigInteger
public "stored"(): $BigInteger
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEnergyInfoProvider$EnergyInfo$Type = ($IEnergyInfoProvider$EnergyInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IEnergyInfoProvider$EnergyInfo_ = $IEnergyInfoProvider$EnergyInfo$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/data/$GTSoundEntries" {
import {$SoundEntry, $SoundEntry$Type} from "packages/com/gregtechceu/gtceu/api/sound/$SoundEntry"

export class $GTSoundEntries {
static readonly "FORGE_HAMMER": $SoundEntry
static readonly "MACERATOR": $SoundEntry
static readonly "CHEMICAL": $SoundEntry
static readonly "ASSEMBLER": $SoundEntry
static readonly "CENTRIFUGE": $SoundEntry
static readonly "COMPRESSOR": $SoundEntry
static readonly "ELECTROLYZER": $SoundEntry
static readonly "MIXER": $SoundEntry
static readonly "REPLICATOR": $SoundEntry
static readonly "ARC": $SoundEntry
static readonly "BOILER": $SoundEntry
static readonly "FURNACE": $SoundEntry
static readonly "COOLING": $SoundEntry
static readonly "FIRE": $SoundEntry
static readonly "BATH": $SoundEntry
static readonly "MOTOR": $SoundEntry
static readonly "CUT": $SoundEntry
static readonly "TURBINE": $SoundEntry
static readonly "COMBUSTION": $SoundEntry
static readonly "COMPUTATION": $SoundEntry
static readonly "MINER": $SoundEntry
static readonly "SCIENCE": $SoundEntry
static readonly "JET_ENGINE": $SoundEntry
static readonly "WRENCH_TOOL": $SoundEntry
static readonly "SOFT_MALLET_TOOL": $SoundEntry
static readonly "DRILL_TOOL": $SoundEntry
static readonly "PLUNGER_TOOL": $SoundEntry
static readonly "FILE_TOOL": $SoundEntry
static readonly "SAW_TOOL": $SoundEntry
static readonly "SCREWDRIVER_TOOL": $SoundEntry
static readonly "CHAINSAW_TOOL": $SoundEntry
static readonly "WIRECUTTER_TOOL": $SoundEntry
static readonly "SPRAY_CAN_TOOL": $SoundEntry
static readonly "PORTABLE_SCANNER": $SoundEntry
static readonly "MORTAR_TOOL": $SoundEntry
static readonly "SUS_RECORD": $SoundEntry
static readonly "PORTAL_OPENING": $SoundEntry
static readonly "PORTAL_CLOSING": $SoundEntry
static readonly "METAL_PIPE": $SoundEntry

constructor()

public static "init"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTSoundEntries$Type = ($GTSoundEntries);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTSoundEntries_ = $GTSoundEntries$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/feature/$IVoidable" {
import {$IMachineFeature, $IMachineFeature$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/$IMachineFeature"
import {$MetaMachine, $MetaMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MetaMachine"
import {$RecipeCapability, $RecipeCapability$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$RecipeCapability"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $IVoidable extends $IMachineFeature {

 "getOutputLimits"(): $Map<($RecipeCapability<(any)>), (integer)>
 "canVoidRecipeOutputs"(capability: $RecipeCapability$Type<(any)>): boolean
 "self"(): $MetaMachine
}

export namespace $IVoidable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IVoidable$Type = ($IVoidable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IVoidable_ = $IVoidable$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pattern/$FactoryBlockPattern" {
import {$RelativeDirection, $RelativeDirection$Type} from "packages/com/gregtechceu/gtceu/api/pattern/util/$RelativeDirection"
import {$TraceabilityPredicate, $TraceabilityPredicate$Type} from "packages/com/gregtechceu/gtceu/api/pattern/$TraceabilityPredicate"
import {$BlockPattern, $BlockPattern$Type} from "packages/com/gregtechceu/gtceu/api/pattern/$BlockPattern"

export class $FactoryBlockPattern {


public static "start"(): $FactoryBlockPattern
public static "start"(charDir: $RelativeDirection$Type, stringDir: $RelativeDirection$Type, aisleDir: $RelativeDirection$Type): $FactoryBlockPattern
public "build"(): $BlockPattern
public "where"(symbol: string, blockMatcher: $TraceabilityPredicate$Type): $FactoryBlockPattern
public "where"(symbol: character, blockMatcher: $TraceabilityPredicate$Type): $FactoryBlockPattern
public "aisle"(...aisle: (string)[]): $FactoryBlockPattern
public "aisleRepeatable"(minRepeat: integer, maxRepeat: integer, ...aisle: (string)[]): $FactoryBlockPattern
public "setRepeatable"(repeatCount: integer): $FactoryBlockPattern
public "setRepeatable"(minRepeat: integer, maxRepeat: integer): $FactoryBlockPattern
set "repeatable"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FactoryBlockPattern$Type = ($FactoryBlockPattern);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FactoryBlockPattern_ = $FactoryBlockPattern$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/$BatteryBlock" {
import {$AppearanceBlock, $AppearanceBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$AppearanceBlock"
import {$IRenderer, $IRenderer$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IRenderer"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$IBlockRendererProvider, $IBlockRendererProvider$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IBlockRendererProvider"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IBatteryData, $IBatteryData$Type} from "packages/com/gregtechceu/gtceu/api/machine/multiblock/$IBatteryData"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export class $BatteryBlock extends $AppearanceBlock implements $IBlockRendererProvider {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, data: $IBatteryData$Type, renderer: $IRenderer$Type)

public "getData"(): $IBatteryData
public "getRenderer"(state: $BlockState$Type): $IRenderer
public "getLightMap"(world: $BlockAndTintGetter$Type, state: $BlockState$Type, pos: $BlockPos$Type): integer
get "data"(): $IBatteryData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BatteryBlock$Type = ($BatteryBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BatteryBlock_ = $BatteryBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/$GTStandingSignBlock" {
import {$IntegerProperty, $IntegerProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$IntegerProperty"
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$WoodType, $WoodType$Type} from "packages/net/minecraft/world/level/block/state/properties/$WoodType"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$StandingSignBlock, $StandingSignBlock$Type} from "packages/net/minecraft/world/level/block/$StandingSignBlock"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $GTStandingSignBlock extends $StandingSignBlock {
static readonly "ROTATION": $IntegerProperty
static readonly "WATERLOGGED": $BooleanProperty
static readonly "AABB_OFFSET": float
static readonly "SHAPE": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, type: $WoodType$Type)

public "getTicker"<T extends $BlockEntity>(level: $Level$Type, state: $BlockState$Type, blockEntityType: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(pos: $BlockPos$Type, state: $BlockState$Type): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTStandingSignBlock$Type = ($GTStandingSignBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTStandingSignBlock_ = $GTStandingSignBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/multiblock/$MultiblockControllerMachine" {
import {$MultiblockState, $MultiblockState$Type} from "packages/com/gregtechceu/gtceu/api/pattern/$MultiblockState"
import {$IMultiPart, $IMultiPart$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/multiblock/$IMultiPart"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Lock, $Lock$Type} from "packages/java/util/concurrent/locks/$Lock"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IMultiController, $IMultiController$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/multiblock/$IMultiController"
import {$ManagedFieldHolder, $ManagedFieldHolder$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/field/$ManagedFieldHolder"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IMachineBlockEntity, $IMachineBlockEntity$Type} from "packages/com/gregtechceu/gtceu/api/machine/$IMachineBlockEntity"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$MetaMachine, $MetaMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MetaMachine"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPattern, $BlockPattern$Type} from "packages/com/gregtechceu/gtceu/api/pattern/$BlockPattern"

export class $MultiblockControllerMachine extends $MetaMachine implements $IMultiController {
readonly "holder": $IMachineBlockEntity
 "isFirstDummyWorldTick": boolean

constructor(holder: $IMachineBlockEntity$Type)

public "onLoad"(): void
public "onRotated"(oldFacing: $Direction$Type, newFacing: $Direction$Type): void
public "getParts"(): $List<($IMultiPart)>
public "isFormed"(): boolean
public "onUnload"(): void
public "allowExtendedFacing"(): boolean
public "isFlipped"(): boolean
public "allowFlip"(): boolean
public "getMultiblockState"(): $MultiblockState
public "asyncCheckPattern"(periodID: long): void
public "onStructureFormed"(): void
public "onStructureInvalid"(): void
public "setUpwardsFacing"(upwardsFacing: $Direction$Type): void
public "setFlipped"(isFlipped: boolean): void
public "getPartPositions"(): ($BlockPos)[]
public "getUpwardsFacing"(): $Direction
public "getPatternLock"(): $Lock
public "getFieldHolder"(): $ManagedFieldHolder
public "isFacingValid"(facing: $Direction$Type): boolean
public "setFrontFacing"(facing: $Direction$Type): void
public "onPartUnload"(): void
public "checkPattern"(): boolean
public "getPattern"(): $BlockPattern
public "onUse"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
public "getPartAppearance"(part: $IMultiPart$Type, side: $Direction$Type, sourceState: $BlockState$Type, sourcePos: $BlockPos$Type): $BlockState
public "hasFrontFacing"(): boolean
public "checkPatternWithTryLock"(): boolean
public "checkPatternWithLock"(): boolean
public "shouldAddPartToController"(part: $IMultiPart$Type): boolean
public "onLeftClick"(player: $Player$Type, world: $Level$Type, hand: $InteractionHand$Type, pos: $BlockPos$Type, direction: $Direction$Type): boolean
get "parts"(): $List<($IMultiPart)>
get "formed"(): boolean
get "flipped"(): boolean
get "multiblockState"(): $MultiblockState
set "upwardsFacing"(value: $Direction$Type)
set "flipped"(value: boolean)
get "partPositions"(): ($BlockPos)[]
get "upwardsFacing"(): $Direction
get "patternLock"(): $Lock
get "fieldHolder"(): $ManagedFieldHolder
set "frontFacing"(value: $Direction$Type)
get "pattern"(): $BlockPattern
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiblockControllerMachine$Type = ($MultiblockControllerMachine);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiblockControllerMachine_ = $MultiblockControllerMachine$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IMaterialProperty" {
import {$MaterialProperties, $MaterialProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$MaterialProperties"

export interface $IMaterialProperty<T> {

 "verifyProperty"(arg0: $MaterialProperties$Type): void

(arg0: $MaterialProperties$Type): void
}

export namespace $IMaterialProperty {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMaterialProperty$Type<T> = ($IMaterialProperty<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMaterialProperty_<T> = $IMaterialProperty$Type<(T)>;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/armor/$IArmorLogic" {
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$HumanoidModel, $HumanoidModel$Type} from "packages/net/minecraft/client/model/$HumanoidModel"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$ArmorComponentItem, $ArmorComponentItem$Type} from "packages/com/gregtechceu/gtceu/api/item/armor/$ArmorComponentItem"
import {$EnumMap, $EnumMap$Type} from "packages/java/util/$EnumMap"
import {$ArmorItem$Type, $ArmorItem$Type$Type} from "packages/net/minecraft/world/item/$ArmorItem$Type"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export interface $IArmorLogic {

 "getAttributeModifiers"(slot: $EquipmentSlot$Type, stack: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
 "onArmorTick"(world: $Level$Type, player: $Player$Type, itemStack: $ItemStack$Type): void
 "getArmorTexture"(arg0: $ItemStack$Type, arg1: $Entity$Type, arg2: $EquipmentSlot$Type, arg3: string): $ResourceLocation
 "damageArmor"(entity: $LivingEntity$Type, itemStack: $ItemStack$Type, source: $DamageSource$Type, damage: integer, equipmentSlot: $EquipmentSlot$Type): void
 "renderHelmetOverlay"(itemStack: $ItemStack$Type, player: $Player$Type, partialTicks: float): void
 "getArmorModel"(entityLiving: $LivingEntity$Type, itemStack: $ItemStack$Type, armorSlot: $EquipmentSlot$Type, defaultModel: $HumanoidModel$Type<(any)>): $HumanoidModel<(any)>
 "addToolComponents"(item: $ArmorComponentItem$Type): void
 "getArmorType"(): $ArmorItem$Type
 "getArmorDisplay"(arg0: $Player$Type, arg1: $ItemStack$Type, arg2: $EquipmentSlot$Type): integer
 "getHeatResistance"(): float
 "canBreakWithDamage"(stack: $ItemStack$Type): boolean
 "isValidArmor"(itemStack: $ItemStack$Type, entity: $Entity$Type, equipmentSlot: $EquipmentSlot$Type): boolean
 "isPPE"(): boolean
 "getArmorLayerColor"(itemStack: $ItemStack$Type, layerIndex: integer): integer
 "getArmorLayersAmount"(itemStack: $ItemStack$Type): integer
}

export namespace $IArmorLogic {
const ATTACK_DAMAGE_MODIFIER: $UUID
const ATTACK_SPEED_MODIFIER: $UUID
const ARMOR_MODIFIER_UUID_PER_TYPE: $EnumMap<($ArmorItem$Type), ($UUID)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IArmorLogic$Type = ($IArmorLogic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IArmorLogic_ = $IArmorLogic$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pipenet/$PipeCoverContainer" {
import {$ICoverable, $ICoverable$Type} from "packages/com/gregtechceu/gtceu/api/capability/$ICoverable"
import {$IFieldUpdateListener, $IFieldUpdateListener$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$IFieldUpdateListener"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CoverDefinition, $CoverDefinition$Type} from "packages/com/gregtechceu/gtceu/api/cover/$CoverDefinition"
import {$CoverBehavior, $CoverBehavior$Type} from "packages/com/gregtechceu/gtceu/api/cover/$CoverBehavior"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IFluidTransfer, $IFluidTransfer$Type} from "packages/com/lowdragmc/lowdraglib/side/fluid/$IFluidTransfer"
import {$TickableSubscription, $TickableSubscription$Type} from "packages/com/gregtechceu/gtceu/api/machine/$TickableSubscription"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$IPipeNode, $IPipeNode$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeNode"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$FieldManagedStorage, $FieldManagedStorage$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/field/$FieldManagedStorage"
import {$ISubscription, $ISubscription$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$ISubscription"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$IItemTransfer, $IItemTransfer$Type} from "packages/com/lowdragmc/lowdraglib/side/item/$IItemTransfer"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IRef, $IRef$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/managed/$IRef"
import {$ManagedFieldHolder, $ManagedFieldHolder$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/field/$ManagedFieldHolder"
import {$IEnhancedManaged, $IEnhancedManaged$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$IEnhancedManaged"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export class $PipeCoverContainer implements $ICoverable, $IEnhancedManaged {
static readonly "MANAGED_FIELD_HOLDER": $ManagedFieldHolder

constructor(pipeTile: $IPipeNode$Type<(any), (any)>)

public "getLevel"(): $Level
public "unsubscribe"(current: $TickableSubscription$Type): void
public "getPos"(): $BlockPos
public "markDirty"(): void
public "getSyncStorage"(): $FieldManagedStorage
public "onChanged"(): void
public "notifyBlockUpdate"(): void
public "canPlaceCoverOnSide"(definition: $CoverDefinition$Type, side: $Direction$Type): boolean
public "shouldRenderBackSide"(): boolean
public "getCoverPlateThickness"(): double
public "getCoverAtSide"(side: $Direction$Type): $CoverBehavior
public "setCoverAtSide"(coverBehavior: $CoverBehavior$Type, side: $Direction$Type): void
public "scheduleRenderUpdate"(): void
public "scheduleNeighborShapeUpdate"(): void
public "subscribeServerTick"(runnable: $Runnable$Type): $TickableSubscription
public "getFrontFacing"(): $Direction
public "getOffsetTimer"(): long
public "getFieldHolder"(): $ManagedFieldHolder
public "isInValid"(): boolean
public "getItemTransferCap"(side: $Direction$Type, useCoverCapability: boolean): $IItemTransfer
public "getFluidTransferCap"(side: $Direction$Type, useCoverCapability: boolean): $IFluidTransfer
public "onLoad"(): void
public "onNeighborChanged"(block: $Block$Type, fromPos: $BlockPos$Type, isMoving: boolean): void
public "isRemote"(): boolean
public "onUnload"(): void
public static "rayTraceCoverableSide"(coverable: $ICoverable$Type, player: $Player$Type): $Direction
public static "getCoverPlateBox"(side: $Direction$Type, plateThickness: double): $VoxelShape
public "hasCover"(facing: $Direction$Type): boolean
public "placeCoverOnSide"(side: $Direction$Type, itemStack: $ItemStack$Type, coverDefinition: $CoverDefinition$Type, player: $ServerPlayer$Type): boolean
public static "traceCoverSide"(result: $BlockHitResult$Type): $Direction
public static "doesCoverCollide"(side: $Direction$Type, collisionBox: $List$Type<($VoxelShape$Type)>, plateThickness: double): boolean
public "getBlockAppearance"(state: $BlockState$Type, level: $BlockAndTintGetter$Type, pos: $BlockPos$Type, side: $Direction$Type, sourceState: $BlockState$Type, sourcePos: $BlockPos$Type): $BlockState
public static "determineGridSideHit"(result: $BlockHitResult$Type): $Direction
public "addCoverCollisionBoundingBox"(): ($VoxelShape)[]
public "dropAllCovers"(): void
public static "canPlaceCover"(coverDef: $CoverDefinition$Type, coverable: $ICoverable$Type): boolean
public "hasAnyCover"(): boolean
public "removeCover"(side: $Direction$Type, player: $Player$Type): boolean
public "removeCover"(dropItself: boolean, side: $Direction$Type, player: $Player$Type): boolean
public "getCovers"(): $List<($CoverBehavior)>
public "scheduleRender"(fieldName: string, newValue: any, oldValue: any): void
public "subscribeServerTick"(last: $TickableSubscription$Type, runnable: $Runnable$Type): $TickableSubscription
public "markDirty"(name: string): void
public "onPersistedChanged"(ref: $IRef$Type, isDirty: boolean): void
public "onSyncChanged"(ref: $IRef$Type, isDirty: boolean): void
public "addSyncUpdateListener"<T>(name: string, listener: $IFieldUpdateListener$Type<(T)>): $ISubscription
get "level"(): $Level
get "pos"(): $BlockPos
get "syncStorage"(): $FieldManagedStorage
get "coverPlateThickness"(): double
get "frontFacing"(): $Direction
get "offsetTimer"(): long
get "fieldHolder"(): $ManagedFieldHolder
get "inValid"(): boolean
get "remote"(): boolean
get "covers"(): $List<($CoverBehavior)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PipeCoverContainer$Type = ($PipeCoverContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PipeCoverContainer_ = $PipeCoverContainer$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$CuboidVeinGenerator" {
import {$GTOreDefinition, $GTOreDefinition$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTOreDefinition"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$OreConfiguration$TargetBlockState, $OreConfiguration$TargetBlockState$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$OreConfiguration$TargetBlockState"
import {$BulkSectionAccess, $BulkSectionAccess$Type} from "packages/net/minecraft/world/level/chunk/$BulkSectionAccess"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$LevelChunkSection, $LevelChunkSection$Type} from "packages/net/minecraft/world/level/chunk/$LevelChunkSection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$VeinGenerator, $VeinGenerator$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/$VeinGenerator"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $CuboidVeinGenerator extends $VeinGenerator {
static readonly "LAYER_CODEC": $Codec<($Either<($List<($OreConfiguration$TargetBlockState)>), ($Material)>)>
static readonly "CODEC": $Codec<($CuboidVeinGenerator)>
static readonly "REGISTRY_CODEC": $Codec<($Codec<(any)>)>
static readonly "DIRECT_CODEC": $Codec<($VeinGenerator)>

constructor(entry: $GTOreDefinition$Type)
constructor(top: $Either$Type<($List$Type<($OreConfiguration$TargetBlockState$Type)>), ($Material$Type)>, middle: $Either$Type<($List$Type<($OreConfiguration$TargetBlockState$Type)>), ($Material$Type)>, bottom: $Either$Type<($List$Type<($OreConfiguration$TargetBlockState$Type)>), ($Material$Type)>, spread: $Either$Type<($List$Type<($OreConfiguration$TargetBlockState$Type)>), ($Material$Type)>, minY: integer, maxY: integer)

public "copy"(): $VeinGenerator
public "codec"(): $Codec<(any)>
public "getAllEntries"(): $List<($Map$Entry<($Either<($BlockState), ($Material)>), (integer)>)>
public "placeOre"(access: $BulkSectionAccess$Type, section: $LevelChunkSection$Type, pos: $BlockPos$Type, randomSeed: long, ore: $Either$Type<($List$Type<($OreConfiguration$TargetBlockState$Type)>), ($Material$Type)>, entry: $GTOreDefinition$Type): void
get "allEntries"(): $List<($Map$Entry<($Either<($BlockState), ($Material)>), (integer)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CuboidVeinGenerator$Type = ($CuboidVeinGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CuboidVeinGenerator_ = $CuboidVeinGenerator$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/blockentity/$ITickSubscription" {
import {$TickableSubscription, $TickableSubscription$Type} from "packages/com/gregtechceu/gtceu/api/machine/$TickableSubscription"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export interface $ITickSubscription {

 "unsubscribe"(arg0: $TickableSubscription$Type): void
 "subscribeServerTick"(arg0: $Runnable$Type): $TickableSubscription
 "subscribeServerTick"(last: $TickableSubscription$Type, runnable: $Runnable$Type): $TickableSubscription
}

export namespace $ITickSubscription {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITickSubscription$Type = ($ITickSubscription);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITickSubscription_ = $ITickSubscription$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/$FusionCasingBlock" {
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$ActiveBlock, $ActiveBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$ActiveBlock"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$IFusionCasingType, $IFusionCasingType$Type} from "packages/com/gregtechceu/gtceu/api/block/$IFusionCasingType"

export class $FusionCasingBlock extends $ActiveBlock {
static readonly "ACTIVE": $BooleanProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, casingType: $IFusionCasingType$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FusionCasingBlock$Type = ($FusionCasingBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FusionCasingBlock_ = $FusionCasingBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/fluids/attribute/$FluidAttribute" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $FluidAttribute {

constructor(resourceLocation: $ResourceLocation$Type, fluidTooltip: $Consumer$Type<($List$Type<($Component$Type)>)>, containerTooltip: $Consumer$Type<($List$Type<($Component$Type)>)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "appendFluidTooltips"(tooltip: $List$Type<($Component$Type)>): void
public "getResourceLocation"(): $ResourceLocation
public "appendContainerTooltips"(tooltip: $List$Type<($Component$Type)>): void
get "resourceLocation"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidAttribute$Type = ($FluidAttribute);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidAttribute_ = $FluidAttribute$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/sound/$AutoReleasedSound" {
import {$Sound, $Sound$Type} from "packages/net/minecraft/client/resources/sounds/$Sound"
import {$BooleanSupplier, $BooleanSupplier$Type} from "packages/java/util/function/$BooleanSupplier"
import {$SoundInstance$Attenuation, $SoundInstance$Attenuation$Type} from "packages/net/minecraft/client/resources/sounds/$SoundInstance$Attenuation"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$SoundEntry, $SoundEntry$Type} from "packages/com/gregtechceu/gtceu/api/sound/$SoundEntry"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$SoundSource, $SoundSource$Type} from "packages/net/minecraft/sounds/$SoundSource"
import {$AbstractTickableSoundInstance, $AbstractTickableSoundInstance$Type} from "packages/net/minecraft/client/resources/sounds/$AbstractTickableSoundInstance"

export class $AutoReleasedSound extends $AbstractTickableSoundInstance {
readonly "predicate": $BooleanSupplier
readonly "soundEntry": $SoundEntry
 "sound": $Sound
readonly "source": $SoundSource
readonly "location": $ResourceLocation
 "volume": float
 "pitch": float
 "x": double
 "y": double
 "z": double
 "looping": boolean
 "delay": integer
 "attenuation": $SoundInstance$Attenuation
 "relative": boolean
 "random": $RandomSource


public "release"(): void
public "tick"(): void
public static "createUnseededRandom"(): $RandomSource
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AutoReleasedSound$Type = ($AutoReleasedSound);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AutoReleasedSound_ = $AutoReleasedSound$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/$BiomeWeightModifier" {
import {$HolderSet, $HolderSet$Type} from "packages/net/minecraft/core/$HolderSet"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Biome, $Biome$Type} from "packages/net/minecraft/world/level/biome/$Biome"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $BiomeWeightModifier implements $Function<($Holder<($Biome)>), (integer)> {
static readonly "EMPTY": $BiomeWeightModifier
static readonly "CODEC": $Codec<($BiomeWeightModifier)>
 "biomes": $Supplier<($HolderSet<($Biome)>)>
 "addedWeight": integer

constructor(biomes: $Supplier$Type<($HolderSet$Type<($Biome$Type)>)>, addedWeight: integer)

public "apply"(biome: $Holder$Type<($Biome$Type)>): integer
public static "identity"<T>(): $Function<($Holder<($Biome)>), ($Holder<($Biome)>)>
public "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (integer)>
public "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<($Holder<($Biome)>), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeWeightModifier$Type = ($BiomeWeightModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BiomeWeightModifier_ = $BiomeWeightModifier$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/feature/$IDataInfoProvider" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$PortableScannerBehavior$DisplayMode, $PortableScannerBehavior$DisplayMode$Type} from "packages/com/gregtechceu/gtceu/common/item/$PortableScannerBehavior$DisplayMode"

export interface $IDataInfoProvider {

 "getDataInfo"(arg0: $PortableScannerBehavior$DisplayMode$Type): $List<($Component)>
 "getDebugInfo"(player: $Player$Type, logLevel: integer, mode: $PortableScannerBehavior$DisplayMode$Type): $List<($Component)>

(arg0: $PortableScannerBehavior$DisplayMode$Type): $List<($Component)>
}

export namespace $IDataInfoProvider {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IDataInfoProvider$Type = ($IDataInfoProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IDataInfoProvider_ = $IDataInfoProvider$Type;
}}
declare module "packages/com/gregtechceu/gtceu/client/renderer/cover/$ICoverableRenderer" {
import {$ICoverable, $ICoverable$Type} from "packages/com/gregtechceu/gtceu/api/capability/$ICoverable"
import {$ModelState, $ModelState$Type} from "packages/net/minecraft/client/resources/model/$ModelState"
import {$IRenderer, $IRenderer$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IRenderer"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ItemDisplayContext, $ItemDisplayContext$Type} from "packages/net/minecraft/world/item/$ItemDisplayContext"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"
import {$BakedQuad, $BakedQuad$Type} from "packages/net/minecraft/client/renderer/block/model/$BakedQuad"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export interface $ICoverableRenderer extends $IRenderer {

 "renderModel"(level: $BlockAndTintGetter$Type, pos: $BlockPos$Type, state: $BlockState$Type, side: $Direction$Type, rand: $RandomSource$Type): $List<($BakedQuad)>
 "renderCovers"(quads: $List$Type<($BakedQuad$Type)>, side: $Direction$Type, rand: $RandomSource$Type, coverable: $ICoverable$Type, modelFacing: $Direction$Type, pos: $BlockPos$Type, level: $BlockAndTintGetter$Type, modelState: $ModelState$Type): void
 "render"(blockEntity: $BlockEntity$Type, partialTicks: float, stack: $PoseStack$Type, buffer: $MultiBufferSource$Type, combinedLight: integer, combinedOverlay: integer): void
 "isRaw"(): boolean
 "shouldRender"(blockEntity: $BlockEntity$Type, cameraPos: $Vec3$Type): boolean
 "onPrepareTextureAtlas"(atlasName: $ResourceLocation$Type, register: $Consumer$Type<($ResourceLocation$Type)>): void
 "reBakeCustomQuadsOffset"(): float
 "reBakeCustomQuads"(): boolean
 "isGui3d"(): boolean
 "isGlobalRenderer"(blockEntity: $BlockEntity$Type): boolean
 "hasTESR"(blockEntity: $BlockEntity$Type): boolean
 "getParticleTexture"(): $TextureAtlasSprite
 "useAO"(state: $BlockState$Type): boolean
 "useAO"(): boolean
 "getViewDistance"(): integer
 "useBlockLight"(stack: $ItemStack$Type): boolean
 "renderItem"(stack: $ItemStack$Type, transformType: $ItemDisplayContext$Type, leftHand: boolean, poseStack: $PoseStack$Type, buffer: $MultiBufferSource$Type, combinedLight: integer, combinedOverlay: integer, model: $BakedModel$Type): void
 "registerEvent"(): void
 "onAdditionalModel"(registry: $Consumer$Type<($ResourceLocation$Type)>): void
}

export namespace $ICoverableRenderer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICoverableRenderer$Type = ($ICoverableRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICoverableRenderer_ = $ICoverableRenderer$Type;
}}
declare module "packages/com/gregtechceu/gtceu/integration/kjs/events/$GTFluidVeinEventJS" {
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$BedrockFluidDefinition$Builder, $BedrockFluidDefinition$Builder$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/bedrockfluid/$BedrockFluidDefinition$Builder"
import {$BedrockFluidDefinition, $BedrockFluidDefinition$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/bedrockfluid/$BedrockFluidDefinition"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $GTFluidVeinEventJS extends $EventJS {

constructor()

public "add"(id: $ResourceLocation$Type, consumer: $Consumer$Type<($BedrockFluidDefinition$Builder$Type)>): void
public "remove"(id: $ResourceLocation$Type): void
public "modify"(id: $ResourceLocation$Type, consumer: $Consumer$Type<($BedrockFluidDefinition$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTFluidVeinEventJS$Type = ($GTFluidVeinEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTFluidVeinEventJS_ = $GTFluidVeinEventJS$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$HazardProperty$ProtectionType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$ArmorItem$Type, $ArmorItem$Type$Type} from "packages/net/minecraft/world/item/$ArmorItem$Type"

export class $HazardProperty$ProtectionType extends $Enum<($HazardProperty$ProtectionType)> {
static readonly "MASK": $HazardProperty$ProtectionType
static readonly "HANDS": $HazardProperty$ProtectionType
static readonly "FULL": $HazardProperty$ProtectionType
static readonly "NONE": $HazardProperty$ProtectionType


public static "values"(): ($HazardProperty$ProtectionType)[]
public static "valueOf"(name: string): $HazardProperty$ProtectionType
public "isProtected"(livingEntity: $LivingEntity$Type): boolean
public "getEquipmentTypes"(): $Set<($ArmorItem$Type)>
get "equipmentTypes"(): $Set<($ArmorItem$Type)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HazardProperty$ProtectionType$Type = (("hands") | ("none") | ("mask") | ("full")) | ($HazardProperty$ProtectionType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HazardProperty$ProtectionType_ = $HazardProperty$ProtectionType$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/capability/recipe/$IRecipeHandler" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$GTRecipe, $GTRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe"
import {$RecipeCapability, $RecipeCapability$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$RecipeCapability"
import {$IO, $IO$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IO"
import {$IRecipeCapabilityHolder, $IRecipeCapabilityHolder$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IRecipeCapabilityHolder"
import {$IFilteredHandler, $IFilteredHandler$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IFilteredHandler"

export interface $IRecipeHandler<K> extends $IFilteredHandler<(K)> {

 "getSize"(): integer
 "getContents"(): $List<(any)>
 "isProxy"(): boolean
 "getCapability"(): $RecipeCapability<(K)>
 "handleRecipe"(io: $IO$Type, recipe: $GTRecipe$Type, left: $List$Type<(any)>, slotName: string, simulate: boolean): $List<(K)>
 "preWorking"(holder: $IRecipeCapabilityHolder$Type, io: $IO$Type, recipe: $GTRecipe$Type): void
 "postWorking"(holder: $IRecipeCapabilityHolder$Type, io: $IO$Type, recipe: $GTRecipe$Type): void
 "copyContent"(content: any): K
 "isDistinct"(): boolean
 "getTotalContentAmount"(): double
 "getSlotNames"(): $Set<(string)>
 "handleRecipeInner"(arg0: $IO$Type, arg1: $GTRecipe$Type, arg2: $List$Type<(K)>, arg3: string, arg4: boolean): $List<(K)>
 "test"(ingredient: K): boolean
 "getPriority"(): integer
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
 "negate"(): $Predicate<(K)>
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
}

export namespace $IRecipeHandler {
const ENTRY_COMPARATOR: $Comparator<($IRecipeHandler<(any)>)>
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
function isEqual<T>(arg0: any): $Predicate<(K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRecipeHandler$Type<K> = ($IRecipeHandler<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRecipeHandler_<K> = $IRecipeHandler$Type<(K)>;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/$StoneBlockType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $StoneBlockType extends $Enum<($StoneBlockType)> {
static readonly "STONE": $StoneBlockType
static readonly "COBBLE": $StoneBlockType
static readonly "COBBLE_MOSSY": $StoneBlockType
static readonly "POLISHED": $StoneBlockType
static readonly "BRICKS": $StoneBlockType
static readonly "BRICKS_CRACKED": $StoneBlockType
static readonly "BRICKS_MOSSY": $StoneBlockType
static readonly "CHISELED": $StoneBlockType
static readonly "TILED": $StoneBlockType
static readonly "TILED_SMALL": $StoneBlockType
static readonly "WINDMILL_A": $StoneBlockType
static readonly "WINDMILL_B": $StoneBlockType
static readonly "BRICKS_SMALL": $StoneBlockType
static readonly "BRICKS_SQUARE": $StoneBlockType
readonly "id": string
readonly "blockId": string
readonly "hardness": float
readonly "resistance": float


public static "values"(): ($StoneBlockType)[]
public static "valueOf"(name: string): $StoneBlockType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StoneBlockType$Type = (("bricks") | ("bricks_mossy") | ("tiled") | ("windmill_a") | ("windmill_b") | ("bricks_small") | ("bricks_cracked") | ("cobble_mossy") | ("stone") | ("polished") | ("tiled_small") | ("chiseled") | ("bricks_square") | ("cobble")) | ($StoneBlockType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StoneBlockType_ = $StoneBlockType$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/$ShapedEnergyTransferRecipe" {
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$ShapedRecipe, $ShapedRecipe$Type} from "packages/net/minecraft/world/item/crafting/$ShapedRecipe"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$CraftingContainer, $CraftingContainer$Type} from "packages/net/minecraft/world/inventory/$CraftingContainer"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$CraftingBookCategory, $CraftingBookCategory$Type} from "packages/net/minecraft/world/item/crafting/$CraftingBookCategory"

export class $ShapedEnergyTransferRecipe extends $ShapedRecipe {
static readonly "SERIALIZER": $RecipeSerializer<($ShapedEnergyTransferRecipe)>
static "MAX_WIDTH": integer
static "MAX_HEIGHT": integer
readonly "width": integer
readonly "height": integer
readonly "recipeItems": $NonNullList<($Ingredient)>
readonly "result": $ItemStack
readonly "group": string
readonly "category": $CraftingBookCategory
readonly "showNotification": boolean

constructor(id: $ResourceLocation$Type, group: string, width: integer, height: integer, chargeIngredient: $Ingredient$Type, overrideCharge: boolean, transferMaxCharge: boolean, recipeItems: $NonNullList$Type<($Ingredient$Type)>, result: $ItemStack$Type)

public "assemble"(craftingContainer: $CraftingContainer$Type, registryAccess: $RegistryAccess$Type): $ItemStack
public "getResultItem"(registryAccess: $RegistryAccess$Type): $ItemStack
public "isOverrideCharge"(): boolean
public "getChargeIngredient"(): $Ingredient
public "isTransferMaxCharge"(): boolean
get "overrideCharge"(): boolean
get "chargeIngredient"(): $Ingredient
get "transferMaxCharge"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapedEnergyTransferRecipe$Type = ($ShapedEnergyTransferRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShapedEnergyTransferRecipe_ = $ShapedEnergyTransferRecipe$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/ingredient/$FluidIngredient$Value" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"

export interface $FluidIngredient$Value {

 "copy"(): $FluidIngredient$Value
 "serialize"(): $JsonObject
 "getFluids"(): $Collection<($Fluid)>
}

export namespace $FluidIngredient$Value {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidIngredient$Value$Type = ($FluidIngredient$Value);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidIngredient$Value_ = $FluidIngredient$Value$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/$MinerPipeBlock" {
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $MinerPipeBlock extends $Block {
static "SHAPE": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type)

public "getShape"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type, context: $CollisionContext$Type): $VoxelShape
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinerPipeBlock$Type = ($MinerPipeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MinerPipeBlock_ = $MinerPipeBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/$RotationState" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"

export class $RotationState extends $Enum<($RotationState)> implements $Predicate<($Direction)> {
static readonly "ALL": $RotationState
static readonly "NONE": $RotationState
static readonly "Y_AXIS": $RotationState
static readonly "NON_Y_AXIS": $RotationState
readonly "defaultDirection": $Direction
readonly "property": $DirectionProperty


public static "get"(): $RotationState
public static "values"(): ($RotationState)[]
public "test"(dir: $Direction$Type): boolean
public static "valueOf"(name: string): $RotationState
public static "clear"(): void
public static "set"(state: $RotationState$Type): void
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($Direction)>
public "negate"(): $Predicate<($Direction)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($Direction)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($Direction)>
public static "isEqual"<T>(arg0: any): $Predicate<($Direction)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RotationState$Type = (("all") | ("y_axis") | ("non_y_axis") | ("none")) | ($RotationState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RotationState_ = $RotationState$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/fluids/$FluidState" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $FluidState extends $Enum<($FluidState)> {
static readonly "LIQUID": $FluidState
static readonly "GAS": $FluidState
static readonly "PLASMA": $FluidState


public static "values"(): ($FluidState)[]
public static "valueOf"(name: string): $FluidState
public "getTranslationKey"(): string
get "translationKey"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidState$Type = (("liquid") | ("gas") | ("plasma")) | ($FluidState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidState_ = $FluidState$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pipenet/$PipeNet" {
import {$ChunkPos, $ChunkPos$Type} from "packages/net/minecraft/world/level/$ChunkPos"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ITagSerializable, $ITagSerializable$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$ITagSerializable"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Node, $Node$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$Node"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$LevelPipeNet, $LevelPipeNet$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$LevelPipeNet"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $PipeNet<NodeDataType> implements $ITagSerializable<($CompoundTag)> {

constructor(Level: $LevelPipeNet$Type<(NodeDataType), (any)>)

public "removeNode"(nodePos: $BlockPos$Type): void
public "isValid"(): boolean
public "getLevel"(): $ServerLevel
public "getAllNodes"(): $Map<($BlockPos), ($Node<(NodeDataType)>)>
public "containsNode"(blockPos: $BlockPos$Type): boolean
public "isNodeConnectedTo"(pos: $BlockPos$Type, side: $Direction$Type): boolean
public "getLastUpdate"(): long
public "getWorldData"(): $LevelPipeNet<(NodeDataType), ($PipeNet<(NodeDataType)>)>
public "deserializeNBT"(nbt: $CompoundTag$Type): void
public "serializeNBT"(): $CompoundTag
public "updateBlockedConnections"(nodePos: $BlockPos$Type, facing: $Direction$Type, isBlocked: boolean): void
public "onPipeConnectionsUpdate"(): void
public "getContainedChunks"(): $Set<($ChunkPos)>
public "updateMark"(nodePos: $BlockPos$Type, newMark: integer): void
public "updateNodeData"(nodePos: $BlockPos$Type, data: NodeDataType): void
public "getNodeAt"(blockPos: $BlockPos$Type): $Node<(NodeDataType)>
public "onNeighbourUpdate"(fromPos: $BlockPos$Type): void
public "markNodeAsActive"(nodePos: $BlockPos$Type, isActive: boolean): boolean
get "valid"(): boolean
get "level"(): $ServerLevel
get "allNodes"(): $Map<($BlockPos), ($Node<(NodeDataType)>)>
get "lastUpdate"(): long
get "worldData"(): $LevelPipeNet<(NodeDataType), ($PipeNet<(NodeDataType)>)>
get "containedChunks"(): $Set<($ChunkPos)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PipeNet$Type<NodeDataType> = ($PipeNet<(NodeDataType)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PipeNet_<NodeDataType> = $PipeNet$Type<(NodeDataType)>;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/$IndicatorGenerator" {
import {$GTOreDefinition, $GTOreDefinition$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTOreDefinition"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $IndicatorGenerator {
static readonly "REGISTRY_CODEC": $Codec<($Codec<(any)>)>
static readonly "DIRECT_CODEC": $Codec<($IndicatorGenerator)>

constructor()
constructor(entry: $GTOreDefinition$Type)

public "codec"(): $Codec<(any)>
public "getSearchRadiusModifier"(arg0: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IndicatorGenerator$Type = ($IndicatorGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IndicatorGenerator_ = $IndicatorGenerator$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$Symptom$Effect" {
import {$MedicalConditionTracker, $MedicalConditionTracker$Type} from "packages/com/gregtechceu/gtceu/common/capability/$MedicalConditionTracker"
import {$Symptom$ConfiguredSymptom, $Symptom$ConfiguredSymptom$Type} from "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$Symptom$ConfiguredSymptom"
import {$MedicalCondition, $MedicalCondition$Type} from "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$MedicalCondition"
import {$Symptom, $Symptom$Type} from "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$Symptom"

export interface $Symptom$Effect {

 "apply"(arg0: $MedicalConditionTracker$Type, arg1: $MedicalCondition$Type, arg2: $Symptom$ConfiguredSymptom$Type, arg3: $Symptom$Type, arg4: integer): void

(arg0: $MedicalConditionTracker$Type, arg1: $MedicalCondition$Type, arg2: $Symptom$ConfiguredSymptom$Type, arg3: $Symptom$Type, arg4: integer): void
}

export namespace $Symptom$Effect {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Symptom$Effect$Type = ($Symptom$Effect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Symptom$Effect_ = $Symptom$Effect$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/cover/$CoverDefinition" {
import {$ICoverRenderer, $ICoverRenderer$Type} from "packages/com/gregtechceu/gtceu/client/renderer/cover/$ICoverRenderer"
import {$ICoverable, $ICoverable$Type} from "packages/com/gregtechceu/gtceu/api/capability/$ICoverable"
import {$CoverDefinition$CoverBehaviourProvider, $CoverDefinition$CoverBehaviourProvider$Type} from "packages/com/gregtechceu/gtceu/api/cover/$CoverDefinition$CoverBehaviourProvider"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CoverBehavior, $CoverBehavior$Type} from "packages/com/gregtechceu/gtceu/api/cover/$CoverBehavior"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $CoverDefinition {

constructor(id: $ResourceLocation$Type, behaviorCreator: $CoverDefinition$CoverBehaviourProvider$Type, coverRenderer: $ICoverRenderer$Type)

public "getId"(): $ResourceLocation
public "createCoverBehavior"(metaTileEntity: $ICoverable$Type, side: $Direction$Type): $CoverBehavior
public "getCoverRenderer"(): $ICoverRenderer
get "id"(): $ResourceLocation
get "coverRenderer"(): $ICoverRenderer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoverDefinition$Type = ($CoverDefinition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CoverDefinition_ = $CoverDefinition$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/blockentity/$ItemPipeBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$ItemPipeProperties, $ItemPipeProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$ItemPipeProperties"
import {$ItemPipeNet, $ItemPipeNet$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/item/$ItemPipeNet"
import {$IItemTransfer, $IItemTransfer$Type} from "packages/com/lowdragmc/lowdraglib/side/item/$IItemTransfer"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemPipeType, $ItemPipeType$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/item/$ItemPipeType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$FacingPos, $FacingPos$Type} from "packages/com/gregtechceu/gtceu/utils/$FacingPos"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$PipeBlockEntity, $PipeBlockEntity$Type} from "packages/com/gregtechceu/gtceu/api/blockentity/$PipeBlockEntity"
import {$AttachmentTarget, $AttachmentTarget$Type} from "packages/net/fabricmc/fabric/api/attachment/v1/$AttachmentTarget"
import {$ManagedFieldHolder, $ManagedFieldHolder$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/field/$ManagedFieldHolder"
import {$ItemNetHandler, $ItemNetHandler$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/item/$ItemNetHandler"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$EnumMap, $EnumMap$Type} from "packages/java/util/$EnumMap"
import {$Object2IntMap, $Object2IntMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntMap"

export class $ItemPipeBlockEntity extends $PipeBlockEntity<($ItemPipeType), ($ItemPipeProperties)> {
static readonly "MANAGED_FIELD_HOLDER": $ManagedFieldHolder
 "level": $Level
 "worldPosition": $BlockPos
 "remove": boolean
 "hasComparators": byte

constructor(type: $BlockEntityType$Type<(any)>, pos: $BlockPos$Type, blockState: $BlockState$Type)

public static "create"(type: $BlockEntityType$Type<(any)>, pos: $BlockPos$Type, blockState: $BlockState$Type): $ItemPipeBlockEntity
public "getHandler"(side: $Direction$Type, useCoverCapability: boolean): $IItemTransfer
public "getHandlers"(): $EnumMap<($Direction), ($ItemNetHandler)>
public "getCapability"<T>(cap: $Capability$Type<(T)>, side: $Direction$Type): $LazyOptional<(T)>
public "getDefaultHandler"(): $ItemNetHandler
public static "onBlockEntityRegister"(itemPipeBlockEntityBlockEntityType: $BlockEntityType$Type<($ItemPipeBlockEntity$Type)>): void
public "onChunkUnloaded"(): void
public "canAttachTo"(side: $Direction$Type): boolean
public "getTransferredItems"(): integer
public "addTransferredItems"(amount: integer): void
public "checkNetwork"(): void
public "initHandlers"(): void
public "getLevelTime"(): long
public "resetTransferred"(): void
public "getItemPipeNet"(): $ItemPipeNet
public "getTransferred"(): $Object2IntMap<($FacingPos)>
public static "transfer"(original: $AttachmentTarget$Type, target: $AttachmentTarget$Type, isDeath: boolean): void
get "handlers"(): $EnumMap<($Direction), ($ItemNetHandler)>
get "defaultHandler"(): $ItemNetHandler
get "transferredItems"(): integer
get "levelTime"(): long
get "itemPipeNet"(): $ItemPipeNet
get "transferred"(): $Object2IntMap<($FacingPos)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPipeBlockEntity$Type = ($ItemPipeBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemPipeBlockEntity_ = $ItemPipeBlockEntity$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$GeodeVeinGenerator" {
import {$GTOreDefinition, $GTOreDefinition$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTOreDefinition"
import {$GeodeVeinGenerator$GeodeBlockSettings, $GeodeVeinGenerator$GeodeBlockSettings$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$GeodeVeinGenerator$GeodeBlockSettings"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$GeodeCrackSettings, $GeodeCrackSettings$Type} from "packages/net/minecraft/world/level/levelgen/$GeodeCrackSettings"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IntProvider, $IntProvider$Type} from "packages/net/minecraft/util/valueproviders/$IntProvider"
import {$VeinGenerator, $VeinGenerator$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/$VeinGenerator"
import {$GeodeLayerSettings, $GeodeLayerSettings$Type} from "packages/net/minecraft/world/level/levelgen/$GeodeLayerSettings"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $GeodeVeinGenerator extends $VeinGenerator {
static readonly "CHANCE_RANGE": $Codec<(double)>
static readonly "CODEC": $Codec<($GeodeVeinGenerator)>
 "geodeBlockSettings": $GeodeVeinGenerator$GeodeBlockSettings
 "geodeLayerSettings": $GeodeLayerSettings
 "geodeCrackSettings": $GeodeCrackSettings
 "usePotentialPlacementsChance": double
 "useAlternateLayer0Chance": double
 "placementsRequireLayer0Alternate": boolean
 "outerWallDistance": $IntProvider
 "distributionPoints": $IntProvider
 "pointOffset": $IntProvider
 "minGenOffset": integer
 "maxGenOffset": integer
 "noiseMultiplier": double
 "invalidBlocksThreshold": integer
static readonly "REGISTRY_CODEC": $Codec<($Codec<(any)>)>
static readonly "DIRECT_CODEC": $Codec<($VeinGenerator)>

constructor(entry: $GTOreDefinition$Type)
constructor(geodeBlockSettings: $GeodeVeinGenerator$GeodeBlockSettings$Type, geodeLayerSettings: $GeodeLayerSettings$Type, geodeCrackSettings: $GeodeCrackSettings$Type, usePotentialPlacementsChance: double, useAlternateLayer0Chance: double, placementsRequireLayer0Alternate: boolean, outerWallDistance: $IntProvider$Type, distributionPoints: $IntProvider$Type, pointOffset: $IntProvider$Type, minGenOffset: integer, maxGenOffset: integer, noiseMultiplier: double, invalidBlocksThreshold: integer)

public "copy"(): $VeinGenerator
public "distributionPoints"(distributionPoints: $IntProvider$Type): $GeodeVeinGenerator
public "codec"(): $Codec<(any)>
public "getAllEntries"(): $List<($Map$Entry<($Either<($BlockState), ($Material)>), (integer)>)>
public "usePotentialPlacementsChance"(usePotentialPlacementsChance: double): $GeodeVeinGenerator
public "placementsRequireLayer0Alternate"(placementsRequireLayer0Alternate: boolean): $GeodeVeinGenerator
public "invalidBlocksThreshold"(invalidBlocksThreshold: integer): $GeodeVeinGenerator
public "useAlternateLayer0Chance"(useAlternateLayer0Chance: double): $GeodeVeinGenerator
public "geodeCrackSettings"(geodeCrackSettings: $GeodeCrackSettings$Type): $GeodeVeinGenerator
public "geodeLayerSettings"(geodeLayerSettings: $GeodeLayerSettings$Type): $GeodeVeinGenerator
public "minGenOffset"(minGenOffset: integer): $GeodeVeinGenerator
public "maxGenOffset"(maxGenOffset: integer): $GeodeVeinGenerator
public "geodeBlockSettings"(geodeBlockSettings: $GeodeVeinGenerator$GeodeBlockSettings$Type): $GeodeVeinGenerator
public "noiseMultiplier"(noiseMultiplier: double): $GeodeVeinGenerator
public "outerWallDistance"(outerWallDistance: $IntProvider$Type): $GeodeVeinGenerator
public "pointOffset"(pointOffset: $IntProvider$Type): $GeodeVeinGenerator
get "allEntries"(): $List<($Map$Entry<($Either<($BlockState), ($Material)>), (integer)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeodeVeinGenerator$Type = ($GeodeVeinGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeodeVeinGenerator_ = $GeodeVeinGenerator$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/cover/$IUICover" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IUIHolder, $IUIHolder$Type} from "packages/com/lowdragmc/lowdraglib/gui/modular/$IUIHolder"
import {$CoverBehavior, $CoverBehavior$Type} from "packages/com/gregtechceu/gtceu/api/cover/$CoverBehavior"
import {$ModularUI, $ModularUI$Type} from "packages/com/lowdragmc/lowdraglib/gui/modular/$ModularUI"
import {$Widget, $Widget$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$Widget"

export interface $IUICover extends $IUIHolder {

 "isInvalid"(): boolean
 "self"(): $CoverBehavior
 "createUI"(entityPlayer: $Player$Type): $ModularUI
 "markAsDirty"(): void
 "isRemote"(): boolean
 "createUIWidget"(): $Widget

(): boolean
}

export namespace $IUICover {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IUICover$Type = ($IUICover);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IUICover_ = $IUICover$Type;
}}
declare module "packages/com/gregtechceu/gtceu/client/renderer/cover/$ICoverRenderer" {
import {$ModelState, $ModelState$Type} from "packages/net/minecraft/client/resources/model/$ModelState"
import {$IRenderer, $IRenderer$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IRenderer"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CoverBehavior, $CoverBehavior$Type} from "packages/com/gregtechceu/gtceu/api/cover/$CoverBehavior"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BakedModel, $BakedModel$Type} from "packages/net/minecraft/client/resources/model/$BakedModel"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ItemDisplayContext, $ItemDisplayContext$Type} from "packages/net/minecraft/world/item/$ItemDisplayContext"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$MultiBufferSource, $MultiBufferSource$Type} from "packages/net/minecraft/client/renderer/$MultiBufferSource"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"
import {$BakedQuad, $BakedQuad$Type} from "packages/net/minecraft/client/renderer/block/model/$BakedQuad"
import {$TextureAtlasSprite, $TextureAtlasSprite$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlasSprite"

export interface $ICoverRenderer extends $IRenderer {

/**
 * 
 * @deprecated
 */
 "renderModel"(level: $BlockAndTintGetter$Type, pos: $BlockPos$Type, state: $BlockState$Type, side: $Direction$Type, rand: $RandomSource$Type): $List<($BakedQuad)>
 "renderCover"(arg0: $List$Type<($BakedQuad$Type)>, arg1: $Direction$Type, arg2: $RandomSource$Type, arg3: $CoverBehavior$Type, arg4: $Direction$Type, arg5: $BlockPos$Type, arg6: $BlockAndTintGetter$Type, arg7: $ModelState$Type): void
 "render"(blockEntity: $BlockEntity$Type, partialTicks: float, stack: $PoseStack$Type, buffer: $MultiBufferSource$Type, combinedLight: integer, combinedOverlay: integer): void
 "isRaw"(): boolean
 "shouldRender"(blockEntity: $BlockEntity$Type, cameraPos: $Vec3$Type): boolean
 "onPrepareTextureAtlas"(atlasName: $ResourceLocation$Type, register: $Consumer$Type<($ResourceLocation$Type)>): void
 "reBakeCustomQuadsOffset"(): float
 "reBakeCustomQuads"(): boolean
 "isGui3d"(): boolean
 "isGlobalRenderer"(blockEntity: $BlockEntity$Type): boolean
 "hasTESR"(blockEntity: $BlockEntity$Type): boolean
 "getParticleTexture"(): $TextureAtlasSprite
 "useAO"(state: $BlockState$Type): boolean
 "useAO"(): boolean
 "getViewDistance"(): integer
 "useBlockLight"(stack: $ItemStack$Type): boolean
 "renderItem"(stack: $ItemStack$Type, transformType: $ItemDisplayContext$Type, leftHand: boolean, poseStack: $PoseStack$Type, buffer: $MultiBufferSource$Type, combinedLight: integer, combinedOverlay: integer, model: $BakedModel$Type): void
 "registerEvent"(): void
 "onAdditionalModel"(registry: $Consumer$Type<($ResourceLocation$Type)>): void

(level: $BlockAndTintGetter$Type, pos: $BlockPos$Type, state: $BlockState$Type, side: $Direction$Type, rand: $RandomSource$Type): $List<($BakedQuad)>
}

export namespace $ICoverRenderer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICoverRenderer$Type = ($ICoverRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICoverRenderer_ = $ICoverRenderer$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/$OverclockingLogic$Logic" {
import {$LongIntPair, $LongIntPair$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIntPair"
import {$GTRecipe, $GTRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe"

export interface $OverclockingLogic$Logic {

 "runOverclockingLogic"(arg0: $GTRecipe$Type, arg1: long, arg2: long, arg3: integer, arg4: integer): $LongIntPair

(arg0: $GTRecipe$Type, arg1: long, arg2: long, arg3: integer, arg4: integer): $LongIntPair
}

export namespace $OverclockingLogic$Logic {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OverclockingLogic$Logic$Type = ($OverclockingLogic$Logic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OverclockingLogic$Logic_ = $OverclockingLogic$Logic$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/block/$RendererBlock" {
import {$AppearanceBlock, $AppearanceBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$AppearanceBlock"
import {$IRenderer, $IRenderer$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IRenderer"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$IBlockRendererProvider, $IBlockRendererProvider$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IBlockRendererProvider"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export class $RendererBlock extends $AppearanceBlock implements $IBlockRendererProvider {
readonly "renderer": $IRenderer
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, renderer: $IRenderer$Type)

public "getRenderer"(state: $BlockState$Type): $IRenderer
public "getLightMap"(world: $BlockAndTintGetter$Type, state: $BlockState$Type, pos: $BlockPos$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RendererBlock$Type = ($RendererBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RendererBlock_ = $RendererBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/data/$GTRecipeTypes" {
import {$GTRecipeType, $GTRecipeType$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipeType"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"

export class $GTRecipeTypes {
static readonly "STEAM": string
static readonly "ELECTRIC": string
static readonly "GENERATOR": string
static readonly "MULTIBLOCK": string
static readonly "DUMMY": string
static readonly "KINETIC": string
static readonly "STEAM_BOILER_RECIPES": $GTRecipeType
static readonly "FURNACE_RECIPES": $GTRecipeType
static readonly "ALLOY_SMELTER_RECIPES": $GTRecipeType
static readonly "ARC_FURNACE_RECIPES": $GTRecipeType
static readonly "ASSEMBLER_RECIPES": $GTRecipeType
static readonly "AUTOCLAVE_RECIPES": $GTRecipeType
static readonly "BENDER_RECIPES": $GTRecipeType
static readonly "BREWING_RECIPES": $GTRecipeType
static readonly "MACERATOR_RECIPES": $GTRecipeType
static readonly "CANNER_RECIPES": $GTRecipeType
static readonly "CENTRIFUGE_RECIPES": $GTRecipeType
static readonly "CHEMICAL_BATH_RECIPES": $GTRecipeType
static readonly "CHEMICAL_RECIPES": $GTRecipeType
static readonly "COMPRESSOR_RECIPES": $GTRecipeType
static readonly "CUTTER_RECIPES": $GTRecipeType
static readonly "DISTILLERY_RECIPES": $GTRecipeType
static readonly "ELECTROLYZER_RECIPES": $GTRecipeType
static readonly "ELECTROMAGNETIC_SEPARATOR_RECIPES": $GTRecipeType
static readonly "EXTRACTOR_RECIPES": $GTRecipeType
static readonly "EXTRUDER_RECIPES": $GTRecipeType
static readonly "FERMENTING_RECIPES": $GTRecipeType
static readonly "FLUID_HEATER_RECIPES": $GTRecipeType
static readonly "FLUID_SOLIDFICATION_RECIPES": $GTRecipeType
static readonly "FORGE_HAMMER_RECIPES": $GTRecipeType
static readonly "FORMING_PRESS_RECIPES": $GTRecipeType
static readonly "LATHE_RECIPES": $GTRecipeType
static readonly "MIXER_RECIPES": $GTRecipeType
static readonly "ORE_WASHER_RECIPES": $GTRecipeType
static readonly "PACKER_RECIPES": $GTRecipeType
static readonly "POLARIZER_RECIPES": $GTRecipeType
static readonly "LASER_ENGRAVER_RECIPES": $GTRecipeType
static readonly "SIFTER_RECIPES": $GTRecipeType
static readonly "THERMAL_CENTRIFUGE_RECIPES": $GTRecipeType
static readonly "WIREMILL_RECIPES": $GTRecipeType
static readonly "CIRCUIT_ASSEMBLER_RECIPES": $GTRecipeType
static readonly "GAS_COLLECTOR_RECIPES": $GTRecipeType
static readonly "AIR_SCRUBBER_RECIPES": $GTRecipeType
static readonly "RESEARCH_STATION_RECIPES": $GTRecipeType
static readonly "ROCK_BREAKER_RECIPES": $GTRecipeType
static readonly "SCANNER_RECIPES": $GTRecipeType
static readonly "COMBUSTION_GENERATOR_FUELS": $GTRecipeType
static readonly "GAS_TURBINE_FUELS": $GTRecipeType
static readonly "STEAM_TURBINE_FUELS": $GTRecipeType
static readonly "PLASMA_GENERATOR_FUELS": $GTRecipeType
static readonly "LARGE_BOILER_RECIPES": $GTRecipeType
static readonly "COKE_OVEN_RECIPES": $GTRecipeType
static readonly "PRIMITIVE_BLAST_FURNACE_RECIPES": $GTRecipeType
static readonly "BLAST_RECIPES": $GTRecipeType
static readonly "DISTILLATION_RECIPES": $GTRecipeType
static readonly "EVAPORATION_RECIPES": $GTRecipeType
static readonly "PYROLYSE_RECIPES": $GTRecipeType
static readonly "CRACKING_RECIPES": $GTRecipeType
static readonly "IMPLOSION_RECIPES": $GTRecipeType
static readonly "VACUUM_RECIPES": $GTRecipeType
static readonly "ASSEMBLY_LINE_RECIPES": $GTRecipeType
static readonly "LARGE_CHEMICAL_RECIPES": $GTRecipeType
static readonly "FUSION_RECIPES": $GTRecipeType
static readonly "DUMMY_RECIPES": $GTRecipeType
static "CREATE_MIXER_RECIPES": $GTRecipeType

constructor()

public static "get"(name: string): $GTRecipeType
public static "register"(name: string, group: string, ...proxyRecipes: ($RecipeType$Type<(any)>)[]): $GTRecipeType
public static "init"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTRecipeTypes$Type = ($GTRecipeTypes);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTRecipeTypes_ = $GTRecipeTypes$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/capability/recipe/$RecipeCapability" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$IContentSerializer, $IContentSerializer$Type} from "packages/com/gregtechceu/gtceu/api/recipe/content/$IContentSerializer"
import {$GTRecipeType, $GTRecipeType$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipeType"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$WidgetGroup, $WidgetGroup$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$WidgetGroup"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$GTRecipe, $GTRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe"
import {$Widget, $Widget$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$Widget"
import {$ContentModifier, $ContentModifier$Type} from "packages/com/gregtechceu/gtceu/api/recipe/content/$ContentModifier"
import {$IRecipeCapabilityHolder, $IRecipeCapabilityHolder$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IRecipeCapabilityHolder"
import {$IO, $IO$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IO"
import {$MutableInt, $MutableInt$Type} from "packages/org/apache/commons/lang3/mutable/$MutableInt"
import {$Content, $Content$Type} from "packages/com/gregtechceu/gtceu/api/recipe/content/$Content"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AbstractMapIngredient, $AbstractMapIngredient$Type} from "packages/com/gregtechceu/gtceu/api/recipe/lookup/$AbstractMapIngredient"
import {$GTRecipeTypeUI$RecipeHolder, $GTRecipeTypeUI$RecipeHolder$Type} from "packages/com/gregtechceu/gtceu/api/recipe/ui/$GTRecipeTypeUI$RecipeHolder"

export class $RecipeCapability<T> {
static readonly "COMPARATOR": $Comparator<($RecipeCapability<(any)>)>
readonly "name": string
readonly "color": integer
readonly "doRenderSlot": boolean
readonly "sortIndex": integer
readonly "serializer": $IContentSerializer<(T)>


public "getName"(): $Component
public "of"(o: any): T
public "isRecipeSearchFilter"(): boolean
public "getMaxParallelRatio"(holder: $IRecipeCapabilityHolder$Type, recipe: $GTRecipe$Type, parallelAmount: integer): integer
public "compressIngredients"(ingredients: $Collection$Type<(any)>): $List<(any)>
public "createXEIContainerContents"(contents: $List$Type<($Content$Type)>, recipe: $GTRecipe$Type, io: $IO$Type): $List<(any)>
public "convertToMapIngredient"(ingredient: any): $List<($AbstractMapIngredient)>
public "doMatchInRecipe"(): boolean
public "copyContent"(content: any): T
public "copyContent"(content: any, modifier: $ContentModifier$Type): T
public "limitParallel"(recipe: $GTRecipe$Type, holder: $IRecipeCapabilityHolder$Type, multiplier: integer): integer
public "copyInner"(content: T): T
public "copyWithModifier"(content: T, modifier: $ContentModifier$Type): T
public "slotName"(io: $IO$Type): string
public "slotName"(io: $IO$Type, index: integer): string
public "calculateAmount"(left: $List$Type<(T)>): double
public "doAddGuiSlots"(): boolean
public "createXEIContainer"(contents: $List$Type<(any)>): any
public "addXEIInfo"(group: $WidgetGroup$Type, xOffset: integer, recipe: $GTRecipe$Type, contents: $List$Type<($Content$Type)>, perTick: boolean, isInput: boolean, yOffset: $MutableInt$Type): void
public "getWidgetClass"(): $Class<(any)>
public "createWidget"(): $Widget
public "applyWidgetInfo"(widget: $Widget$Type, index: integer, isXEI: boolean, io: $IO$Type, recipeHolder: $GTRecipeTypeUI$RecipeHolder$Type, recipeType: $GTRecipeType$Type, recipe: $GTRecipe$Type, content: $Content$Type, storage: any): void
get "name"(): $Component
get "recipeSearchFilter"(): boolean
get "widgetClass"(): $Class<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeCapability$Type<T> = ($RecipeCapability<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeCapability_<T> = $RecipeCapability$Type<(T)>;
}}
declare module "packages/com/gregtechceu/gtceu/api/block/$IMachineBlock" {
import {$EntityBlock, $EntityBlock$Type} from "packages/net/minecraft/world/level/block/$EntityBlock"
import {$IRenderer, $IRenderer$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IRenderer"
import {$IBlockRendererProvider, $IBlockRendererProvider$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IBlockRendererProvider"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$MachineDefinition, $MachineDefinition$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MachineDefinition"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$RotationState, $RotationState$Type} from "packages/com/gregtechceu/gtceu/api/data/$RotationState"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"
import {$DirectionProperty, $DirectionProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$DirectionProperty"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export interface $IMachineBlock extends $IBlockRendererProvider, $EntityBlock {

 "getDefinition"(): $MachineDefinition
 "self"(): $Block
 "getTicker"<T extends $BlockEntity>(level: $Level$Type, state: $BlockState$Type, blockEntityType: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
 "newBlockEntity"(pos: $BlockPos$Type, state: $BlockState$Type): $BlockEntity
 "getRotationState"(): $RotationState
 "getRenderer"(arg0: $BlockState$Type): $IRenderer
 "getLightMap"(world: $BlockAndTintGetter$Type, state: $BlockState$Type, pos: $BlockPos$Type): integer
 "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
}

export namespace $IMachineBlock {
const UPWARDS_FACING_PROPERTY: $DirectionProperty
function colorTinted(blockState: $BlockState$Type, level: $BlockAndTintGetter$Type, pos: $BlockPos$Type, index: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMachineBlock$Type = ($IMachineBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMachineBlock_ = $IMachineBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/utils/$FacingPos" {
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $FacingPos {

constructor(pos: $BlockPos$Type, facing: $Direction$Type)

public "equals"(o: any): boolean
public "hashCode"(): integer
public "getFacing"(): $Direction
public "getPos"(): $BlockPos
get "facing"(): $Direction
get "pos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FacingPos$Type = ($FacingPos);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FacingPos_ = $FacingPos$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/fluids/$FluidBuilder" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$GTRegistrate, $GTRegistrate$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$GTRegistrate"
import {$FluidStorageKey, $FluidStorageKey$Type} from "packages/com/gregtechceu/gtceu/api/fluids/store/$FluidStorageKey"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$FluidAttribute, $FluidAttribute$Type} from "packages/com/gregtechceu/gtceu/api/fluids/attribute/$FluidAttribute"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidState, $FluidState$Type} from "packages/com/gregtechceu/gtceu/api/fluids/$FluidState"

export class $FluidBuilder {

constructor()

public "name"(name: string): $FluidBuilder
public "state"(state: $FluidState$Type): $FluidBuilder
public "block"(): $FluidBuilder
public "color"(color: integer): $FluidBuilder
public "build"(modid: string, material: $Material$Type, key: $FluidStorageKey$Type, registrate: $GTRegistrate$Type): $Supplier<(any)>
public "attributes"(...attributes: ($FluidAttribute$Type)[]): $FluidBuilder
public "attribute"(attribute: $FluidAttribute$Type): $FluidBuilder
public "textures"(hasCustomStill: boolean, hasCustomFlowing: boolean): $FluidBuilder
public "textures"(hasCustomStill: boolean): $FluidBuilder
public "translation"(translation: string): $FluidBuilder
public "density"(density: double): $FluidBuilder
public "density"(density: integer): $FluidBuilder
public "flowing"(flowing: $ResourceLocation$Type): $FluidBuilder
public "flowing"(): $ResourceLocation
public "viscosity"(viscosity: double): $FluidBuilder
public "viscosity"(mcViscosity: integer): $FluidBuilder
public "temperature"(temperature: integer): $FluidBuilder
public "burnTime"(burnTime: integer): $FluidBuilder
public "still"(): $ResourceLocation
public "still"(still: $ResourceLocation$Type): $FluidBuilder
public "luminosity"(luminosity: integer): $FluidBuilder
public "customStill"(): $FluidBuilder
public "disableBucket"(): $FluidBuilder
public "disableColor"(): $FluidBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidBuilder$Type = ($FluidBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidBuilder_ = $FluidBuilder$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/blockentity/$OpticalPipeBlockEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$OpticalPipeProperties, $OpticalPipeProperties$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/optical/$OpticalPipeProperties"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$OpticalPipeNet, $OpticalPipeNet$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/optical/$OpticalPipeNet"
import {$PipeBlockEntity, $PipeBlockEntity$Type} from "packages/com/gregtechceu/gtceu/api/blockentity/$PipeBlockEntity"
import {$AttachmentTarget, $AttachmentTarget$Type} from "packages/net/fabricmc/fabric/api/attachment/v1/$AttachmentTarget"
import {$ManagedFieldHolder, $ManagedFieldHolder$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/field/$ManagedFieldHolder"
import {$GTToolType, $GTToolType$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$OpticalPipeType, $OpticalPipeType$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/optical/$OpticalPipeType"

export class $OpticalPipeBlockEntity extends $PipeBlockEntity<($OpticalPipeType), ($OpticalPipeProperties)> {
static readonly "MANAGED_FIELD_HOLDER": $ManagedFieldHolder
 "level": $Level
 "worldPosition": $BlockPos
 "remove": boolean
 "hasComparators": byte

constructor(type: $BlockEntityType$Type<(any)>, pos: $BlockPos$Type, blockState: $BlockState$Type)

public "isActive"(): boolean
public "setActive"(active: boolean, duration: integer): void
public "getCapability"<T>(capability: $Capability$Type<(T)>, facing: $Direction$Type): $LazyOptional<(T)>
public "onChunkUnloaded"(): void
public "setConnection"(side: $Direction$Type, connected: boolean, fromNeighbor: boolean): void
public "canAttachTo"(side: $Direction$Type): boolean
public "canHaveBlockedFaces"(): boolean
public "checkNetwork"(): void
public "getOpticalPipeNet"(): $OpticalPipeNet
public "getPipeTuneTool"(): $GTToolType
public "getFieldHolder"(): $ManagedFieldHolder
public static "transfer"(original: $AttachmentTarget$Type, target: $AttachmentTarget$Type, isDeath: boolean): void
get "active"(): boolean
get "opticalPipeNet"(): $OpticalPipeNet
get "pipeTuneTool"(): $GTToolType
get "fieldHolder"(): $ManagedFieldHolder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OpticalPipeBlockEntity$Type = ($OpticalPipeBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OpticalPipeBlockEntity_ = $OpticalPipeBlockEntity$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/data/$GTMaterials" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$MaterialFlag, $MaterialFlag$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/info/$MaterialFlag"
import {$MarkerMaterial, $MarkerMaterial$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$MarkerMaterial"
import {$List, $List$Type} from "packages/java/util/$List"

export class $GTMaterials {
static "CHEMICAL_DYES": ($Material)[]
static "VOLTAGE_COMMON_MATERIALS": ($Material)[]
static readonly "STD_METAL": $List<($MaterialFlag)>
static readonly "EXT_METAL": $List<($MaterialFlag)>
static readonly "EXT2_METAL": $List<($MaterialFlag)>
static readonly "NULL": $MarkerMaterial
static "Actinium": $Material
static "Aluminium": $Material
static "Americium": $Material
static "Antimony": $Material
static "Argon": $Material
static "Arsenic": $Material
static "Astatine": $Material
static "Barium": $Material
static "Berkelium": $Material
static "Beryllium": $Material
static "Bismuth": $Material
static "Bohrium": $Material
static "Boron": $Material
static "Bromine": $Material
static "Caesium": $Material
static "Calcium": $Material
static "Californium": $Material
static "Carbon": $Material
static "Cadmium": $Material
static "Cerium": $Material
static "Chlorine": $Material
static "Chromium": $Material
static "Cobalt": $Material
static "Copernicium": $Material
static "Copper": $Material
static "Curium": $Material
static "Darmstadtium": $Material
static "Deuterium": $Material
static "Dubnium": $Material
static "Dysprosium": $Material
static "Einsteinium": $Material
static "Erbium": $Material
static "Europium": $Material
static "Fermium": $Material
static "Flerovium": $Material
static "Fluorine": $Material
static "Francium": $Material
static "Gadolinium": $Material
static "Gallium": $Material
static "Germanium": $Material
static "Gold": $Material
static "Hafnium": $Material
static "Hassium": $Material
static "Holmium": $Material
static "Hydrogen": $Material
static "Helium": $Material
static "Helium3": $Material
static "Indium": $Material
static "Iodine": $Material
static "Iridium": $Material
static "Iron": $Material
static "Krypton": $Material
static "Lanthanum": $Material
static "Lawrencium": $Material
static "Lead": $Material
static "Lithium": $Material
static "Livermorium": $Material
static "Lutetium": $Material
static "Magnesium": $Material
static "Mendelevium": $Material
static "Manganese": $Material
static "Meitnerium": $Material
static "Mercury": $Material
static "Molybdenum": $Material
static "Moscovium": $Material
static "Neodymium": $Material
static "Neon": $Material
static "Neptunium": $Material
static "Nickel": $Material
static "Nihonium": $Material
static "Niobium": $Material
static "Nitrogen": $Material
static "Nobelium": $Material
static "Oganesson": $Material
static "Osmium": $Material
static "Oxygen": $Material
static "Palladium": $Material
static "Phosphorus": $Material
static "Polonium": $Material
static "Platinum": $Material
static "Plutonium239": $Material
static "Plutonium241": $Material
static "Potassium": $Material
static "Praseodymium": $Material
static "Promethium": $Material
static "Protactinium": $Material
static "Radon": $Material
static "Radium": $Material
static "Rhenium": $Material
static "Rhodium": $Material
static "Roentgenium": $Material
static "Rubidium": $Material
static "Ruthenium": $Material
static "Rutherfordium": $Material
static "Samarium": $Material
static "Scandium": $Material
static "Seaborgium": $Material
static "Selenium": $Material
static "Silicon": $Material
static "Silver": $Material
static "Sodium": $Material
static "Strontium": $Material
static "Sulfur": $Material
static "Tantalum": $Material
static "Technetium": $Material
static "Tellurium": $Material
static "Tennessine": $Material
static "Terbium": $Material
static "Thorium": $Material
static "Thallium": $Material
static "Thulium": $Material
static "Tin": $Material
static "Titanium": $Material
static "Tritium": $Material
static "Tungsten": $Material
static "Uranium238": $Material
static "Uranium235": $Material
static "Vanadium": $Material
static "Xenon": $Material
static "Ytterbium": $Material
static "Yttrium": $Material
static "Zinc": $Material
static "Zirconium": $Material
static "Naquadah": $Material
static "NaquadahEnriched": $Material
static "Naquadria": $Material
static "Neutronium": $Material
static "Tritanium": $Material
static "Duranium": $Material
static "Trinium": $Material
static "Almandine": $Material
static "Andradite": $Material
static "AnnealedCopper": $Material
static "Asbestos": $Material
static "Ash": $Material
static "Hematite": $Material
static "BatteryAlloy": $Material
static "BlueTopaz": $Material
static "Bone": $Material
static "Brass": $Material
static "Bronze": $Material
static "Goethite": $Material
static "Calcite": $Material
static "Cassiterite": $Material
static "CassiteriteSand": $Material
static "Chalcopyrite": $Material
static "Charcoal": $Material
static "Chromite": $Material
static "Cinnabar": $Material
static "Water": $Material
static "Coal": $Material
static "Cobaltite": $Material
static "Cooperite": $Material
static "Cupronickel": $Material
static "DarkAsh": $Material
static "Diamond": $Material
static "Electrum": $Material
static "Emerald": $Material
static "Galena": $Material
static "Garnierite": $Material
static "GreenSapphire": $Material
static "Grossular": $Material
static "Ice": $Material
static "Ilmenite": $Material
static "Rutile": $Material
static "Bauxite": $Material
static "Invar": $Material
static "Kanthal": $Material
static "Lazurite": $Material
static "Magnalium": $Material
static "Magnesite": $Material
static "Magnetite": $Material
static "Molybdenite": $Material
static "Nichrome": $Material
static "NiobiumNitride": $Material
static "NiobiumTitanium": $Material
static "Obsidian": $Material
static "Phosphate": $Material
static "SterlingSilver": $Material
static "RoseGold": $Material
static "BlackBronze": $Material
static "BismuthBronze": $Material
static "Biotite": $Material
static "Powellite": $Material
static "Pyrite": $Material
static "Pyrolusite": $Material
static "Pyrope": $Material
static "RockSalt": $Material
static "RTMAlloy": $Material
static "Ruridit": $Material
static "Rubber": $Material
static "Ruby": $Material
static "Salt": $Material
static "Saltpeter": $Material
static "Sapphire": $Material
static "Scheelite": $Material
static "Sodalite": $Material
static "AluminiumSulfite": $Material
static "Tantalite": $Material
static "Coke": $Material
static "SolderingAlloy": $Material
static "Spessartine": $Material
static "Sphalerite": $Material
static "StainlessSteel": $Material
static "Steel": $Material
static "Stibnite": $Material
static "Tetrahedrite": $Material
static "TinAlloy": $Material
static "Topaz": $Material
static "Tungstate": $Material
static "Ultimet": $Material
static "Uraninite": $Material
static "Uvarovite": $Material
static "VanadiumGallium": $Material
static "WroughtIron": $Material
static "Wulfenite": $Material
static "YellowLimonite": $Material
static "YttriumBariumCuprate": $Material
static "NetherQuartz": $Material
static "CertusQuartz": $Material
static "Quartzite": $Material
static "Graphite": $Material
static "Graphene": $Material
static "TungsticAcid": $Material
static "Osmiridium": $Material
static "LithiumChloride": $Material
static "CalciumChloride": $Material
static "Bornite": $Material
static "Chalcocite": $Material
static "GalliumArsenide": $Material
static "Potash": $Material
static "SodaAsh": $Material
static "IndiumGalliumPhosphide": $Material
static "NickelZincFerrite": $Material
static "SiliconDioxide": $Material
static "MagnesiumChloride": $Material
static "SodiumSulfide": $Material
static "PhosphorusPentoxide": $Material
static "Quicklime": $Material
static "SodiumBisulfate": $Material
static "FerriteMixture": $Material
static "Magnesia": $Material
static "PlatinumGroupSludge": $Material
static "Realgar": $Material
static "SodiumBicarbonate": $Material
static "PotassiumDichromate": $Material
static "ChromiumTrioxide": $Material
static "AntimonyTrioxide": $Material
static "Zincite": $Material
static "CupricOxide": $Material
static "CobaltOxide": $Material
static "ArsenicTrioxide": $Material
static "Massicot": $Material
static "Ferrosilite": $Material
static "MetalMixture": $Material
static "SodiumHydroxide": $Material
static "SodiumPersulfate": $Material
static "Bastnasite": $Material
static "Pentlandite": $Material
static "Spodumene": $Material
static "Lepidolite": $Material
static "GlauconiteSand": $Material
static "Malachite": $Material
static "Mica": $Material
static "Barite": $Material
static "Alunite": $Material
static "Talc": $Material
static "Soapstone": $Material
static "Kyanite": $Material
static "IronMagnetic": $Material
static "TungstenCarbide": $Material
static "CarbonDioxide": $Material
static "TitaniumTetrachloride": $Material
static "NitrogenDioxide": $Material
static "HydrogenSulfide": $Material
static "NitricAcid": $Material
static "SulfuricAcid": $Material
static "PhosphoricAcid": $Material
static "SulfurTrioxide": $Material
static "SulfurDioxide": $Material
static "CarbonMonoxide": $Material
static "HypochlorousAcid": $Material
static "Ammonia": $Material
static "HydrofluoricAcid": $Material
static "NitricOxide": $Material
static "Iron3Chloride": $Material
static "Iron2Chloride": $Material
static "UraniumHexafluoride": $Material
static "EnrichedUraniumHexafluoride": $Material
static "DepletedUraniumHexafluoride": $Material
static "NitrousOxide": $Material
static "EnderPearl": $Material
static "PotassiumFeldspar": $Material
static "NeodymiumMagnetic": $Material
static "HydrochloricAcid": $Material
static "Steam": $Material
static "DistilledWater": $Material
static "SodiumPotassium": $Material
static "SamariumMagnetic": $Material
static "ManganesePhosphide": $Material
static "MagnesiumDiboride": $Material
static "MercuryBariumCalciumCuprate": $Material
static "UraniumTriplatinum": $Material
static "SamariumIronArsenicOxide": $Material
static "IndiumTinBariumTitaniumCuprate": $Material
static "UraniumRhodiumDinaquadide": $Material
static "EnrichedNaquadahTriniumEuropiumDuranide": $Material
static "RutheniumTriniumAmericiumNeutronate": $Material
static "PlatinumRaw": $Material
static "InertMetalMixture": $Material
static "RhodiumSulfate": $Material
static "RutheniumTetroxide": $Material
static "OsmiumTetroxide": $Material
static "IridiumChloride": $Material
static "FluoroantimonicAcid": $Material
static "TitaniumTrifluoride": $Material
static "CalciumPhosphide": $Material
static "IndiumPhosphide": $Material
static "BariumSulfide": $Material
static "TriniumSulfide": $Material
static "ZincSulfide": $Material
static "GalliumSulfide": $Material
static "AntimonyTrifluoride": $Material
static "EnrichedNaquadahSulfate": $Material
static "NaquadriaSulfate": $Material
static "Pyrochlore": $Material
static "PotassiumHydroxide": $Material
static "PotassiumIodide": $Material
static "PotassiumFerrocyanide": $Material
static "CalciumFerrocyanide": $Material
static "CalciumHydroxide": $Material
static "CalciumCarbonate": $Material
static "PotassiumCyanide": $Material
static "PotassiumCarbonate": $Material
static "HydrogenCyanide": $Material
static "FormicAcid": $Material
static "PotassiumSulfate": $Material
static "PrussianBlue": $Material
static "Formaldehyde": $Material
static "Glycolonitrile": $Material
static "DiethylenetriaminePentaacetonitrile": $Material
static "DiethylenetriaminepentaaceticAcid": $Material
static "SodiumNitrite": $Material
static "AcidicBromineSolution": $Material
static "ConcentratedBromineSolution": $Material
static "Iodide": $Material
static "IodineSolution": $Material
static "DiluteIodineSolution": $Material
static "SiliconeRubber": $Material
static "RawRubber": $Material
static "RawStyreneButadieneRubber": $Material
static "StyreneButadieneRubber": $Material
static "PolyvinylAcetate": $Material
static "ReinforcedEpoxyResin": $Material
static "PolyvinylChloride": $Material
static "PolyphenyleneSulfide": $Material
static "GlycerylTrinitrate": $Material
static "Polybenzimidazole": $Material
static "Polydimethylsiloxane": $Material
static "Polyethylene": $Material
static "Epoxy": $Material
static "Polycaprolactam": $Material
static "Polytetrafluoroethylene": $Material
static "Sugar": $Material
static "Methane": $Material
static "Epichlorohydrin": $Material
static "Monochloramine": $Material
static "Chloroform": $Material
static "Cumene": $Material
static "Tetrafluoroethylene": $Material
static "Chloromethane": $Material
static "AllylChloride": $Material
static "Isoprene": $Material
static "Propane": $Material
static "Propene": $Material
static "Ethane": $Material
static "Butene": $Material
static "Butane": $Material
static "DissolvedCalciumAcetate": $Material
static "VinylAcetate": $Material
static "MethylAcetate": $Material
static "Ethenone": $Material
static "Tetranitromethane": $Material
static "Dimethylamine": $Material
static "Dimethylhydrazine": $Material
static "DinitrogenTetroxide": $Material
static "Dimethyldichlorosilane": $Material
static "Styrene": $Material
static "Butadiene": $Material
static "Dichlorobenzene": $Material
static "AceticAcid": $Material
static "Phenol": $Material
static "BisphenolA": $Material
static "VinylChloride": $Material
static "Ethylene": $Material
static "Benzene": $Material
static "Acetone": $Material
static "Glycerol": $Material
static "Methanol": $Material
static "Ethanol": $Material
static "Toluene": $Material
static "DiphenylIsophtalate": $Material
static "PhthalicAcid": $Material
static "Dimethylbenzene": $Material
static "Diaminobenzidine": $Material
static "Dichlorobenzidine": $Material
static "Nitrochlorobenzene": $Material
static "Chlorobenzene": $Material
static "Octane": $Material
static "EthylTertButylEther": $Material
static "Ethylbenzene": $Material
static "Naphthalene": $Material
static "Nitrobenzene": $Material
static "Cyclohexane": $Material
static "NitrosylChloride": $Material
static "CyclohexanoneOxime": $Material
static "Caprolactam": $Material
static "PlatinumSludgeResidue": $Material
static "PalladiumRaw": $Material
static "RarestMetalMixture": $Material
static "AmmoniumChloride": $Material
static "AcidicOsmiumSolution": $Material
static "RhodiumPlatedPalladium": $Material
static "Butyraldehyde": $Material
static "PolyvinylButyral": $Material
static "Biphenyl": $Material
static "PolychlorinatedBiphenyl": $Material
static "AceticAnhydride": $Material
static "AminoPhenol": $Material
static "Paracetamol": $Material
static "AmmoniumFormate": $Material
static "Formamide": $Material
static "WoodGas": $Material
static "WoodVinegar": $Material
static "WoodTar": $Material
static "CharcoalByproducts": $Material
static "Biomass": $Material
static "BioDiesel": $Material
static "FermentedBiomass": $Material
static "Creosote": $Material
static "Diesel": $Material
static "RocketFuel": $Material
static "Glue": $Material
static "Lubricant": $Material
static "McGuffium239": $Material
static "IndiumConcentrate": $Material
static "SeedOil": $Material
static "DrillingFluid": $Material
static "ConstructionFoam": $Material
static "Oil": $Material
static "OilHeavy": $Material
static "RawOil": $Material
static "OilLight": $Material
static "NaturalGas": $Material
static "SulfuricHeavyFuel": $Material
static "HeavyFuel": $Material
static "LightlyHydroCrackedHeavyFuel": $Material
static "SeverelyHydroCrackedHeavyFuel": $Material
static "LightlySteamCrackedHeavyFuel": $Material
static "SeverelySteamCrackedHeavyFuel": $Material
static "SulfuricLightFuel": $Material
static "LightFuel": $Material
static "LightlyHydroCrackedLightFuel": $Material
static "SeverelyHydroCrackedLightFuel": $Material
static "LightlySteamCrackedLightFuel": $Material
static "SeverelySteamCrackedLightFuel": $Material
static "SulfuricNaphtha": $Material
static "Naphtha": $Material
static "LightlyHydroCrackedNaphtha": $Material
static "SeverelyHydroCrackedNaphtha": $Material
static "LightlySteamCrackedNaphtha": $Material
static "SeverelySteamCrackedNaphtha": $Material
static "SulfuricGas": $Material
static "RefineryGas": $Material
static "LightlyHydroCrackedGas": $Material
static "SeverelyHydroCrackedGas": $Material
static "LightlySteamCrackedGas": $Material
static "SeverelySteamCrackedGas": $Material
static "HydroCrackedEthane": $Material
static "HydroCrackedEthylene": $Material
static "HydroCrackedPropene": $Material
static "HydroCrackedPropane": $Material
static "HydroCrackedButane": $Material
static "HydroCrackedButene": $Material
static "HydroCrackedButadiene": $Material
static "SteamCrackedEthane": $Material
static "SteamCrackedEthylene": $Material
static "SteamCrackedPropene": $Material
static "SteamCrackedPropane": $Material
static "SteamCrackedButane": $Material
static "SteamCrackedButene": $Material
static "SteamCrackedButadiene": $Material
static "LPG": $Material
static "RawGrowthMedium": $Material
static "SterileGrowthMedium": $Material
static "Bacteria": $Material
static "BacterialSludge": $Material
static "EnrichedBacterialSludge": $Material
static "Mutagen": $Material
static "GelatinMixture": $Material
static "RawGasoline": $Material
static "Gasoline": $Material
static "HighOctaneGasoline": $Material
static "CoalGas": $Material
static "CoalTar": $Material
static "Gunpowder": $Material
static "Oilsands": $Material
static "RareEarth": $Material
static "Stone": $Material
static "Lava": $Material
static "Glowstone": $Material
static "NetherStar": $Material
static "Endstone": $Material
static "Netherrack": $Material
static "CetaneBoostedDiesel": $Material
static "Collagen": $Material
static "Gelatin": $Material
static "Agar": $Material
static "Andesite": $Material
static "Milk": $Material
static "Cocoa": $Material
static "Wheat": $Material
static "Meat": $Material
static "Wood": $Material
static "TreatedWood": $Material
static "Paper": $Material
static "FishOil": $Material
static "RubySlurry": $Material
static "SapphireSlurry": $Material
static "GreenSapphireSlurry": $Material
static "DyeBlack": $Material
static "DyeRed": $Material
static "DyeGreen": $Material
static "DyeBrown": $Material
static "DyeBlue": $Material
static "DyePurple": $Material
static "DyeCyan": $Material
static "DyeLightGray": $Material
static "DyeGray": $Material
static "DyePink": $Material
static "DyeLime": $Material
static "DyeYellow": $Material
static "DyeLightBlue": $Material
static "DyeMagenta": $Material
static "DyeOrange": $Material
static "DyeWhite": $Material
static "ImpureEnrichedNaquadahSolution": $Material
static "EnrichedNaquadahSolution": $Material
static "AcidicEnrichedNaquadahSolution": $Material
static "EnrichedNaquadahWaste": $Material
static "ImpureNaquadriaSolution": $Material
static "NaquadriaSolution": $Material
static "AcidicNaquadriaSolution": $Material
static "NaquadriaWaste": $Material
static "Lapotron": $Material
static "UUMatter": $Material
static "PCBCoolant": $Material
static "Glass": $Material
static "Perlite": $Material
static "Borax": $Material
static "Olivine": $Material
static "Opal": $Material
static "Amethyst": $Material
static "Lapis": $Material
static "Blaze": $Material
static "Apatite": $Material
static "BlackSteel": $Material
static "DamascusSteel": $Material
static "TungstenSteel": $Material
static "CobaltBrass": $Material
static "TricalciumPhosphate": $Material
static "GarnetRed": $Material
static "GarnetYellow": $Material
static "Marble": $Material
static "Deepslate": $Material
static "GraniteRed": $Material
static "VanadiumMagnetite": $Material
static "QuartzSand": $Material
static "Pollucite": $Material
static "Bentonite": $Material
static "FullersEarth": $Material
static "Pitchblende": $Material
static "Monazite": $Material
static "Mirabilite": $Material
static "ActivatedCarbon": $Material
static "Trona": $Material
static "Gypsum": $Material
static "Zeolite": $Material
static "Concrete": $Material
static "SteelMagnetic": $Material
static "VanadiumSteel": $Material
static "Potin": $Material
static "BorosilicateGlass": $Material
static "NaquadahAlloy": $Material
static "SulfuricNickelSolution": $Material
static "SulfuricCopperSolution": $Material
static "LeadZincSolution": $Material
static "NitrationMixture": $Material
static "DilutedSulfuricAcid": $Material
static "DilutedHydrochloricAcid": $Material
static "Flint": $Material
static "Air": $Material
static "LiquidAir": $Material
static "NetherAir": $Material
static "LiquidNetherAir": $Material
static "EnderAir": $Material
static "LiquidEnderAir": $Material
static "AquaRegia": $Material
static "SaltWater": $Material
static "Clay": $Material
static "Redstone": $Material
static "Dichloroethane": $Material
static "Diethylenetriamine": $Material
static "RawBrine": $Material
static "DebrominatedBrine": $Material
static "BrominatedChlorineVapor": $Material
static "AcidicBromineExhaust": $Material
static "Electrotine": $Material
static "EnderEye": $Material
static "Diatomite": $Material
static "RedSteel": $Material
static "BlueSteel": $Material
static "Basalt": $Material
static "GraniticMineralSand": $Material
static "Redrock": $Material
static "GarnetSand": $Material
static "HSSG": $Material
static "IridiumMetalResidue": $Material
static "Granite": $Material
static "Brick": $Material
static "Fireclay": $Material
static "Diorite": $Material
static "HotBrine": $Material
static "HotChlorinatedBrominatedBrine": $Material
static "HotDebrominatedBrine": $Material
static "HotAlkalineDebrominatedBrine": $Material
static "RedAlloy": $Material
static "BlueAlloy": $Material
static "BasalticMineralSand": $Material
static "HSSE": $Material
static "HSSS": $Material
static "RadAway": $Material
static "TantalumCarbide": $Material
static "HSLASteel": $Material
static "MolybdenumDisilicide": $Material
static "Zeron100": $Material
static "WatertightSteel": $Material
static "IncoloyMA956": $Material
static "MaragingSteel300": $Material
static "HastelloyX": $Material
static "Stellite100": $Material
static "TitaniumCarbide": $Material
static "TitaniumTungstenCarbide": $Material
static "HastelloyC276": $Material

constructor()

public static "get"(name: string): $Material
public static "init"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTMaterials$Type = ($GTMaterials);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTMaterials_ = $GTMaterials$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/item/$LevelItemPipeNet" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ItemPipeProperties, $ItemPipeProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$ItemPipeProperties"
import {$ItemPipeNet, $ItemPipeNet$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/item/$ItemPipeNet"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$LevelPipeNet, $LevelPipeNet$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$LevelPipeNet"

export class $LevelItemPipeNet extends $LevelPipeNet<($ItemPipeProperties), ($ItemPipeNet)> {

constructor(serverLevel: $ServerLevel$Type, tag: $CompoundTag$Type)
constructor(serverLevel: $ServerLevel$Type)

public static "getOrCreate"(serverLevel: $ServerLevel$Type): $LevelItemPipeNet
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelItemPipeNet$Type = ($LevelItemPipeNet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LevelItemPipeNet_ = $LevelItemPipeNet$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$AlloyBlastProperty" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$AlloyBlastRecipeProducer, $AlloyBlastRecipeProducer$Type} from "packages/com/gregtechceu/gtceu/data/recipe/misc/alloyblast/$AlloyBlastRecipeProducer"
import {$IMaterialProperty, $IMaterialProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IMaterialProperty"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$MaterialProperties, $MaterialProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$MaterialProperties"

export class $AlloyBlastProperty implements $IMaterialProperty<($AlloyBlastProperty)> {

constructor(temperature: integer)

public "setFluid"(materialFluid: $Supplier$Type<(any)>): void
public "getFluid"(): $Fluid
public "getTemperature"(): integer
public "setTemperature"(fluidTemperature: integer): void
public "verifyProperty"(materialProperties: $MaterialProperties$Type): void
public "getRecipeProducer"(): $AlloyBlastRecipeProducer
public "setRecipeProducer"(recipeProducer: $AlloyBlastRecipeProducer$Type): void
set "fluid"(value: $Supplier$Type<(any)>)
get "fluid"(): $Fluid
get "temperature"(): integer
set "temperature"(value: integer)
get "recipeProducer"(): $AlloyBlastRecipeProducer
set "recipeProducer"(value: $AlloyBlastRecipeProducer$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlloyBlastProperty$Type = ($AlloyBlastProperty);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlloyBlastProperty_ = $AlloyBlastProperty$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/trait/$RecipeLogic" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$RecipeLogic$Status, $RecipeLogic$Status$Type} from "packages/com/gregtechceu/gtceu/api/machine/trait/$RecipeLogic$Status"
import {$MachineTrait, $MachineTrait$Type} from "packages/com/gregtechceu/gtceu/api/machine/trait/$MachineTrait"
import {$GTRecipe, $GTRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe"
import {$IWorkable, $IWorkable$Type} from "packages/com/gregtechceu/gtceu/api/capability/$IWorkable"
import {$GTRecipe$ActionResult, $GTRecipe$ActionResult$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe$ActionResult"
import {$TooltipComponent, $TooltipComponent$Type} from "packages/net/minecraft/world/inventory/tooltip/$TooltipComponent"
import {$IFancyTooltip, $IFancyTooltip$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$IFancyTooltip"
import {$ManagedFieldHolder, $ManagedFieldHolder$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/field/$ManagedFieldHolder"
import {$IRecipeLogicMachine, $IRecipeLogicMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/$IRecipeLogicMachine"
import {$RecipeManager, $RecipeManager$Type} from "packages/net/minecraft/world/item/crafting/$RecipeManager"
import {$IEnhancedManaged, $IEnhancedManaged$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$IEnhancedManaged"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IGuiTexture, $IGuiTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$IGuiTexture"

export class $RecipeLogic extends $MachineTrait implements $IEnhancedManaged, $IWorkable, $IFancyTooltip {
static readonly "MANAGED_FIELD_HOLDER": $ManagedFieldHolder
readonly "machine": $IRecipeLogicMachine
 "lastFailedMatches": $List<($GTRecipe)>

constructor(machine: $IRecipeLogicMachine$Type)

public "isActive"(): boolean
public "getDuration"(): integer
public "getStatus"(): $RecipeLogic$Status
public "isSuspend"(): boolean
public "setProgress"(progress: integer): void
public "getRecipeManager"(): $RecipeManager
public "setupRecipe"(recipe: $GTRecipe$Type): void
public "isWorking"(): boolean
public "setWaiting"(reason: $Component$Type): void
public "isWaiting"(): boolean
public "serverTick"(): void
public "isIdle"(): boolean
public "getProgress"(): integer
public "setStatus"(status: $RecipeLogic$Status$Type): void
public "checkMatchedRecipeAvailable"(match: $GTRecipe$Type): boolean
public "getTotalContinuousRunningTime"(): long
public "handleRecipeWorking"(): void
public "findAndHandleRecipe"(): void
/**
 * 
 * @deprecated
 */
public "isHasNotEnoughEnergy"(): boolean
public "getLastOriginRecipe"(): $GTRecipe
public "scheduleRenderUpdate"(): void
public "needFuel"(): boolean
public "onRecipeFinish"(): void
public "handleFuelRecipe"(): boolean
public "handleTickRecipe"(recipe: $GTRecipe$Type): $GTRecipe$ActionResult
public "getFuelTime"(): integer
public "getFuelMaxTime"(): integer
public "isRecipeDirty"(): boolean
public "interruptRecipe"(): void
public "resetRecipeLogic"(): void
public "getFieldHolder"(): $ManagedFieldHolder
public "onMachineLoad"(): void
public "setWorkingEnabled"(isWorkingAllowed: boolean): void
public "isWorkingEnabled"(): boolean
public "showFancyTooltip"(): boolean
public "getFancyTooltip"(): $List<($Component)>
public "getMaxProgress"(): integer
public "inValid"(): void
public "updateSound"(): void
public "getLastRecipe"(): $GTRecipe
public "getProgressPercent"(): double
public "getFancyTooltipIcon"(): $IGuiTexture
public "updateTickSubscription"(): void
public "markLastRecipeDirty"(): void
public "getFancyComponent"(): $TooltipComponent
get "active"(): boolean
get "duration"(): integer
get "status"(): $RecipeLogic$Status
get "suspend"(): boolean
set "progress"(value: integer)
get "recipeManager"(): $RecipeManager
set "upRecipe"(value: $GTRecipe$Type)
get "working"(): boolean
set "waiting"(value: $Component$Type)
get "waiting"(): boolean
get "idle"(): boolean
get "progress"(): integer
set "status"(value: $RecipeLogic$Status$Type)
get "totalContinuousRunningTime"(): long
get "hasNotEnoughEnergy"(): boolean
get "lastOriginRecipe"(): $GTRecipe
get "fuelTime"(): integer
get "fuelMaxTime"(): integer
get "recipeDirty"(): boolean
get "fieldHolder"(): $ManagedFieldHolder
set "workingEnabled"(value: boolean)
get "workingEnabled"(): boolean
get "fancyTooltip"(): $List<($Component)>
get "maxProgress"(): integer
get "lastRecipe"(): $GTRecipe
get "progressPercent"(): double
get "fancyTooltipIcon"(): $IGuiTexture
get "fancyComponent"(): $TooltipComponent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeLogic$Type = ($RecipeLogic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeLogic_ = $RecipeLogic$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/gui/editor/$EditableMachineUI" {
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IEditableUI, $IEditableUI$Type} from "packages/com/gregtechceu/gtceu/api/gui/editor/$IEditableUI"
import {$WidgetGroup, $WidgetGroup$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$WidgetGroup"
import {$MetaMachine, $MetaMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MetaMachine"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $EditableMachineUI implements $IEditableUI<($WidgetGroup), ($MetaMachine)> {

constructor(groupName: string, uiPath: $ResourceLocation$Type, widgetSupplier: $Supplier$Type<($WidgetGroup$Type)>, binder: $BiConsumer$Type<($WidgetGroup$Type), ($MetaMachine$Type)>)

public "getGroupName"(): string
public "getUiPath"(): $ResourceLocation
public "hasCustomUI"(): boolean
public "reloadCustomUI"(): void
public "getCustomUI"(): $CompoundTag
public "createCustomUI"(): $WidgetGroup
public "setupUI"(template: $WidgetGroup$Type, machine: $MetaMachine$Type): void
get "groupName"(): string
get "uiPath"(): $ResourceLocation
get "customUI"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EditableMachineUI$Type = ($EditableMachineUI);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EditableMachineUI_ = $EditableMachineUI$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/$PipeBlockItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$BlockItem, $BlockItem$Type} from "packages/net/minecraft/world/item/$BlockItem"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$Type} from "packages/net/mehvahdjukaar/moonlight/api/item/additional_placements/$AdditionalItemPlacement"
import {$PipeBlock, $PipeBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$PipeBlock"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$FoodProperties, $FoodProperties$Type} from "packages/net/minecraft/world/food/$FoodProperties"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $PipeBlockItem extends $BlockItem {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "descriptionId": string
 "foodProperties": $FoodProperties
readonly "canRepair": boolean
 "renderProperties": any
 "moonlight$clientAnimationProvider": any

constructor(block: $PipeBlock$Type<(any), (any), (any)>, properties: $Item$Properties$Type)

public "getBlock"(): $PipeBlock<(any), (any), (any)>
public "placeBlock"(context: $BlockPlaceContext$Type, state: $BlockState$Type): boolean
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public "moonlight$addAdditionalBehavior"(arg0: $AdditionalItemPlacement$Type): void
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
get "block"(): $PipeBlock<(any), (any), (any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PipeBlockItem$Type = ($PipeBlockItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PipeBlockItem_ = $PipeBlockItem$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/$GTValues" {
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $GTValues {
static readonly "FALLBACK": integer
static readonly "M": long
static readonly "L": integer
static readonly "RNG": $RandomSource
static "CLIENT_TIME": long
static readonly "V": (long)[]
static readonly "VH": (integer)[]
static readonly "VA": (integer)[]
static readonly "VHA": (integer)[]
static readonly "ULV": integer
static readonly "LV": integer
static readonly "MV": integer
static readonly "HV": integer
static readonly "EV": integer
static readonly "IV": integer
static readonly "LuV": integer
static readonly "ZPM": integer
static readonly "UV": integer
static readonly "UHV": integer
static readonly "UEV": integer
static readonly "UIV": integer
static readonly "UXV": integer
static readonly "OpV": integer
static readonly "MAX": integer
static readonly "ALL_TIERS": (integer)[]
static readonly "TIER_COUNT": integer
static readonly "MODID_TOP": string
static readonly "MODID_JEI": string
static readonly "MODID_APPENG": string
static readonly "MODID_KUBEJS": string
static readonly "MODID_IRIS": string
static readonly "MODID_OCULUS": string
static readonly "MODID_SODIUM": string
static readonly "MODID_RUBIDIUM": string
static readonly "MODID_EMBEDDIUM": string
static readonly "MODID_CREATE": string
static readonly "MODID_REBORN_ENERGY": string
static readonly "MODID_ALMOSTUNIFIED": string
static readonly "MODID_CURIOS": string
static readonly "MODID_AE2WTLIB": string
static readonly "MODID_SHIMMER": string
static readonly "MODID_TINTED": string
static readonly "VN": (string)[]
static readonly "VNF": (string)[]
static readonly "VLVH": (string)[]
static readonly "VLVT": (string)[]
static readonly "LVT": (string)[]
static readonly "VC": (integer)[]
static readonly "VOLTAGE_NAMES": (string)[]
static "HT": boolean
static "FOOLS": $Supplier<(boolean)>
static "XMAS": $Supplier<(boolean)>
static readonly "CUSTOM_TAG_SOURCE": string

constructor()

public static "tiersBetween"(minInclusive: integer, maxInclusive: integer): (integer)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTValues$Type = ($GTValues);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTValues_ = $GTValues$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/$CoilBlock" {
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$ICoilType, $ICoilType$Type} from "packages/com/gregtechceu/gtceu/api/block/$ICoilType"
import {$ActiveBlock, $ActiveBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$ActiveBlock"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$List, $List$Type} from "packages/java/util/$List"

export class $CoilBlock extends $ActiveBlock {
 "coilType": $ICoilType
static readonly "ACTIVE": $BooleanProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, coilType: $ICoilType$Type)

public "appendHoverText"(stack: $ItemStack$Type, level: $BlockGetter$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoilBlock$Type = ($CoilBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CoilBlock_ = $CoilBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pattern/util/$PatternMatchContext" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $PatternMatchContext {

constructor()

public "get"<T>(key: string): T
public "getInt"(key: string): integer
public "entrySet"(): $Set<($Map$Entry<(string), (any)>)>
public "increment"(key: string, value: integer): void
public "set"(key: string, value: any): void
public "containsKey"(key: string): boolean
public "getOrDefault"<T>(key: string, defaultValue: T): T
public "reset"(): void
public "getOrCreate"<T>(key: string, creator: $Supplier$Type<(T)>): T
public "getOrPut"<T>(key: string, initialValue: T): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PatternMatchContext$Type = ($PatternMatchContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PatternMatchContext_ = $PatternMatchContext$Type;
}}
declare module "packages/com/gregtechceu/gtceu/integration/kjs/builders/block/$RendererBlockBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$BlockBuilder, $BlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockBuilder"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$IRenderer, $IRenderer$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IRenderer"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RendererBlockBuilder extends $BlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
 "lootTable": $Consumer<($LootBuilder)>
 "blockstateJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "createObject"(): $Block
public "renderer"(renderer: $IRenderer$Type): $RendererBlockBuilder
public "textureOverrideRenderer"(modelPath: $ResourceLocation$Type, textures: $Map$Type<(string), ($ResourceLocation$Type)>): $RendererBlockBuilder
public "ctmRenderer"(modelPath: $ResourceLocation$Type): $RendererBlockBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RendererBlockBuilder$Type = ($RendererBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RendererBlockBuilder_ = $RendererBlockBuilder$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$DikeVeinGenerator$DikeBlockDefinition" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$OreConfiguration$TargetBlockState, $OreConfiguration$TargetBlockState$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$OreConfiguration$TargetBlockState"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $DikeVeinGenerator$DikeBlockDefinition extends $Record {
static readonly "CODEC": $Codec<($DikeVeinGenerator$DikeBlockDefinition)>

constructor(block: $Either$Type<($List$Type<($OreConfiguration$TargetBlockState$Type)>), ($Material$Type)>, weight: integer, minY: integer, maxY: integer)
constructor(block: $List$Type<($OreConfiguration$TargetBlockState$Type)>, weight: integer, minY: integer, maxY: integer)
constructor(block: $Material$Type, weight: integer, minY: integer, maxY: integer)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "block"(): $Either<($List<($OreConfiguration$TargetBlockState)>), ($Material)>
public "weight"(): integer
public "minY"(): integer
public "maxY"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DikeVeinGenerator$DikeBlockDefinition$Type = ($DikeVeinGenerator$DikeBlockDefinition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DikeVeinGenerator$DikeBlockDefinition_ = $DikeVeinGenerator$DikeBlockDefinition$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/worldgen/feature/$FluidSproutFeature" {
import {$RandomFeatureConfiguration, $RandomFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$RandomFeatureConfiguration"
import {$SpikeConfiguration, $SpikeConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SpikeConfiguration"
import {$MultifaceGrowthConfiguration, $MultifaceGrowthConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$MultifaceGrowthConfiguration"
import {$RootSystemConfiguration, $RootSystemConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$RootSystemConfiguration"
import {$UnderwaterMagmaConfiguration, $UnderwaterMagmaConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$UnderwaterMagmaConfiguration"
import {$WorldGenLevel, $WorldGenLevel$Type} from "packages/net/minecraft/world/level/$WorldGenLevel"
import {$TwistingVinesConfig, $TwistingVinesConfig$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$TwistingVinesConfig"
import {$FeaturePlaceContext, $FeaturePlaceContext$Type} from "packages/net/minecraft/world/level/levelgen/feature/$FeaturePlaceContext"
import {$HugeMushroomFeatureConfiguration, $HugeMushroomFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$HugeMushroomFeatureConfiguration"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$HugeFungusConfiguration, $HugeFungusConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/$HugeFungusConfiguration"
import {$FossilFeatureConfiguration, $FossilFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/$FossilFeatureConfiguration"
import {$DeltaFeatureConfiguration, $DeltaFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$DeltaFeatureConfiguration"
import {$FluidSproutConfiguration, $FluidSproutConfiguration$Type} from "packages/com/gregtechceu/gtceu/common/worldgen/feature/configurations/$FluidSproutConfiguration"
import {$BlockPileConfiguration, $BlockPileConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$BlockPileConfiguration"
import {$OreConfiguration, $OreConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$OreConfiguration"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$SculkPatchConfiguration, $SculkPatchConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SculkPatchConfiguration"
import {$NetherForestVegetationConfig, $NetherForestVegetationConfig$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$NetherForestVegetationConfig"
import {$GeodeConfiguration, $GeodeConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$GeodeConfiguration"
import {$RandomBooleanFeatureConfiguration, $RandomBooleanFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$RandomBooleanFeatureConfiguration"
import {$ColumnFeatureConfiguration, $ColumnFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$ColumnFeatureConfiguration"
import {$CountConfiguration, $CountConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$CountConfiguration"
import {$VegetationPatchConfiguration, $VegetationPatchConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$VegetationPatchConfiguration"
import {$Feature, $Feature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$Feature"
import {$BonusChestFeature, $BonusChestFeature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$BonusChestFeature"
import {$LakeFeature$Configuration, $LakeFeature$Configuration$Type} from "packages/net/minecraft/world/level/levelgen/feature/$LakeFeature$Configuration"
import {$BlockColumnConfiguration, $BlockColumnConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$BlockColumnConfiguration"
import {$BlockPos$MutableBlockPos, $BlockPos$MutableBlockPos$Type} from "packages/net/minecraft/core/$BlockPos$MutableBlockPos"
import {$RandomPatchConfiguration, $RandomPatchConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$RandomPatchConfiguration"
import {$ProbabilityFeatureConfiguration, $ProbabilityFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$ProbabilityFeatureConfiguration"
import {$TreeConfiguration, $TreeConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$TreeConfiguration"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$DripstoneClusterConfiguration, $DripstoneClusterConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$DripstoneClusterConfiguration"
import {$LayerConfiguration, $LayerConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$LayerConfiguration"
import {$ReplaceBlockConfiguration, $ReplaceBlockConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$ReplaceBlockConfiguration"
import {$BlockStateConfiguration, $BlockStateConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$BlockStateConfiguration"
import {$SimpleBlockConfiguration, $SimpleBlockConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SimpleBlockConfiguration"
import {$DiskConfiguration, $DiskConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$DiskConfiguration"
import {$SeagrassFeature, $SeagrassFeature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$SeagrassFeature"
import {$ReplaceSphereConfiguration, $ReplaceSphereConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$ReplaceSphereConfiguration"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$PointedDripstoneConfiguration, $PointedDripstoneConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$PointedDripstoneConfiguration"
import {$SpringConfiguration, $SpringConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SpringConfiguration"
import {$BulkSectionAccess, $BulkSectionAccess$Type} from "packages/net/minecraft/world/level/chunk/$BulkSectionAccess"
import {$SimpleRandomFeatureConfiguration, $SimpleRandomFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SimpleRandomFeatureConfiguration"
import {$LargeDripstoneConfiguration, $LargeDripstoneConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$LargeDripstoneConfiguration"
import {$MutableInt, $MutableInt$Type} from "packages/org/apache/commons/lang3/mutable/$MutableInt"
import {$RuleTest, $RuleTest$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$RuleTest"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$NoneFeatureConfiguration"
import {$EndGatewayConfiguration, $EndGatewayConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$EndGatewayConfiguration"

export class $FluidSproutFeature extends $Feature<($FluidSproutConfiguration)> {
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>

constructor()

public "setBlock"(mutablePos: $BlockPos$MutableBlockPos$Type, currentX: integer, currentY: integer, currentZ: integer, access: $BulkSectionAccess$Type, level: $WorldGenLevel$Type, config: $FluidSproutConfiguration$Type, placedAmount: $MutableInt$Type): void
public "place"(context: $FeaturePlaceContext$Type<($FluidSproutConfiguration$Type)>): boolean
public "canPlaceFluid"(state: $BlockState$Type, adjacentStateAccessor: $Function$Type<($BlockPos$Type), ($BlockState$Type)>, random: $RandomSource$Type, target: $RuleTest$Type, mutablePos: $BlockPos$MutableBlockPos$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidSproutFeature$Type = ($FluidSproutFeature);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidSproutFeature_ = $FluidSproutFeature$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/capability/$IEnergyInfoProvider" {
import {$IEnergyInfoProvider$EnergyInfo, $IEnergyInfoProvider$EnergyInfo$Type} from "packages/com/gregtechceu/gtceu/api/capability/$IEnergyInfoProvider$EnergyInfo"

export interface $IEnergyInfoProvider {

 "getEnergyInfo"(): $IEnergyInfoProvider$EnergyInfo
 "supportsBigIntEnergyValues"(): boolean
}

export namespace $IEnergyInfoProvider {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEnergyInfoProvider$Type = ($IEnergyInfoProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IEnergyInfoProvider_ = $IEnergyInfoProvider$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolItem" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$FoodProperties, $FoodProperties$Type} from "packages/net/minecraft/world/food/$FoodProperties"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IGTTool, $IGTTool$Type} from "packages/com/gregtechceu/gtceu/api/item/$IGTTool"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$DustProperty, $DustProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$DustProperty"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$IGTToolDefinition, $IGTToolDefinition$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$IGTToolDefinition"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$DiggerItem, $DiggerItem$Type} from "packages/net/minecraft/world/item/$DiggerItem"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$HeldItemUIFactory$HeldItemHolder, $HeldItemUIFactory$HeldItemHolder$Type} from "packages/com/lowdragmc/lowdraglib/gui/factory/$HeldItemUIFactory$HeldItemHolder"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$ItemColor, $ItemColor$Type} from "packages/net/minecraft/client/color/item/$ItemColor"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$GTToolType, $GTToolType$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$MaterialToolTier, $MaterialToolTier$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$MaterialToolTier"
import {$ModularUI, $ModularUI$Type} from "packages/com/lowdragmc/lowdraglib/gui/modular/$ModularUI"
import {$ToolProperty, $ToolProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$ToolProperty"
import {$SoundEntry, $SoundEntry$Type} from "packages/com/gregtechceu/gtceu/api/sound/$SoundEntry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GTToolItem extends $DiggerItem implements $IGTTool {
 "speed": float
 "defaultModifiers": $Multimap<($Attribute), ($AttributeModifier)>
 "tier": $Tier
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "descriptionId": string
 "foodProperties": $FoodProperties
readonly "canRepair": boolean
 "renderProperties": any
 "moonlight$clientAnimationProvider": any


public static "create"(toolType: $GTToolType$Type, tier: $MaterialToolTier$Type, material: $Material$Type, definition: $IGTToolDefinition$Type, properties: $Item$Properties$Type): $GTToolItem
public "getDamage"(stack: $ItemStack$Type): integer
public "appendHoverText"(stack: $ItemStack$Type, level: $Level$Type, tooltipComponents: $List$Type<($Component$Type)>, isAdvanced: $TooltipFlag$Type): void
public "getName"(stack: $ItemStack$Type): $Component
public "shouldCauseReequipAnimation"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type, slotChanged: boolean): boolean
public "isCorrectToolForDrops"(stack: $ItemStack$Type, state: $BlockState$Type): boolean
public "getCraftingRemainingItem"(itemStack: $ItemStack$Type): $ItemStack
public "hasCraftingRemainingItem"(stack: $ItemStack$Type): boolean
public "getAttributeModifiers"(slot: $EquipmentSlot$Type, stack: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "use"(level: $Level$Type, player: $Player$Type, usedHand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "useOn"(context: $UseOnContext$Type): $InteractionResult
public "getDestroySpeed"(stack: $ItemStack$Type, state: $BlockState$Type): float
public "hurtEnemy"(stack: $ItemStack$Type, target: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
public "getMaxDamage"(stack: $ItemStack$Type): integer
public "mineBlock"(stack: $ItemStack$Type, level: $Level$Type, state: $BlockState$Type, pos: $BlockPos$Type, miningEntity: $LivingEntity$Type): boolean
public "getDescription"(): $Component
public "hasCraftingRemainingItem"(): boolean
public "isValidRepairItem"(stack: $ItemStack$Type, repairCandidate: $ItemStack$Type): boolean
public "doesSneakBypassUse"(stack: $ItemStack$Type, level: $LevelReader$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "onItemUseFirst"(itemStack: $ItemStack$Type, context: $UseOnContext$Type): $InteractionResult
public "onBlockStartBreak"(stack: $ItemStack$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "isDamaged"(stack: $ItemStack$Type): boolean
public "setDamage"(stack: $ItemStack$Type, damage: integer): void
public "getSound"(): $SoundEntry
public "canDisableShield"(stack: $ItemStack$Type, shield: $ItemStack$Type, entity: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
public "getEnchantmentValue"(stack: $ItemStack$Type): integer
public "shouldCauseBlockBreakReset"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type): boolean
public "canApplyAtEnchantingTable"(stack: $ItemStack$Type, enchantment: $Enchantment$Type): boolean
public "getDescriptionId"(): string
public "getDefaultInstance"(): $ItemStack
public "initCapabilities"(stack: $ItemStack$Type, nbt: $CompoundTag$Type): $ICapabilityProvider
public "isElectric"(): boolean
public "getMaterial"(): $Material
public "playSoundOnBlockDestroy"(): boolean
public "getToolStats"(): $IGTToolDefinition
public "getElectricTier"(): integer
public "getToolType"(): $GTToolType
public "get"(defaultMaxCharge: long): $ItemStack
public "get"(): $ItemStack
public "get"(defaultCharge: long, defaultMaxCharge: long): $ItemStack
public "getRaw"(): $ItemStack
public "getColor"(stack: $ItemStack$Type, tintIndex: integer): integer
public "createUI"(entityPlayer: $Player$Type, holder: $HeldItemUIFactory$HeldItemHolder$Type): $ModularUI
public static "tintColor"(): $ItemColor
public "definition$canApplyAtEnchantingTable"(stack: $ItemStack$Type, enchantment: $Enchantment$Type): boolean
public "definition$shouldCauseReequipAnimation"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type, slotChanged: boolean): boolean
public "definition$getDefaultAttributeModifiers"(equipmentSlot: $EquipmentSlot$Type, stack: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "definition$shouldCauseBlockBreakReset"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type): boolean
public "definition$getCraftingRemainingItem"(stack: $ItemStack$Type): $ItemStack
public "definition$hasCraftingRemainingItem"(stack: $ItemStack$Type): boolean
public "definition$canDestroyBlockInCreative"(world: $Level$Type, pos: $BlockPos$Type, stack: $ItemStack$Type, player: $Player$Type): boolean
public "getCharge"(stack: $ItemStack$Type): long
public "playSound"(player: $Player$Type): void
public "asItem"(): $Item
public "definition$isDamaged"(stack: $ItemStack$Type): boolean
public "getToolMaterial"(stack: $ItemStack$Type): $Material
public "getMaxCharge"(stack: $ItemStack$Type): long
public "getToolClasses"(stack: $ItemStack$Type): $Set<($GTToolType)>
public "getTotalToolSpeed"(stack: $ItemStack$Type): float
public "getToolProperty"(stack: $ItemStack$Type): $ToolProperty
public "getDustProperty"(stack: $ItemStack$Type): $DustProperty
public "playCraftingSound"(player: $Player$Type, stack: $ItemStack$Type): void
public "definition$use"(world: $Level$Type, player: $Player$Type, hand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "definition$init"(): void
public "canPlaySound"(stack: $ItemStack$Type): boolean
public "getToolClassNames"(stack: $ItemStack$Type): $Set<(string)>
public "definition$getDestroySpeed"(stack: $ItemStack$Type, state: $BlockState$Type): float
public "getTotalAttackDamage"(stack: $ItemStack$Type): float
public "getTotalAttackSpeed"(stack: $ItemStack$Type): float
public "definition$hurtEnemy"(stack: $ItemStack$Type, target: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
public "getTotalHarvestLevel"(stack: $ItemStack$Type): integer
public "getMaterialAttackSpeed"(stack: $ItemStack$Type): float
public "definition$onBlockStartBreak"(stack: $ItemStack$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "definition$mineBlock"(stack: $ItemStack$Type, worldIn: $Level$Type, state: $BlockState$Type, pos: $BlockPos$Type, entityLiving: $LivingEntity$Type): boolean
public "definition$isValidRepairItem"(toRepair: $ItemStack$Type, repair: $ItemStack$Type): boolean
public "definition$getHarvestLevel"(stack: $ItemStack$Type, toolClass: $GTToolType$Type, player: $Player$Type, blockState: $BlockState$Type): integer
public "getMaterialAttackDamage"(stack: $ItemStack$Type): float
public "definition$canDisableShield"(stack: $ItemStack$Type, shield: $ItemStack$Type, entity: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
public "definition$doesSneakBypassUse"(stack: $ItemStack$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "getMaterialEnchantability"(stack: $ItemStack$Type): integer
public "definition$onEntitySwing"(entityLiving: $LivingEntity$Type, stack: $ItemStack$Type): boolean
public "getTotalEnchantability"(stack: $ItemStack$Type): integer
public "getMaterialDurability"(stack: $ItemStack$Type): integer
public "definition$getDamage"(stack: $ItemStack$Type): integer
public "getTotalMaxDurability"(stack: $ItemStack$Type): integer
public "getMaterialToolSpeed"(stack: $ItemStack$Type): float
public "getMaterialHarvestLevel"(stack: $ItemStack$Type): integer
public "definition$getMaxDamage"(stack: $ItemStack$Type): integer
public "definition$setDamage"(stack: $ItemStack$Type, durability: integer): void
public "definition$getDurabilityForDisplay"(stack: $ItemStack$Type): double
public "definition$onItemUse"(context: $UseOnContext$Type): $InteractionResult
public "setLastCraftingSoundTime"(stack: $ItemStack$Type): void
public "definition$initCapabilities"(stack: $ItemStack$Type, nbt: $CompoundTag$Type): $ICapabilityProvider
public "definition$appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "definition$shouldOpenUIAfterUse"(context: $UseOnContext$Type): boolean
public "definition$fillItemCategory"(category: $CreativeModeTab$Type, items: $NonNullList$Type<($ItemStack$Type)>): void
public "definition$onItemUseFirst"(stack: $ItemStack$Type, context: $UseOnContext$Type): $InteractionResult
public "definition$isCorrectToolForDrops"(stack: $ItemStack$Type, state: $BlockState$Type): boolean
get "description"(): $Component
get "sound"(): $SoundEntry
get "descriptionId"(): string
get "defaultInstance"(): $ItemStack
get "electric"(): boolean
get "material"(): $Material
get "toolStats"(): $IGTToolDefinition
get "electricTier"(): integer
get "toolType"(): $GTToolType
get "raw"(): $ItemStack
set "lastCraftingSoundTime"(value: $ItemStack$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTToolItem$Type = ($GTToolItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTToolItem_ = $GTToolItem$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/multiblock/$IBatteryData" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IBatteryData {

 "getCapacity"(): long
 "getTier"(): integer
 "getBatteryName"(): string
}

export namespace $IBatteryData {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IBatteryData$Type = ($IBatteryData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IBatteryData_ = $IBatteryData$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/modifier/$RecipeModifier" {
import {$GTRecipe, $GTRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe"
import {$MetaMachine, $MetaMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MetaMachine"

export interface $RecipeModifier {

 "apply"(arg0: $MetaMachine$Type, arg1: $GTRecipe$Type): $GTRecipe

(arg0: $MetaMachine$Type, arg1: $GTRecipe$Type): $GTRecipe
}

export namespace $RecipeModifier {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeModifier$Type = ($RecipeModifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeModifier_ = $RecipeModifier$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/feature/$IRedstoneSignalMachine" {
import {$IMachineFeature, $IMachineFeature$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/$IMachineFeature"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$MetaMachine, $MetaMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MetaMachine"

export interface $IRedstoneSignalMachine extends $IMachineFeature {

 "canConnectRedstone"(side: $Direction$Type): boolean
 "updateSignal"(): void
 "getAnalogOutputSignal"(): integer
 "getOutputSignal"(side: $Direction$Type): integer
 "getOutputDirectSignal"(direction: $Direction$Type): integer
 "self"(): $MetaMachine
}

export namespace $IRedstoneSignalMachine {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRedstoneSignalMachine$Type = ($IRedstoneSignalMachine);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRedstoneSignalMachine_ = $IRedstoneSignalMachine$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/fluidpipe/$FluidPipeType" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$IMaterialPipeType, $IMaterialPipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IMaterialPipeType"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$PipeModel, $PipeModel$Type} from "packages/com/gregtechceu/gtceu/client/model/$PipeModel"
import {$TagPrefix, $TagPrefix$Type} from "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidPipeProperties, $FluidPipeProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$FluidPipeProperties"

export class $FluidPipeType extends $Enum<($FluidPipeType)> implements $IMaterialPipeType<($FluidPipeProperties)> {
static readonly "TINY": $FluidPipeType
static readonly "SMALL": $FluidPipeType
static readonly "NORMAL": $FluidPipeType
static readonly "LARGE": $FluidPipeType
static readonly "HUGE": $FluidPipeType
static readonly "QUADRUPLE": $FluidPipeType
static readonly "NONUPLE": $FluidPipeType
static readonly "TYPE_ID": $ResourceLocation
readonly "name": string
readonly "thickness": float
readonly "capacityMultiplier": integer
readonly "tagPrefix": $TagPrefix
readonly "channels": integer


public "type"(): $ResourceLocation
public static "values"(): ($FluidPipeType)[]
public static "valueOf"(name: string): $FluidPipeType
public "getThickness"(): float
public "getTagPrefix"(): $TagPrefix
public "modifyProperties"(fluidPipeData: $FluidPipeProperties$Type): $FluidPipeProperties
public "isPaintable"(): boolean
public "createPipeModel"(material: $Material$Type): $PipeModel
get "thickness"(): float
get "tagPrefix"(): $TagPrefix
get "paintable"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidPipeType$Type = (("small") | ("normal") | ("quadruple") | ("large") | ("tiny") | ("huge") | ("nonuple")) | ($FluidPipeType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidPipeType_ = $FluidPipeType$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/$TagPrefixItem" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$TagPrefix, $TagPrefix$Type} from "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$ItemColor, $ItemColor$Type} from "packages/net/minecraft/client/color/item/$ItemColor"
import {$FoodProperties, $FoodProperties$Type} from "packages/net/minecraft/world/food/$FoodProperties"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $TagPrefixItem extends $Item {
readonly "tagPrefix": $TagPrefix
readonly "material": $Material
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "descriptionId": string
 "foodProperties": $FoodProperties
readonly "canRepair": boolean
 "renderProperties": any
 "moonlight$clientAnimationProvider": any

constructor(properties: $Item$Properties$Type, tagPrefix: $TagPrefix$Type, material: $Material$Type)

public "getItemBurnTime"(): integer
public "appendHoverText"(stack: $ItemStack$Type, level: $Level$Type, tooltipComponents: $List$Type<($Component$Type)>, isAdvanced: $TooltipFlag$Type): void
public "getName"(stack: $ItemStack$Type): $Component
public static "tintColor"(): $ItemColor
public "onRegister"(): void
public "getDescriptionId"(stack: $ItemStack$Type): string
public "inventoryTick"(stack: $ItemStack$Type, level: $Level$Type, entity: $Entity$Type, slotId: integer, isSelected: boolean): void
public "getDescription"(): $Component
public "getBurnTime"(itemStack: $ItemStack$Type, recipeType: $RecipeType$Type<(any)>): integer
public "getDescriptionId"(): string
get "itemBurnTime"(): integer
get "description"(): $Component
get "descriptionId"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagPrefixItem$Type = ($TagPrefixItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TagPrefixItem_ = $TagPrefixItem$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/block/$ActiveBlock" {
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$AppearanceBlock, $AppearanceBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$AppearanceBlock"
import {$IRenderer, $IRenderer$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IRenderer"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$IBlockRendererProvider, $IBlockRendererProvider$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IBlockRendererProvider"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export class $ActiveBlock extends $AppearanceBlock implements $IBlockRendererProvider {
static readonly "ACTIVE": $BooleanProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, renderer: $IRenderer$Type, activeRenderer: $IRenderer$Type)

public "isActive"(state: $BlockState$Type): boolean
public "getRenderer"(state: $BlockState$Type): $IRenderer
public "getBlockAppearance"(state: $BlockState$Type, level: $BlockAndTintGetter$Type, pos: $BlockPos$Type, side: $Direction$Type, sourceState: $BlockState$Type, sourcePos: $BlockPos$Type): $BlockState
public "changeActive"(state: $BlockState$Type, active: boolean): $BlockState
public "getLightMap"(world: $BlockAndTintGetter$Type, state: $BlockState$Type, pos: $BlockPos$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ActiveBlock$Type = ($ActiveBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ActiveBlock_ = $ActiveBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pattern/predicates/$SimplePredicate" {
import {$BlockInfo, $BlockInfo$Type} from "packages/com/lowdragmc/lowdraglib/utils/$BlockInfo"
import {$MultiblockState, $MultiblockState$Type} from "packages/com/gregtechceu/gtceu/api/pattern/$MultiblockState"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TraceabilityPredicate, $TraceabilityPredicate$Type} from "packages/com/gregtechceu/gtceu/api/pattern/$TraceabilityPredicate"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$IO, $IO$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IO"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $SimplePredicate {
static "ANY": $SimplePredicate
static "AIR": $SimplePredicate
 "candidates": $Supplier<(($BlockInfo)[])>
 "predicate": $Predicate<($MultiblockState)>
 "toolTips": $List<($Component)>
 "minCount": integer
 "maxCount": integer
 "minLayerCount": integer
 "maxLayerCount": integer
 "previewCount": integer
 "disableRenderFormed": boolean
 "io": $IO
 "slotName": string
 "nbtParser": string
readonly "type": string

constructor(type: string, predicate: $Predicate$Type<($MultiblockState$Type)>, candidates: $Supplier$Type<(($BlockInfo$Type)[])>)
constructor(predicate: $Predicate$Type<($MultiblockState$Type)>, candidates: $Supplier$Type<(($BlockInfo$Type)[])>)
constructor(type: string)
constructor()

public "test"(blockWorldState: $MultiblockState$Type): boolean
public "getToolTips"(predicates: $TraceabilityPredicate$Type): $List<($Component)>
public "getCandidates"(): $List<($ItemStack)>
public "buildPredicate"(): $SimplePredicate
public "testGlobal"(blockWorldState: $MultiblockState$Type): boolean
public "testLayer"(blockWorldState: $MultiblockState$Type): boolean
public "testLimited"(blockWorldState: $MultiblockState$Type): boolean
get "candidates"(): $List<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimplePredicate$Type = ($SimplePredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SimplePredicate_ = $SimplePredicate$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/$OpticalPipeBlock" {
import {$BlockColor, $BlockColor$Type} from "packages/net/minecraft/client/color/block/$BlockColor"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$PipeModel, $PipeModel$Type} from "packages/com/gregtechceu/gtceu/client/model/$PipeModel"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$OpticalPipeProperties, $OpticalPipeProperties$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/optical/$OpticalPipeProperties"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$IPipeNode, $IPipeNode$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeNode"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$PipeBlock, $PipeBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$PipeBlock"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$PipeBlockRenderer, $PipeBlockRenderer$Type} from "packages/com/gregtechceu/gtceu/client/renderer/block/$PipeBlockRenderer"
import {$OpticalPipeType, $OpticalPipeType$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/optical/$OpticalPipeType"
import {$LevelOpticalPipeNet, $LevelOpticalPipeNet$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/optical/$LevelOpticalPipeNet"
import {$IPipeType, $IPipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeType"

export class $OpticalPipeBlock extends $PipeBlock<($OpticalPipeType), ($OpticalPipeProperties), ($LevelOpticalPipeNet)> {
readonly "renderer": $PipeBlockRenderer
readonly "pipeModel": $PipeModel
readonly "pipeType": PipeType
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, pipeType: $OpticalPipeType$Type)

public "createProperties"(pipeTile: $IPipeNode$Type<($OpticalPipeType$Type), ($OpticalPipeProperties$Type)>): $OpticalPipeProperties
public "getBlockEntityType"(): $BlockEntityType<(any)>
public "canPipeConnectToBlock"(selfTile: $IPipeNode$Type<($OpticalPipeType$Type), ($OpticalPipeProperties$Type)>, side: $Direction$Type, tile: $BlockEntity$Type): boolean
public static "tintedColor"(): $BlockColor
public "getWorldPipeNet"(level: $ServerLevel$Type): $LevelOpticalPipeNet
public "getPipeModel"(): $PipeModel
public "getFallbackType"(): $OpticalPipeProperties
public "canPipesConnect"(selfTile: $IPipeNode$Type<($OpticalPipeType$Type), ($OpticalPipeProperties$Type)>, side: $Direction$Type, sideTile: $IPipeNode$Type<($OpticalPipeType$Type), ($OpticalPipeProperties$Type)>): boolean
get "blockEntityType"(): $BlockEntityType<(any)>
get "pipeModel"(): $PipeModel
get "fallbackType"(): $OpticalPipeProperties
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OpticalPipeBlock$Type = ($OpticalPipeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OpticalPipeBlock_ = $OpticalPipeBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeNode" {
import {$ITickSubscription, $ITickSubscription$Type} from "packages/com/gregtechceu/gtceu/api/blockentity/$ITickSubscription"
import {$ICoverable, $ICoverable$Type} from "packages/com/gregtechceu/gtceu/api/capability/$ICoverable"
import {$PipeNet, $PipeNet$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$PipeNet"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$TickableSubscription, $TickableSubscription$Type} from "packages/com/gregtechceu/gtceu/api/machine/$TickableSubscription"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$PipeBlock, $PipeBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$PipeBlock"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IPaintable, $IPaintable$Type} from "packages/com/gregtechceu/gtceu/api/blockentity/$IPaintable"
import {$IPipeType, $IPipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeType"

export interface $IPipeNode<PipeType extends ($Enum<(PipeType)>) & ($IPipeType<(NodeDataType)>), NodeDataType> extends $ITickSubscription, $IPaintable {

 "self"(): $BlockEntity
 "isConnected"(side: $Direction$Type): boolean
 "markAsDirty"(): void
 "setConnections"(arg0: integer): void
 "isRemote"(): boolean
 "isBlocked"(side: $Direction$Type): boolean
 "serverTick"(): void
 "getConnections"(): integer
 "setConnection"(arg0: $Direction$Type, arg1: boolean, arg2: boolean): void
 "canAttachTo"(arg0: $Direction$Type): boolean
 "notifyBlockUpdate"(): void
 "getDefaultPaintingColor"(): integer
 "setBlocked"(arg0: $Direction$Type, arg1: boolean): void
 "canHaveBlockedFaces"(): boolean
 "getBlockedConnections"(): integer
 "scheduleRenderUpdate"(): void
 "scheduleNeighborShapeUpdate"(): void
 "getVisualConnections"(): integer
 "getNumConnections"(): integer
 "getPipeType"(): PipeType
 "getFrameMaterial"(): $Material
 "getPipeLevel"(): $Level
 "getPipeNet"(): $PipeNet<(NodeDataType)>
 "getPipePos"(): $BlockPos
 "getCoverContainer"(): $ICoverable
 "getNeighbor"(direction: $Direction$Type): $BlockEntity
 "getPipeBlock"(): $PipeBlock<(PipeType), (NodeDataType), (any)>
 "getOffsetTimer"(): long
 "getNodeData"(): NodeDataType
 "isInValid"(): boolean
 "unsubscribe"(arg0: $TickableSubscription$Type): void
 "subscribeServerTick"(arg0: $Runnable$Type): $TickableSubscription
 "subscribeServerTick"(last: $TickableSubscription$Type, runnable: $Runnable$Type): $TickableSubscription
 "isPainted"(): boolean
 "getRealColor"(): integer
 "getPaintingColor"(): integer
 "setPaintingColor"(arg0: integer): void
}

export namespace $IPipeNode {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IPipeNode$Type<PipeType, NodeDataType> = ($IPipeNode<(PipeType), (NodeDataType)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IPipeNode_<PipeType, NodeDataType> = $IPipeNode$Type<(PipeType), (NodeDataType)>;
}}
declare module "packages/com/gregtechceu/gtceu/common/data/$GTItems" {
import {$NonNullConsumer, $NonNullConsumer$Type} from "packages/com/tterrag/registrate/util/nullness/$NonNullConsumer"
import {$ItemProviderEntry, $ItemProviderEntry$Type} from "packages/com/tterrag/registrate/util/entry/$ItemProviderEntry"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ICustomDescriptionId, $ICustomDescriptionId$Type} from "packages/com/gregtechceu/gtceu/api/item/component/$ICustomDescriptionId"
import {$CompassNode, $CompassNode$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$CompassNode"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ItemMaterialInfo, $ItemMaterialInfo$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/stack/$ItemMaterialInfo"
import {$IGTTool, $IGTTool$Type} from "packages/com/gregtechceu/gtceu/api/item/$IGTTool"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$IItemComponent, $IItemComponent$Type} from "packages/com/gregtechceu/gtceu/api/item/component/$IItemComponent"
import {$CompassSection, $CompassSection$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$CompassSection"
import {$Table, $Table$Type} from "packages/com/google/common/collect/$Table"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$TagPrefix, $TagPrefix$Type} from "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix"
import {$IComponentItem, $IComponentItem$Type} from "packages/com/gregtechceu/gtceu/api/item/$IComponentItem"
import {$ItemBuilder, $ItemBuilder$Type} from "packages/com/tterrag/registrate/builders/$ItemBuilder"
import {$RecordItem, $RecordItem$Type} from "packages/net/minecraft/world/item/$RecordItem"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$ItemColor, $ItemColor$Type} from "packages/net/minecraft/client/color/item/$ItemColor"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ComponentItem, $ComponentItem$Type} from "packages/com/gregtechceu/gtceu/api/item/$ComponentItem"
import {$ItemPropertyFunction, $ItemPropertyFunction$Type} from "packages/net/minecraft/client/renderer/item/$ItemPropertyFunction"
import {$TagPrefixItem, $TagPrefixItem$Type} from "packages/com/gregtechceu/gtceu/api/item/$TagPrefixItem"
import {$MarkerMaterial, $MarkerMaterial$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$MarkerMaterial"
import {$GTToolType, $GTToolType$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType"
import {$ItemEntry, $ItemEntry$Type} from "packages/com/tterrag/registrate/util/entry/$ItemEntry"
import {$MaterialToolTier, $MaterialToolTier$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$MaterialToolTier"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"
import {$ArmorComponentItem, $ArmorComponentItem$Type} from "packages/com/gregtechceu/gtceu/api/item/armor/$ArmorComponentItem"
import {$UnificationEntry, $UnificationEntry$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/stack/$UnificationEntry"
import {$NonNullFunction, $NonNullFunction$Type} from "packages/com/tterrag/registrate/util/nullness/$NonNullFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GTItems {
static readonly "toUnify": $Map<($UnificationEntry), ($Supplier<(any)>)>
static readonly "purifyMap": $Map<($TagPrefix), ($TagPrefix)>
static "MATERIAL_ITEMS": $Table<($TagPrefix), ($Material), ($ItemEntry<($TagPrefixItem)>)>
static readonly "TOOL_ITEMS": $Table<($Material), ($GTToolType), ($ItemProviderEntry<($IGTTool)>)>
static "CREDIT_COPPER": $ItemEntry<($Item)>
static "CREDIT_CUPRONICKEL": $ItemEntry<($Item)>
static "CREDIT_SILVER": $ItemEntry<($Item)>
static "CREDIT_GOLD": $ItemEntry<($Item)>
static "CREDIT_PLATINUM": $ItemEntry<($Item)>
static "CREDIT_OSMIUM": $ItemEntry<($Item)>
static "CREDIT_NAQUADAH": $ItemEntry<($Item)>
static "CREDIT_NEUTRONIUM": $ItemEntry<($Item)>
static "COIN_GOLD_ANCIENT": $ItemEntry<($Item)>
static "COIN_DOGE": $ItemEntry<($Item)>
static "COIN_CHOCOLATE": $ItemEntry<($Item)>
static "COMPRESSED_CLAY": $ItemEntry<($Item)>
static "COMPRESSED_COKE_CLAY": $ItemEntry<($Item)>
static "COMPRESSED_FIRECLAY": $ItemEntry<($Item)>
static "FIRECLAY_BRICK": $ItemEntry<($Item)>
static "COKE_OVEN_BRICK": $ItemEntry<($Item)>
static "WOODEN_FORM_EMPTY": $ItemEntry<($Item)>
static "WOODEN_FORM_BRICK": $ItemEntry<($ComponentItem)>
static "SHAPE_EMPTY": $ItemEntry<($Item)>
static readonly "SHAPE_MOLDS": ($ItemEntry<($Item)>)[]
static readonly "SHAPE_MOLD_PLATE": $ItemEntry<($Item)>
static readonly "SHAPE_MOLD_GEAR": $ItemEntry<($Item)>
static readonly "SHAPE_MOLD_CREDIT": $ItemEntry<($Item)>
static readonly "SHAPE_MOLD_BOTTLE": $ItemEntry<($Item)>
static readonly "SHAPE_MOLD_INGOT": $ItemEntry<($Item)>
static readonly "SHAPE_MOLD_BALL": $ItemEntry<($Item)>
static readonly "SHAPE_MOLD_BLOCK": $ItemEntry<($Item)>
static readonly "SHAPE_MOLD_NUGGET": $ItemEntry<($Item)>
static readonly "SHAPE_MOLD_CYLINDER": $ItemEntry<($Item)>
static readonly "SHAPE_MOLD_ANVIL": $ItemEntry<($Item)>
static readonly "SHAPE_MOLD_NAME": $ItemEntry<($Item)>
static readonly "SHAPE_MOLD_GEAR_SMALL": $ItemEntry<($Item)>
static readonly "SHAPE_MOLD_ROTOR": $ItemEntry<($Item)>
static readonly "SHAPE_MOLD_PILL": $ItemEntry<($Item)>
static readonly "SHAPE_EXTRUDERS": ($ItemEntry<($Item)>)[]
static "SHAPE_EXTRUDER_PLATE": $ItemEntry<($Item)>
static "SHAPE_EXTRUDER_ROD": $ItemEntry<($Item)>
static "SHAPE_EXTRUDER_BOLT": $ItemEntry<($Item)>
static "SHAPE_EXTRUDER_RING": $ItemEntry<($Item)>
static "SHAPE_EXTRUDER_CELL": $ItemEntry<($Item)>
static "SHAPE_EXTRUDER_INGOT": $ItemEntry<($Item)>
static "SHAPE_EXTRUDER_WIRE": $ItemEntry<($Item)>
static "SHAPE_EXTRUDER_PIPE_TINY": $ItemEntry<($Item)>
static "SHAPE_EXTRUDER_PIPE_SMALL": $ItemEntry<($Item)>
static "SHAPE_EXTRUDER_PIPE_NORMAL": $ItemEntry<($Item)>
static "SHAPE_EXTRUDER_PIPE_LARGE": $ItemEntry<($Item)>
static "SHAPE_EXTRUDER_PIPE_HUGE": $ItemEntry<($Item)>
static "SHAPE_EXTRUDER_BLOCK": $ItemEntry<($Item)>
static "SHAPE_EXTRUDER_GEAR": $ItemEntry<($Item)>
static "SHAPE_EXTRUDER_BOTTLE": $ItemEntry<($Item)>
static "SHAPE_EXTRUDER_FOIL": $ItemEntry<($Item)>
static "SHAPE_EXTRUDER_GEAR_SMALL": $ItemEntry<($Item)>
static "SHAPE_EXTRUDER_ROD_LONG": $ItemEntry<($Item)>
static "SHAPE_EXTRUDER_ROTOR": $ItemEntry<($Item)>
static "SPRAY_EMPTY": $ItemEntry<($Item)>
static "SPRAY_SOLVENT": $ItemEntry<($ComponentItem)>
static "PORTABLE_SCANNER": $ItemEntry<($ComponentItem)>
static "PORTABLE_DEBUG_SCANNER": $ItemEntry<($ComponentItem)>
static "FLUID_CELL": $ItemEntry<($ComponentItem)>
static "FLUID_CELL_UNIVERSAL": $ItemEntry<($ComponentItem)>
static "FLUID_CELL_LARGE_STEEL": $ItemEntry<($ComponentItem)>
static "FLUID_CELL_LARGE_ALUMINIUM": $ItemEntry<($ComponentItem)>
static "FLUID_CELL_LARGE_STAINLESS_STEEL": $ItemEntry<($ComponentItem)>
static "FLUID_CELL_LARGE_TITANIUM": $ItemEntry<($ComponentItem)>
static "FLUID_CELL_LARGE_TUNGSTEN_STEEL": $ItemEntry<($ComponentItem)>
static "FLUID_CELL_GLASS_VIAL": $ItemEntry<($ComponentItem)>
static "TOOL_MATCHES": $ItemEntry<($Item)>
static "TOOL_MATCHBOX": $ItemEntry<($Item)>
static "TOOL_LIGHTER_INVAR": $ItemEntry<($Item)>
static "TOOL_LIGHTER_PLATINUM": $ItemEntry<($Item)>
static "CARBON_FIBERS": $ItemEntry<($Item)>
static "CARBON_MESH": $ItemEntry<($Item)>
static "CARBON_FIBER_PLATE": $ItemEntry<($Item)>
static "DUCT_TAPE": $ItemEntry<($Item)>
static "NEUTRON_REFLECTOR": $ItemEntry<($Item)>
static "BATTERY_HULL_LV": $ItemEntry<($Item)>
static "BATTERY_HULL_MV": $ItemEntry<($Item)>
static "BATTERY_HULL_HV": $ItemEntry<($Item)>
static "BATTERY_HULL_SMALL_VANADIUM": $ItemEntry<($Item)>
static "BATTERY_HULL_MEDIUM_VANADIUM": $ItemEntry<($Item)>
static "BATTERY_HULL_LARGE_VANADIUM": $ItemEntry<($Item)>
static "BATTERY_HULL_MEDIUM_NAQUADRIA": $ItemEntry<($Item)>
static "BATTERY_HULL_LARGE_NAQUADRIA": $ItemEntry<($Item)>
static "BATTERY_ULV_TANTALUM": $ItemEntry<($ComponentItem)>
static "BATTERY_LV_SODIUM": $ItemEntry<($ComponentItem)>
static "BATTERY_MV_SODIUM": $ItemEntry<($ComponentItem)>
static "BATTERY_HV_SODIUM": $ItemEntry<($ComponentItem)>
static "BATTERY_LV_LITHIUM": $ItemEntry<($ComponentItem)>
static "BATTERY_MV_LITHIUM": $ItemEntry<($ComponentItem)>
static "BATTERY_HV_LITHIUM": $ItemEntry<($ComponentItem)>
static "BATTERY_LV_CADMIUM": $ItemEntry<($ComponentItem)>
static "BATTERY_MV_CADMIUM": $ItemEntry<($ComponentItem)>
static "BATTERY_HV_CADMIUM": $ItemEntry<($ComponentItem)>
static "ENERGIUM_CRYSTAL": $ItemEntry<($ComponentItem)>
static "LAPOTRON_CRYSTAL": $ItemEntry<($ComponentItem)>
static "BATTERY_EV_VANADIUM": $ItemEntry<($ComponentItem)>
static "BATTERY_IV_VANADIUM": $ItemEntry<($ComponentItem)>
static "BATTERY_LUV_VANADIUM": $ItemEntry<($ComponentItem)>
static "BATTERY_ZPM_NAQUADRIA": $ItemEntry<($ComponentItem)>
static "BATTERY_UV_NAQUADRIA": $ItemEntry<($ComponentItem)>
static "ENERGY_LAPOTRONIC_ORB": $ItemEntry<($ComponentItem)>
static "ENERGY_LAPOTRONIC_ORB_CLUSTER": $ItemEntry<($ComponentItem)>
static "ENERGY_MODULE": $ItemEntry<($ComponentItem)>
static "ENERGY_CLUSTER": $ItemEntry<($ComponentItem)>
static "ZERO_POINT_MODULE": $ItemEntry<($ComponentItem)>
static "ULTIMATE_BATTERY": $ItemEntry<($ComponentItem)>
static "ELECTRIC_MOTOR_LV": $ItemEntry<($Item)>
static "ELECTRIC_MOTOR_MV": $ItemEntry<($Item)>
static "ELECTRIC_MOTOR_HV": $ItemEntry<($Item)>
static "ELECTRIC_MOTOR_EV": $ItemEntry<($Item)>
static "ELECTRIC_MOTOR_IV": $ItemEntry<($Item)>
static "ELECTRIC_MOTOR_LuV": $ItemEntry<($Item)>
static "ELECTRIC_MOTOR_ZPM": $ItemEntry<($Item)>
static "ELECTRIC_MOTOR_UV": $ItemEntry<($Item)>
static "ELECTRIC_MOTOR_UHV": $ItemEntry<($Item)>
static "ELECTRIC_MOTOR_UEV": $ItemEntry<($Item)>
static "ELECTRIC_MOTOR_UIV": $ItemEntry<($Item)>
static "ELECTRIC_MOTOR_UXV": $ItemEntry<($Item)>
static "ELECTRIC_MOTOR_OpV": $ItemEntry<($Item)>
static "ELECTRIC_PUMP_LV": $ItemEntry<($ComponentItem)>
static "ELECTRIC_PUMP_MV": $ItemEntry<($ComponentItem)>
static "ELECTRIC_PUMP_HV": $ItemEntry<($ComponentItem)>
static "ELECTRIC_PUMP_EV": $ItemEntry<($ComponentItem)>
static "ELECTRIC_PUMP_IV": $ItemEntry<($ComponentItem)>
static "ELECTRIC_PUMP_LuV": $ItemEntry<($ComponentItem)>
static "ELECTRIC_PUMP_ZPM": $ItemEntry<($ComponentItem)>
static "ELECTRIC_PUMP_UV": $ItemEntry<($ComponentItem)>
static "ELECTRIC_PUMP_UHV": $ItemEntry<($ComponentItem)>
static "ELECTRIC_PUMP_UEV": $ItemEntry<($ComponentItem)>
static "ELECTRIC_PUMP_UIV": $ItemEntry<($ComponentItem)>
static "ELECTRIC_PUMP_UXV": $ItemEntry<($ComponentItem)>
static "ELECTRIC_PUMP_OpV": $ItemEntry<($ComponentItem)>
static "FLUID_REGULATOR_LV": $ItemEntry<($ComponentItem)>
static "FLUID_REGULATOR_MV": $ItemEntry<($ComponentItem)>
static "FLUID_REGULATOR_HV": $ItemEntry<($ComponentItem)>
static "FLUID_REGULATOR_EV": $ItemEntry<($ComponentItem)>
static "FLUID_REGULATOR_IV": $ItemEntry<($ComponentItem)>
static "FLUID_REGULATOR_LUV": $ItemEntry<($ComponentItem)>
static "FLUID_REGULATOR_ZPM": $ItemEntry<($ComponentItem)>
static "FLUID_REGULATOR_UV": $ItemEntry<($ComponentItem)>
static "FLUID_REGULATOR_UHV": $ItemEntry<($ComponentItem)>
static "FLUID_REGULATOR_UEV": $ItemEntry<($ComponentItem)>
static "FLUID_REGULATOR_UIV": $ItemEntry<($ComponentItem)>
static "FLUID_REGULATOR_UXV": $ItemEntry<($ComponentItem)>
static "FLUID_REGULATOR_OpV": $ItemEntry<($ComponentItem)>
static "DYNAMITE": $ItemEntry<($ComponentItem)>
static "CONVEYOR_MODULE_LV": $ItemEntry<($ComponentItem)>
static "CONVEYOR_MODULE_MV": $ItemEntry<($ComponentItem)>
static "CONVEYOR_MODULE_HV": $ItemEntry<($ComponentItem)>
static "CONVEYOR_MODULE_EV": $ItemEntry<($ComponentItem)>
static "CONVEYOR_MODULE_IV": $ItemEntry<($ComponentItem)>
static "CONVEYOR_MODULE_LuV": $ItemEntry<($ComponentItem)>
static "CONVEYOR_MODULE_ZPM": $ItemEntry<($ComponentItem)>
static "CONVEYOR_MODULE_UV": $ItemEntry<($ComponentItem)>
static "CONVEYOR_MODULE_UHV": $ItemEntry<($ComponentItem)>
static "CONVEYOR_MODULE_UEV": $ItemEntry<($ComponentItem)>
static "CONVEYOR_MODULE_UIV": $ItemEntry<($ComponentItem)>
static "CONVEYOR_MODULE_UXV": $ItemEntry<($ComponentItem)>
static "CONVEYOR_MODULE_OpV": $ItemEntry<($ComponentItem)>
static "ELECTRIC_PISTON_LV": $ItemEntry<($Item)>
static "ELECTRIC_PISTON_MV": $ItemEntry<($Item)>
static "ELECTRIC_PISTON_HV": $ItemEntry<($Item)>
static "ELECTRIC_PISTON_EV": $ItemEntry<($Item)>
static "ELECTRIC_PISTON_IV": $ItemEntry<($Item)>
static "ELECTRIC_PISTON_LUV": $ItemEntry<($Item)>
static "ELECTRIC_PISTON_ZPM": $ItemEntry<($Item)>
static "ELECTRIC_PISTON_UV": $ItemEntry<($Item)>
static "ELECTRIC_PISTON_UHV": $ItemEntry<($Item)>
static "ELECTRIC_PISTON_UEV": $ItemEntry<($Item)>
static "ELECTRIC_PISTON_UIV": $ItemEntry<($Item)>
static "ELECTRIC_PISTON_UXV": $ItemEntry<($Item)>
static "ELECTRIC_PISTON_OpV": $ItemEntry<($Item)>
static "ROBOT_ARM_LV": $ItemEntry<($ComponentItem)>
static "ROBOT_ARM_MV": $ItemEntry<($ComponentItem)>
static "ROBOT_ARM_HV": $ItemEntry<($ComponentItem)>
static "ROBOT_ARM_EV": $ItemEntry<($ComponentItem)>
static "ROBOT_ARM_IV": $ItemEntry<($ComponentItem)>
static "ROBOT_ARM_LuV": $ItemEntry<($ComponentItem)>
static "ROBOT_ARM_ZPM": $ItemEntry<($ComponentItem)>
static "ROBOT_ARM_UV": $ItemEntry<($ComponentItem)>
static "ROBOT_ARM_UHV": $ItemEntry<($ComponentItem)>
static "ROBOT_ARM_UEV": $ItemEntry<($ComponentItem)>
static "ROBOT_ARM_UIV": $ItemEntry<($ComponentItem)>
static "ROBOT_ARM_UXV": $ItemEntry<($ComponentItem)>
static "ROBOT_ARM_OpV": $ItemEntry<($ComponentItem)>
static "FIELD_GENERATOR_LV": $ItemEntry<($Item)>
static "FIELD_GENERATOR_MV": $ItemEntry<($Item)>
static "FIELD_GENERATOR_HV": $ItemEntry<($Item)>
static "FIELD_GENERATOR_EV": $ItemEntry<($Item)>
static "FIELD_GENERATOR_IV": $ItemEntry<($Item)>
static "FIELD_GENERATOR_LuV": $ItemEntry<($Item)>
static "FIELD_GENERATOR_ZPM": $ItemEntry<($Item)>
static "FIELD_GENERATOR_UV": $ItemEntry<($Item)>
static "FIELD_GENERATOR_UHV": $ItemEntry<($Item)>
static "FIELD_GENERATOR_UEV": $ItemEntry<($Item)>
static "FIELD_GENERATOR_UIV": $ItemEntry<($Item)>
static "FIELD_GENERATOR_UXV": $ItemEntry<($Item)>
static "FIELD_GENERATOR_OpV": $ItemEntry<($Item)>
static "EMITTER_LV": $ItemEntry<($Item)>
static "EMITTER_MV": $ItemEntry<($Item)>
static "EMITTER_HV": $ItemEntry<($Item)>
static "EMITTER_EV": $ItemEntry<($Item)>
static "EMITTER_IV": $ItemEntry<($Item)>
static "EMITTER_LuV": $ItemEntry<($Item)>
static "EMITTER_ZPM": $ItemEntry<($Item)>
static "EMITTER_UV": $ItemEntry<($Item)>
static "EMITTER_UHV": $ItemEntry<($Item)>
static "EMITTER_UEV": $ItemEntry<($Item)>
static "EMITTER_UIV": $ItemEntry<($Item)>
static "EMITTER_UXV": $ItemEntry<($Item)>
static "EMITTER_OpV": $ItemEntry<($Item)>
static "SENSOR_LV": $ItemEntry<($Item)>
static "SENSOR_MV": $ItemEntry<($Item)>
static "SENSOR_HV": $ItemEntry<($Item)>
static "SENSOR_EV": $ItemEntry<($Item)>
static "SENSOR_IV": $ItemEntry<($Item)>
static "SENSOR_LuV": $ItemEntry<($Item)>
static "SENSOR_ZPM": $ItemEntry<($Item)>
static "SENSOR_UV": $ItemEntry<($Item)>
static "SENSOR_UHV": $ItemEntry<($Item)>
static "SENSOR_UEV": $ItemEntry<($Item)>
static "SENSOR_UIV": $ItemEntry<($Item)>
static "SENSOR_UXV": $ItemEntry<($Item)>
static "SENSOR_OpV": $ItemEntry<($Item)>
static "TOOL_DATA_STICK": $ItemEntry<($ComponentItem)>
static "TOOL_DATA_ORB": $ItemEntry<($ComponentItem)>
static "TOOL_DATA_MODULE": $ItemEntry<($ComponentItem)>
static readonly "GLASS_LENSES": $Map<($MarkerMaterial), ($ItemEntry<($Item)>)>
static "SILICON_BOULE": $ItemEntry<($Item)>
static "PHOSPHORUS_BOULE": $ItemEntry<($Item)>
static "NAQUADAH_BOULE": $ItemEntry<($Item)>
static "NEUTRONIUM_BOULE": $ItemEntry<($Item)>
static "SILICON_WAFER": $ItemEntry<($Item)>
static "PHOSPHORUS_WAFER": $ItemEntry<($Item)>
static "NAQUADAH_WAFER": $ItemEntry<($Item)>
static "NEUTRONIUM_WAFER": $ItemEntry<($Item)>
static "CENTRAL_PROCESSING_UNIT_WAFER": $ItemEntry<($Item)>
static "RANDOM_ACCESS_MEMORY_WAFER": $ItemEntry<($Item)>
static "INTEGRATED_LOGIC_CIRCUIT_WAFER": $ItemEntry<($Item)>
static "NANO_CENTRAL_PROCESSING_UNIT_WAFER": $ItemEntry<($Item)>
static "QUBIT_CENTRAL_PROCESSING_UNIT_WAFER": $ItemEntry<($Item)>
static "SIMPLE_SYSTEM_ON_CHIP_WAFER": $ItemEntry<($Item)>
static "SYSTEM_ON_CHIP_WAFER": $ItemEntry<($Item)>
static "ADVANCED_SYSTEM_ON_CHIP_WAFER": $ItemEntry<($Item)>
static "HIGHLY_ADVANCED_SOC_WAFER": $ItemEntry<($Item)>
static "NAND_MEMORY_CHIP_WAFER": $ItemEntry<($Item)>
static "NOR_MEMORY_CHIP_WAFER": $ItemEntry<($Item)>
static "ULTRA_LOW_POWER_INTEGRATED_CIRCUIT_WAFER": $ItemEntry<($Item)>
static "LOW_POWER_INTEGRATED_CIRCUIT_WAFER": $ItemEntry<($Item)>
static "POWER_INTEGRATED_CIRCUIT_WAFER": $ItemEntry<($Item)>
static "HIGH_POWER_INTEGRATED_CIRCUIT_WAFER": $ItemEntry<($Item)>
static "ULTRA_HIGH_POWER_INTEGRATED_CIRCUIT_WAFER": $ItemEntry<($Item)>
static "ENGRAVED_CRYSTAL_CHIP": $ItemEntry<($Item)>
static "ENGRAVED_LAPOTRON_CHIP": $ItemEntry<($Item)>
static "CENTRAL_PROCESSING_UNIT": $ItemEntry<($Item)>
static "RANDOM_ACCESS_MEMORY": $ItemEntry<($Item)>
static "INTEGRATED_LOGIC_CIRCUIT": $ItemEntry<($Item)>
static "NANO_CENTRAL_PROCESSING_UNIT": $ItemEntry<($Item)>
static "QUBIT_CENTRAL_PROCESSING_UNIT": $ItemEntry<($Item)>
static "SIMPLE_SYSTEM_ON_CHIP": $ItemEntry<($Item)>
static "SYSTEM_ON_CHIP": $ItemEntry<($Item)>
static "ADVANCED_SYSTEM_ON_CHIP": $ItemEntry<($Item)>
static "HIGHLY_ADVANCED_SOC": $ItemEntry<($Item)>
static "NAND_MEMORY_CHIP": $ItemEntry<($Item)>
static "NOR_MEMORY_CHIP": $ItemEntry<($Item)>
static "ULTRA_LOW_POWER_INTEGRATED_CIRCUIT": $ItemEntry<($Item)>
static "LOW_POWER_INTEGRATED_CIRCUIT": $ItemEntry<($Item)>
static "POWER_INTEGRATED_CIRCUIT": $ItemEntry<($Item)>
static "HIGH_POWER_INTEGRATED_CIRCUIT": $ItemEntry<($Item)>
static "ULTRA_HIGH_POWER_INTEGRATED_CIRCUIT": $ItemEntry<($Item)>
static "RAW_CRYSTAL_CHIP": $ItemEntry<($Item)>
static "RAW_CRYSTAL_CHIP_PART": $ItemEntry<($Item)>
static "CRYSTAL_CENTRAL_PROCESSING_UNIT": $ItemEntry<($Item)>
static "CRYSTAL_SYSTEM_ON_CHIP": $ItemEntry<($Item)>
static "COATED_BOARD": $ItemEntry<($Item)>
static "PHENOLIC_BOARD": $ItemEntry<($Item)>
static "PLASTIC_BOARD": $ItemEntry<($Item)>
static "EPOXY_BOARD": $ItemEntry<($Item)>
static "FIBER_BOARD": $ItemEntry<($Item)>
static "MULTILAYER_FIBER_BOARD": $ItemEntry<($Item)>
static "WETWARE_BOARD": $ItemEntry<($Item)>
static "BASIC_CIRCUIT_BOARD": $ItemEntry<($Item)>
static "GOOD_CIRCUIT_BOARD": $ItemEntry<($Item)>
static "PLASTIC_CIRCUIT_BOARD": $ItemEntry<($Item)>
static "ADVANCED_CIRCUIT_BOARD": $ItemEntry<($Item)>
static "EXTREME_CIRCUIT_BOARD": $ItemEntry<($Item)>
static "ELITE_CIRCUIT_BOARD": $ItemEntry<($Item)>
static "WETWARE_CIRCUIT_BOARD": $ItemEntry<($Item)>
static "VACUUM_TUBE": $ItemEntry<($Item)>
static "GLASS_TUBE": $ItemEntry<($Item)>
static "TRANSISTOR": $ItemEntry<($Item)>
static "RESISTOR": $ItemEntry<($Item)>
static "CAPACITOR": $ItemEntry<($Item)>
static "DIODE": $ItemEntry<($Item)>
static "INDUCTOR": $ItemEntry<($Item)>
static "SMD_TRANSISTOR": $ItemEntry<($Item)>
static "SMD_RESISTOR": $ItemEntry<($Item)>
static "SMD_CAPACITOR": $ItemEntry<($Item)>
static "SMD_DIODE": $ItemEntry<($Item)>
static "SMD_INDUCTOR": $ItemEntry<($Item)>
static "ADVANCED_SMD_TRANSISTOR": $ItemEntry<($Item)>
static "ADVANCED_SMD_RESISTOR": $ItemEntry<($Item)>
static "ADVANCED_SMD_CAPACITOR": $ItemEntry<($Item)>
static "ADVANCED_SMD_DIODE": $ItemEntry<($Item)>
static "ADVANCED_SMD_INDUCTOR": $ItemEntry<($Item)>
static "ELECTRONIC_CIRCUIT_LV": $ItemEntry<($Item)>
static "ELECTRONIC_CIRCUIT_MV": $ItemEntry<($Item)>
static "INTEGRATED_CIRCUIT_LV": $ItemEntry<($Item)>
static "INTEGRATED_CIRCUIT_MV": $ItemEntry<($Item)>
static "INTEGRATED_CIRCUIT_HV": $ItemEntry<($Item)>
static "NAND_CHIP_ULV": $ItemEntry<($Item)>
static "MICROPROCESSOR_LV": $ItemEntry<($Item)>
static "PROCESSOR_MV": $ItemEntry<($Item)>
static "PROCESSOR_ASSEMBLY_HV": $ItemEntry<($Item)>
static "WORKSTATION_EV": $ItemEntry<($Item)>
static "MAINFRAME_IV": $ItemEntry<($Item)>
static "NANO_PROCESSOR_HV": $ItemEntry<($Item)>
static "NANO_PROCESSOR_ASSEMBLY_EV": $ItemEntry<($Item)>
static "NANO_COMPUTER_IV": $ItemEntry<($Item)>
static "NANO_MAINFRAME_LUV": $ItemEntry<($Item)>
static "QUANTUM_PROCESSOR_EV": $ItemEntry<($Item)>
static "QUANTUM_ASSEMBLY_IV": $ItemEntry<($Item)>
static "QUANTUM_COMPUTER_LUV": $ItemEntry<($Item)>
static "QUANTUM_MAINFRAME_ZPM": $ItemEntry<($Item)>
static "CRYSTAL_PROCESSOR_IV": $ItemEntry<($Item)>
static "CRYSTAL_ASSEMBLY_LUV": $ItemEntry<($Item)>
static "CRYSTAL_COMPUTER_ZPM": $ItemEntry<($Item)>
static "CRYSTAL_MAINFRAME_UV": $ItemEntry<($Item)>
static "WETWARE_PROCESSOR_LUV": $ItemEntry<($Item)>
static "WETWARE_PROCESSOR_ASSEMBLY_ZPM": $ItemEntry<($Item)>
static "WETWARE_SUPER_COMPUTER_UV": $ItemEntry<($Item)>
static "WETWARE_MAINFRAME_UHV": $ItemEntry<($Item)>
static "COMPONENT_GRINDER_DIAMOND": $ItemEntry<($Item)>
static "COMPONENT_GRINDER_TUNGSTEN": $ItemEntry<($Item)>
static "IRON_MINECART_WHEELS": $ItemEntry<($Item)>
static "STEEL_MINECART_WHEELS": $ItemEntry<($Item)>
static "QUANTUM_EYE": $ItemEntry<($Item)>
static "QUANTUM_STAR": $ItemEntry<($Item)>
static "GRAVI_STAR": $ItemEntry<($Item)>
static "ITEM_FILTER": $ItemEntry<($ComponentItem)>
static "ORE_DICTIONARY_FILTER": $ItemEntry<($ComponentItem)>
static "FLUID_FILTER": $ItemEntry<($ComponentItem)>
static "TAG_FLUID_FILTER": $ItemEntry<($ComponentItem)>
static "COVER_MACHINE_CONTROLLER": $ItemEntry<($ComponentItem)>
static "COVER_ACTIVITY_DETECTOR": $ItemEntry<($ComponentItem)>
static "COVER_ACTIVITY_DETECTOR_ADVANCED": $ItemEntry<($ComponentItem)>
static "COVER_FLUID_DETECTOR": $ItemEntry<($ComponentItem)>
static "COVER_FLUID_DETECTOR_ADVANCED": $ItemEntry<($ComponentItem)>
static "COVER_ITEM_DETECTOR": $ItemEntry<($ComponentItem)>
static "COVER_ITEM_DETECTOR_ADVANCED": $ItemEntry<($ComponentItem)>
static "COVER_ENERGY_DETECTOR": $ItemEntry<($ComponentItem)>
static "COVER_ENERGY_DETECTOR_ADVANCED": $ItemEntry<($ComponentItem)>
static "COVER_MAINTENANCE_DETECTOR": $ItemEntry<($ComponentItem)>
static "COVER_SCREEN": $ItemEntry<($ComponentItem)>
static "COVER_CRAFTING": $ItemEntry<($ComponentItem)>
static "COVER_SHUTTER": $ItemEntry<($ComponentItem)>
static "COVER_INFINITE_WATER": $ItemEntry<($ComponentItem)>
static "COVER_ENDER_FLUID_LINK": $ItemEntry<($ComponentItem)>
static "COVER_DIGITAL_INTERFACE": $ItemEntry<($ComponentItem)>
static "COVER_DIGITAL_INTERFACE_WIRELESS": $ItemEntry<($ComponentItem)>
static "COVER_FLUID_VOIDING": $ItemEntry<($ComponentItem)>
static "COVER_FLUID_VOIDING_ADVANCED": $ItemEntry<($ComponentItem)>
static "COVER_ITEM_VOIDING": $ItemEntry<($ComponentItem)>
static "COVER_ITEM_VOIDING_ADVANCED": $ItemEntry<($ComponentItem)>
static "COVER_FACADE": $ItemEntry<($ComponentItem)>
static "COVER_SOLAR_PANEL": $ItemEntry<($ComponentItem)>
static "COVER_SOLAR_PANEL_ULV": $ItemEntry<($ComponentItem)>
static "COVER_SOLAR_PANEL_LV": $ItemEntry<($ComponentItem)>
static "COVER_SOLAR_PANEL_MV": $ItemEntry<($ComponentItem)>
static "COVER_SOLAR_PANEL_HV": $ItemEntry<($ComponentItem)>
static "COVER_SOLAR_PANEL_EV": $ItemEntry<($ComponentItem)>
static "COVER_SOLAR_PANEL_IV": $ItemEntry<($ComponentItem)>
static "COVER_SOLAR_PANEL_LUV": $ItemEntry<($ComponentItem)>
static "COVER_SOLAR_PANEL_ZPM": $ItemEntry<($ComponentItem)>
static "COVER_SOLAR_PANEL_UV": $ItemEntry<($ComponentItem)>
static "PLUGIN_TEXT": $ItemEntry<($Item)>
static "PLUGIN_ONLINE_PIC": $ItemEntry<($Item)>
static "PLUGIN_FAKE_GUI": $ItemEntry<($Item)>
static "PLUGIN_ADVANCED_MONITOR": $ItemEntry<($Item)>
static "INTEGRATED_CIRCUIT": $ItemEntry<($ComponentItem)>
static "GELLED_TOLUENE": $ItemEntry<($Item)>
static "BOTTLE_PURPLE_DRINK": $ItemEntry<($Item)>
static "PLANT_BALL": $ItemEntry<($ComponentItem)>
static "STICKY_RESIN": $ItemEntry<($ComponentItem)>
static "BIO_CHAFF": $ItemEntry<($ComponentItem)>
static "ENERGIUM_DUST": $ItemEntry<($Item)>
static "POWER_UNIT_LV": $ItemEntry<($ComponentItem)>
static "POWER_UNIT_MV": $ItemEntry<($ComponentItem)>
static "POWER_UNIT_HV": $ItemEntry<($ComponentItem)>
static "POWER_UNIT_EV": $ItemEntry<($ComponentItem)>
static "POWER_UNIT_IV": $ItemEntry<($ComponentItem)>
static "MASK_FILTER": $ItemEntry<($Item)>
static "PARACETAMOL_PILL": $ItemEntry<($ComponentItem)>
static "RAD_AWAY_PILL": $ItemEntry<($ComponentItem)>
static "NANO_SABER": $ItemEntry<($ComponentItem)>
static "PROSPECTOR_LV": $ItemEntry<($ComponentItem)>
static "PROSPECTOR_HV": $ItemEntry<($ComponentItem)>
static "PROSPECTOR_LUV": $ItemEntry<($ComponentItem)>
static "ITEM_MAGNET_LV": $ItemEntry<($ComponentItem)>
static "ITEM_MAGNET_HV": $ItemEntry<($ComponentItem)>
static "WIRELESS": $ItemEntry<($Item)>
static "CAMERA": $ItemEntry<($Item)>
static "TERMINAL": $ItemEntry<($ComponentItem)>
static readonly "DYE_ONLY_ITEMS": ($ItemEntry<($Item)>)[]
static readonly "SPRAY_CAN_DYES": ($ItemEntry<($ComponentItem)>)[]
static "TURBINE_ROTOR": $ItemEntry<($ComponentItem)>
static "NEURO_PROCESSOR": $ItemEntry<($Item)>
static "STEM_CELLS": $ItemEntry<($Item)>
static "PETRI_DISH": $ItemEntry<($Item)>
static "VOLTAGE_COIL_ULV": $ItemEntry<($ComponentItem)>
static "VOLTAGE_COIL_LV": $ItemEntry<($ComponentItem)>
static "VOLTAGE_COIL_MV": $ItemEntry<($ComponentItem)>
static "VOLTAGE_COIL_HV": $ItemEntry<($ComponentItem)>
static "VOLTAGE_COIL_EV": $ItemEntry<($ComponentItem)>
static "VOLTAGE_COIL_IV": $ItemEntry<($ComponentItem)>
static "VOLTAGE_COIL_LuV": $ItemEntry<($ComponentItem)>
static "VOLTAGE_COIL_ZPM": $ItemEntry<($ComponentItem)>
static "VOLTAGE_COIL_UV": $ItemEntry<($ComponentItem)>
static "CLIPBOARD": $ItemEntry<($Item)>
static "NIGHTVISION_GOGGLES": $ItemEntry<($ArmorComponentItem)>
static "NANO_CHESTPLATE": $ItemEntry<($ArmorComponentItem)>
static "NANO_LEGGINGS": $ItemEntry<($ArmorComponentItem)>
static "NANO_BOOTS": $ItemEntry<($ArmorComponentItem)>
static "NANO_HELMET": $ItemEntry<($ArmorComponentItem)>
static "FACE_MASK": $ItemEntry<($ArmorComponentItem)>
static "RUBBER_GLOVES": $ItemEntry<($ArmorComponentItem)>
static "HAZMAT_CHESTPLATE": $ItemEntry<($ArmorComponentItem)>
static "HAZMAT_LEGGINGS": $ItemEntry<($ArmorComponentItem)>
static "HAZMAT_BOOTS": $ItemEntry<($ArmorComponentItem)>
static "HAZMAT_HELMET": $ItemEntry<($ArmorComponentItem)>
static "QUANTUM_CHESTPLATE": $ItemEntry<($ArmorComponentItem)>
static "QUANTUM_LEGGINGS": $ItemEntry<($ArmorComponentItem)>
static "QUANTUM_BOOTS": $ItemEntry<($ArmorComponentItem)>
static "QUANTUM_HELMET": $ItemEntry<($ArmorComponentItem)>
static "LIQUID_FUEL_JETPACK": $ItemEntry<($ArmorComponentItem)>
static "ELECTRIC_JETPACK": $ItemEntry<($ArmorComponentItem)>
static "ELECTRIC_JETPACK_ADVANCED": $ItemEntry<($ArmorComponentItem)>
static "NANO_CHESTPLATE_ADVANCED": $ItemEntry<($ArmorComponentItem)>
static "QUANTUM_CHESTPLATE_ADVANCED": $ItemEntry<($ArmorComponentItem)>
static "POWER_THRUSTER": $ItemEntry<($Item)>
static "POWER_THRUSTER_ADVANCED": $ItemEntry<($Item)>
static "GRAVITATION_ENGINE": $ItemEntry<($Item)>
static "SUS_RECORD": $ItemEntry<($RecordItem)>
static "NAN_CERTIFICATE": $ItemEntry<($Item)>
static "FERTILIZER": $ItemEntry<($ComponentItem)>
static "BLACKLIGHT": $ItemEntry<($Item)>

constructor()

public static "init"(): void
public static "attach"<T extends $IComponentItem>(components: $IItemComponent$Type): $NonNullConsumer<(T)>
public static "attach"<T extends $IComponentItem>(...components: ($IItemComponent$Type)[]): $NonNullConsumer<(T)>
public static "burnTime"<T extends $ComponentItem>(burnTime: integer): $NonNullConsumer<(T)>
public static "materialInfo"<T extends $ItemLike>(materialInfo: $ItemMaterialInfo$Type): $NonNullConsumer<(T)>
public static "getTierName"(tier: $Tier$Type): $ResourceLocation
public static "generateMaterialItems"(): void
public static "cauldronInteraction"<T extends $Item>(item: T): void
public static "compassNode"<T extends $ItemLike>(section: $CompassSection$Type, ...preNodes: ($CompassNode$Type)[]): $NonNullConsumer<(T)>
public static "generateTools"(): void
public static "unificationItem"<P, T extends $Item, S2 extends $ItemBuilder<(T), (P)>>(tagPrefix: $TagPrefix$Type, mat: $Material$Type): $NonNullFunction<(S2), (S2)>
public static "cellName"(): $ICustomDescriptionId
public static "modelPredicate"<T extends $Item>(predicate: $ResourceLocation$Type, property: $Function$Type<($ItemStack$Type), (float)>): $NonNullConsumer<(T)>
public static "modelPredicate"<T extends $Item>(predicate: $ResourceLocation$Type, property: $Supplier$Type<($Supplier$Type<($ItemPropertyFunction$Type)>)>): $NonNullConsumer<(T)>
public static "registerToolTier"(tier: $MaterialToolTier$Type, id: $ResourceLocation$Type, before: $Collection$Type<($ResourceLocation$Type)>, after: $Collection$Type<($ResourceLocation$Type)>): void
public static "cellColor"(): $ItemColor
public static "compassNodeExist"<T extends $ItemLike>(section: $CompassSection$Type, node: string, ...preNodes: ($CompassNode$Type)[]): $NonNullConsumer<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTItems$Type = ($GTItems);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTItems_ = $GTItems$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/registry/registrate/$MachineBuilder" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$NonNullUnaryOperator, $NonNullUnaryOperator$Type} from "packages/com/tterrag/registrate/util/nullness/$NonNullUnaryOperator"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$NonNullConsumer, $NonNullConsumer$Type} from "packages/com/tterrag/registrate/util/nullness/$NonNullConsumer"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$MachineDefinition, $MachineDefinition$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MachineDefinition"
import {$CompassNode, $CompassNode$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$CompassNode"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Registrate, $Registrate$Type} from "packages/com/tterrag/registrate/$Registrate"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$TriFunction, $TriFunction$Type} from "packages/org/apache/commons/lang3/function/$TriFunction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BuilderBase, $BuilderBase$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$BuilderBase"
import {$IMachineBlockEntity, $IMachineBlockEntity$Type} from "packages/com/gregtechceu/gtceu/api/machine/$IMachineBlockEntity"
import {$MetaMachine, $MetaMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MetaMachine"
import {$RotationState, $RotationState$Type} from "packages/com/gregtechceu/gtceu/api/data/$RotationState"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IMachineBlock, $IMachineBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$IMachineBlock"
import {$CompassSection, $CompassSection$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$CompassSection"
import {$GTRecipeType, $GTRecipeType$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipeType"
import {$RecipeModifier, $RecipeModifier$Type} from "packages/com/gregtechceu/gtceu/api/recipe/modifier/$RecipeModifier"
import {$BlockBuilder, $BlockBuilder$Type} from "packages/com/tterrag/registrate/builders/$BlockBuilder"
import {$MetaMachineItem, $MetaMachineItem$Type} from "packages/com/gregtechceu/gtceu/api/item/$MetaMachineItem"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$IRenderer, $IRenderer$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IRenderer"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$GTRecipe, $GTRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$RecipeCapability, $RecipeCapability$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$RecipeCapability"
import {$ItemBuilder, $ItemBuilder$Type} from "packages/com/tterrag/registrate/builders/$ItemBuilder"
import {$PartAbility, $PartAbility$Type} from "packages/com/gregtechceu/gtceu/api/machine/multiblock/$PartAbility"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$IRecipeLogicMachine, $IRecipeLogicMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/$IRecipeLogicMachine"
import {$EditableMachineUI, $EditableMachineUI$Type} from "packages/com/gregtechceu/gtceu/api/gui/editor/$EditableMachineUI"
import {$Object2IntMap, $Object2IntMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntMap"

export class $MachineBuilder<DEFINITION extends $MachineDefinition> extends $BuilderBase<(DEFINITION)> {
 "id": $ResourceLocation


public "register"(): DEFINITION
public static "create"<DEFINITION extends $MachineDefinition>(registrate: $Registrate$Type, name: string, definitionFactory: $Function$Type<($ResourceLocation$Type), (DEFINITION)>, metaMachine: $Function$Type<($IMachineBlockEntity$Type), ($MetaMachine$Type)>, blockFactory: $BiFunction$Type<($BlockBehaviour$Properties$Type), (DEFINITION), ($IMachineBlock$Type)>, itemFactory: $BiFunction$Type<($IMachineBlock$Type), ($Item$Properties$Type), ($MetaMachineItem$Type)>, blockEntityFactory: $TriFunction$Type<($BlockEntityType$Type<(any)>), ($BlockPos$Type), ($BlockState$Type), ($IMachineBlockEntity$Type)>): $MachineBuilder<(DEFINITION)>
public "shape"(shape: $VoxelShape$Type): $MachineBuilder<(DEFINITION)>
public "renderer"(renderer: $Supplier$Type<($IRenderer$Type)>): $MachineBuilder<(DEFINITION)>
public "editableUI"(editableUI: $EditableMachineUI$Type): $MachineBuilder<(DEFINITION)>
public "blockProp"(blockProp: $NonNullUnaryOperator$Type<($BlockBehaviour$Properties$Type)>): $MachineBuilder<(DEFINITION)>
public "itemProp"(itemProp: $NonNullUnaryOperator$Type<($Item$Properties$Type)>): $MachineBuilder<(DEFINITION)>
public "hasTESR"(hasTESR: boolean): $MachineBuilder<(DEFINITION)>
public "recipeType"(type: $GTRecipeType$Type): $MachineBuilder<(DEFINITION)>
public "metaMachine"(metaMachine: $Function$Type<($IMachineBlockEntity$Type), ($MetaMachine$Type)>): $MachineBuilder<(DEFINITION)>
public "tooltips"(...components: ($Component$Type)[]): $MachineBuilder<(DEFINITION)>
public "recipeTypes"(...types: ($GTRecipeType$Type)[]): $MachineBuilder<(DEFINITION)>
public "tier"(): integer
public "tier"(tier: integer): $MachineBuilder<(DEFINITION)>
public "itemColor"(itemColor: $BiFunction$Type<($ItemStack$Type), (integer), (integer)>): $MachineBuilder<(DEFINITION)>
public "onBlockEntityRegister"(onBlockEntityRegister: $NonNullConsumer$Type<($BlockEntityType$Type<($BlockEntity$Type)>)>): $MachineBuilder<(DEFINITION)>
public "overlaySteamHullRenderer"(name: string): $MachineBuilder<(DEFINITION)>
public "overlayTieredHullRenderer"(name: string): $MachineBuilder<(DEFINITION)>
public "workableTieredHullRenderer"(workableModel: $ResourceLocation$Type): $MachineBuilder<(DEFINITION)>
public "defaultModelRenderer"(): $MachineBuilder<(DEFINITION)>
public "workableSteamHullRenderer"(isHighPressure: boolean, workableModel: $ResourceLocation$Type): $MachineBuilder<(DEFINITION)>
public "workableCasingRenderer"(baseCasing: $ResourceLocation$Type, workableModel: $ResourceLocation$Type): $MachineBuilder<(DEFINITION)>
public "workableCasingRenderer"(baseCasing: $ResourceLocation$Type, workableModel: $ResourceLocation$Type, tint: boolean): $MachineBuilder<(DEFINITION)>
public "recipeModifiers"(...recipeModifiers: ($RecipeModifier$Type)[]): $MachineBuilder<(DEFINITION)>
public "recipeModifiers"(alwaysTryModifyRecipe: boolean, ...recipeModifiers: ($RecipeModifier$Type)[]): $MachineBuilder<(DEFINITION)>
public "appearanceBlock"(block: $Supplier$Type<(any)>): $MachineBuilder<(DEFINITION)>
public "noRecipeModifier"(): $MachineBuilder<(DEFINITION)>
public "compassNodeSelf"(): $MachineBuilder<(DEFINITION)>
public "addOutputLimit"(capability: $RecipeCapability$Type<(any)>, limit: integer): $MachineBuilder<(DEFINITION)>
public "compassPreNodes"(section: $CompassSection$Type, ...compassNodes: (string)[]): $MachineBuilder<(DEFINITION)>
public "compassPreNodes"(...compassNodes: ($CompassNode$Type)[]): $MachineBuilder<(DEFINITION)>
public "compassPreNodes"(...compassNodes: ($ResourceLocation$Type)[]): $MachineBuilder<(DEFINITION)>
public "appearance"(appearance: $Supplier$Type<($BlockState$Type)>): $MachineBuilder<(DEFINITION)>
public "definitionFactory"(definitionFactory: $Function$Type<($ResourceLocation$Type), (DEFINITION)>): $MachineBuilder<(DEFINITION)>
public "blockBuilder"(blockBuilder: $Consumer$Type<($BlockBuilder$Type<(any), (any)>)>): $MachineBuilder<(DEFINITION)>
public "itemBuilder"(itemBuilder: $Consumer$Type<($ItemBuilder$Type<(any), (any)>)>): $MachineBuilder<(DEFINITION)>
public "modelRenderer"(model: $Supplier$Type<($ResourceLocation$Type)>): $MachineBuilder<(DEFINITION)>
public "alwaysTryModifyRecipe"(alwaysTryModifyRecipe: boolean): $MachineBuilder<(DEFINITION)>
public "onWorking"(onWorking: $Predicate$Type<($IRecipeLogicMachine$Type)>): $MachineBuilder<(DEFINITION)>
public "onWorking"(): $Predicate<($IRecipeLogicMachine)>
public "afterWorking"(): $Consumer<($IRecipeLogicMachine)>
public "afterWorking"(afterWorking: $Consumer$Type<($IRecipeLogicMachine$Type)>): $MachineBuilder<(DEFINITION)>
public "tooltipBuilder"(tooltipBuilder: $BiConsumer$Type<($ItemStack$Type), ($List$Type<($Component$Type)>)>): $MachineBuilder<(DEFINITION)>
public "recipeModifier"(recipeModifier: $RecipeModifier$Type): $MachineBuilder<(DEFINITION)>
public "recipeModifier"(recipeModifier: $RecipeModifier$Type, alwaysTryModifyRecipe: boolean): $MachineBuilder<(DEFINITION)>
public "onWaiting"(): $Consumer<($IRecipeLogicMachine)>
public "onWaiting"(onWaiting: $Consumer$Type<($IRecipeLogicMachine$Type)>): $MachineBuilder<(DEFINITION)>
public "beforeWorking"(): $BiPredicate<($IRecipeLogicMachine), ($GTRecipe)>
public "beforeWorking"(beforeWorking: $BiPredicate$Type<($IRecipeLogicMachine$Type), ($GTRecipe$Type)>): $MachineBuilder<(DEFINITION)>
public "recipeOutputLimits"(recipeOutputLimits: $Object2IntMap$Type<($RecipeCapability$Type<(any)>)>): $MachineBuilder<(DEFINITION)>
public "sidedWorkableCasingRenderer"(basePath: string, overlayModel: $ResourceLocation$Type): $MachineBuilder<(DEFINITION)>
public "sidedWorkableCasingRenderer"(basePath: string, overlayModel: $ResourceLocation$Type, tint: boolean): $MachineBuilder<(DEFINITION)>
public "rotationState"(rotationState: $RotationState$Type): $MachineBuilder<(DEFINITION)>
public "compassPage"(compassPage: $ResourceLocation$Type): $MachineBuilder<(DEFINITION)>
public "compassSections"(...sections: ($CompassSection$Type)[]): $MachineBuilder<(DEFINITION)>
public "langValue"(langValue: string): $MachineBuilder<(DEFINITION)>
public "abilities"(...abilities: ($PartAbility$Type)[]): $MachineBuilder<(DEFINITION)>
public "compassNode"(compassNode: string): $MachineBuilder<(DEFINITION)>
public "paintingColor"(paintingColor: integer): $MachineBuilder<(DEFINITION)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineBuilder$Type<DEFINITION> = ($MachineBuilder<(DEFINITION)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineBuilder_<DEFINITION> = $MachineBuilder$Type<(DEFINITION)>;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/$MultiblockMachineDefinition" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IMultiPart, $IMultiPart$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/multiblock/$IMultiPart"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IMultiController, $IMultiController$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/multiblock/$IMultiController"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$MachineDefinition, $MachineDefinition$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MachineDefinition"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TriFunction, $TriFunction$Type} from "packages/org/apache/commons/lang3/function/$TriFunction"
import {$MultiblockShapeInfo, $MultiblockShapeInfo$Type} from "packages/com/gregtechceu/gtceu/api/pattern/$MultiblockShapeInfo"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$BlockPattern, $BlockPattern$Type} from "packages/com/gregtechceu/gtceu/api/pattern/$BlockPattern"

export class $MultiblockMachineDefinition extends $MachineDefinition {


public "setAllowExtendedFacing"(allowExtendedFacing: boolean): void
public "setAdditionalDisplay"(additionalDisplay: $BiConsumer$Type<($IMultiController$Type), ($List$Type<($Component$Type)>)>): void
public static "createDefinition"(id: $ResourceLocation$Type): $MultiblockMachineDefinition
public "getShapes"(): $Supplier<($List<($MultiblockShapeInfo)>)>
public "setShapes"(shapes: $Supplier$Type<($List$Type<($MultiblockShapeInfo$Type)>)>): void
public "setAllowFlip"(allowFlip: boolean): void
public "setPartAppearance"(partAppearance: $TriFunction$Type<($IMultiController$Type), ($IMultiPart$Type), ($Direction$Type), ($BlockState$Type)>): void
public "setGenerator"(generator: boolean): void
public "setPartSorter"(partSorter: $Comparator$Type<($IMultiPart$Type)>): void
public "setRecoveryItems"(recoveryItems: $Supplier$Type<(($ItemStack$Type)[])>): void
public "setPatternFactory"(patternFactory: $Supplier$Type<($BlockPattern$Type)>): void
public "getMatchingShapes"(): $List<($MultiblockShapeInfo)>
public "isGenerator"(): boolean
public "isAllowExtendedFacing"(): boolean
public "getAdditionalDisplay"(): $BiConsumer<($IMultiController), ($List<($Component)>)>
public "isAllowFlip"(): boolean
public "getPartSorter"(): $Comparator<($IMultiPart)>
public "getPatternFactory"(): $Supplier<($BlockPattern)>
public "getRecoveryItems"(): $Supplier<(($ItemStack)[])>
public "getPartAppearance"(): $TriFunction<($IMultiController), ($IMultiPart), ($Direction), ($BlockState)>
set "allowExtendedFacing"(value: boolean)
set "additionalDisplay"(value: $BiConsumer$Type<($IMultiController$Type), ($List$Type<($Component$Type)>)>)
get "shapes"(): $Supplier<($List<($MultiblockShapeInfo)>)>
set "shapes"(value: $Supplier$Type<($List$Type<($MultiblockShapeInfo$Type)>)>)
set "allowFlip"(value: boolean)
set "partAppearance"(value: $TriFunction$Type<($IMultiController$Type), ($IMultiPart$Type), ($Direction$Type), ($BlockState$Type)>)
set "generator"(value: boolean)
set "partSorter"(value: $Comparator$Type<($IMultiPart$Type)>)
set "recoveryItems"(value: $Supplier$Type<(($ItemStack$Type)[])>)
set "patternFactory"(value: $Supplier$Type<($BlockPattern$Type)>)
get "matchingShapes"(): $List<($MultiblockShapeInfo)>
get "generator"(): boolean
get "allowExtendedFacing"(): boolean
get "additionalDisplay"(): $BiConsumer<($IMultiController), ($List<($Component)>)>
get "allowFlip"(): boolean
get "partSorter"(): $Comparator<($IMultiPart)>
get "patternFactory"(): $Supplier<($BlockPattern)>
get "recoveryItems"(): $Supplier<(($ItemStack)[])>
get "partAppearance"(): $TriFunction<($IMultiController), ($IMultiPart), ($Direction), ($BlockState)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiblockMachineDefinition$Type = ($MultiblockMachineDefinition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiblockMachineDefinition_ = $MultiblockMachineDefinition$Type;
}}
declare module "packages/com/gregtechceu/gtceu/core/mixins/$RecipeManagerInvoker" {
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $RecipeManagerInvoker {

 "getRecipeFromType"<C extends $Container, T extends $Recipe<(C)>>(arg0: $RecipeType$Type<(T)>): $Map<($ResourceLocation), ($Recipe<(C)>)>

(arg0: $RecipeType$Type<(T)>): $Map<($ResourceLocation), ($Recipe<(C)>)>
}

export namespace $RecipeManagerInvoker {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeManagerInvoker$Type = ($RecipeManagerInvoker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeManagerInvoker_ = $RecipeManagerInvoker$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/feature/$IFancyUIMachine" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Widget, $Widget$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$Widget"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$IUIMachine, $IUIMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/$IUIMachine"
import {$ConfiguratorPanel, $ConfiguratorPanel$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$ConfiguratorPanel"
import {$IFancyUIProvider, $IFancyUIProvider$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$IFancyUIProvider"
import {$IFancyUIProvider$PageGroupingData, $IFancyUIProvider$PageGroupingData$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$IFancyUIProvider$PageGroupingData"
import {$TabsWidget, $TabsWidget$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$TabsWidget"
import {$TooltipComponent, $TooltipComponent$Type} from "packages/net/minecraft/world/inventory/tooltip/$TooltipComponent"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ModularUI, $ModularUI$Type} from "packages/com/lowdragmc/lowdraglib/gui/modular/$ModularUI"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$MetaMachine, $MetaMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MetaMachine"
import {$FancyMachineUIWidget, $FancyMachineUIWidget$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$FancyMachineUIWidget"
import {$IGuiTexture, $IGuiTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$IGuiTexture"
import {$TooltipsPanel, $TooltipsPanel$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$TooltipsPanel"

export interface $IFancyUIMachine extends $IUIMachine, $IFancyUIProvider {

 "getTitle"(): $Component
 "createUI"(entityPlayer: $Player$Type): $ModularUI
 "createMainPage"(widget: $FancyMachineUIWidget$Type): $Widget
 "getTabTooltips"(): $List<($Component)>
 "attachTooltips"(tooltipsPanel: $TooltipsPanel$Type): void
 "attachSideTabs"(sideTabs: $TabsWidget$Type): void
 "getTabIcon"(): $IGuiTexture
 "createUIWidget"(): $Widget
 "attachConfigurators"(configuratorPanel: $ConfiguratorPanel$Type): void
 "isInvalid"(): boolean
 "markAsDirty"(): void
 "isRemote"(): boolean
 "shouldOpenUI"(player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): boolean
 "tryToOpenUI"(player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
 "hasPlayerInventory"(): boolean
 "getSubTabs"(): $List<($IFancyUIProvider)>
 "getTabTooltipComponent"(): $TooltipComponent
 "getPageGroupingData"(): $IFancyUIProvider$PageGroupingData
 "self"(): $MetaMachine
}

export namespace $IFancyUIMachine {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFancyUIMachine$Type = ($IFancyUIMachine);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFancyUIMachine_ = $IFancyUIMachine$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/gui/fancy/$IFancyUIProvider$PageGroupingData" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"

export class $IFancyUIProvider$PageGroupingData extends $Record {

constructor(groupKey: string, groupPositionWeight: integer)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "groupPositionWeight"(): integer
public "groupKey"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFancyUIProvider$PageGroupingData$Type = ($IFancyUIProvider$PageGroupingData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFancyUIProvider$PageGroupingData_ = $IFancyUIProvider$PageGroupingData$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/feature/multiblock/$IMultiController" {
import {$MultiblockState, $MultiblockState$Type} from "packages/com/gregtechceu/gtceu/api/pattern/$MultiblockState"
import {$IInteractedMachine, $IInteractedMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/$IInteractedMachine"
import {$IMachineFeature, $IMachineFeature$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/$IMachineFeature"
import {$IMultiPart, $IMultiPart$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/multiblock/$IMultiPart"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Lock, $Lock$Type} from "packages/java/util/concurrent/locks/$Lock"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPattern, $BlockPattern$Type} from "packages/com/gregtechceu/gtceu/api/pattern/$BlockPattern"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $IMultiController extends $IMachineFeature, $IInteractedMachine {

 "checkPattern"(): boolean
 "getPattern"(): $BlockPattern
 "getParts"(): $List<($IMultiPart)>
 "isFormed"(): boolean
 "onUse"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
 "getMultiblockState"(): $MultiblockState
 "asyncCheckPattern"(arg0: long): void
 "onStructureFormed"(): void
 "onStructureInvalid"(): void
 "getPatternLock"(): $Lock
 "getPartAppearance"(part: $IMultiPart$Type, side: $Direction$Type, sourceState: $BlockState$Type, sourcePos: $BlockPos$Type): $BlockState
 "hasFrontFacing"(): boolean
 "onPartUnload"(): void
 "checkPatternWithTryLock"(): boolean
 "checkPatternWithLock"(): boolean
 "shouldAddPartToController"(part: $IMultiPart$Type): boolean
 "onLeftClick"(player: $Player$Type, world: $Level$Type, hand: $InteractionHand$Type, pos: $BlockPos$Type, direction: $Direction$Type): boolean
}

export namespace $IMultiController {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMultiController$Type = ($IMultiController);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMultiController_ = $IMultiController$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/cover/$CoverBehavior" {
import {$ICoverable, $ICoverable$Type} from "packages/com/gregtechceu/gtceu/api/capability/$ICoverable"
import {$IFieldUpdateListener, $IFieldUpdateListener$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$IFieldUpdateListener"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CoverDefinition, $CoverDefinition$Type} from "packages/com/gregtechceu/gtceu/api/cover/$CoverDefinition"
import {$ResourceTexture, $ResourceTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$ResourceTexture"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IFluidTransfer, $IFluidTransfer$Type} from "packages/com/lowdragmc/lowdraglib/side/fluid/$IFluidTransfer"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$ICoverRenderer, $ICoverRenderer$Type} from "packages/com/gregtechceu/gtceu/client/renderer/cover/$ICoverRenderer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ISubscription, $ISubscription$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$ISubscription"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$IItemTransfer, $IItemTransfer$Type} from "packages/com/lowdragmc/lowdraglib/side/item/$IItemTransfer"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IRef, $IRef$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/managed/$IRef"
import {$ManagedFieldHolder, $ManagedFieldHolder$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/field/$ManagedFieldHolder"
import {$IToolGridHighLight, $IToolGridHighLight$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$IToolGridHighLight"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$IEnhancedManaged, $IEnhancedManaged$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$IEnhancedManaged"
import {$GTToolType, $GTToolType$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType"

export class $CoverBehavior implements $IEnhancedManaged, $IToolGridHighLight {
static readonly "MANAGED_FIELD_HOLDER": $ManagedFieldHolder
readonly "coverDefinition": $CoverDefinition
readonly "coverHolder": $ICoverable
readonly "attachedSide": $Direction

constructor(definition: $CoverDefinition$Type, coverHolder: $ICoverable$Type, attachedSide: $Direction$Type)

public "onLoad"(): void
public "getAppearance"(sourceState: $BlockState$Type, sourcePos: $BlockPos$Type): $BlockState
public "onNeighborChanged"(block: $Block$Type, fromPos: $BlockPos$Type, isMoving: boolean): void
public "onRemoved"(): void
public "canConnectRedstone"(): boolean
public "canAttach"(): boolean
public "onUnload"(): void
public "onChanged"(): void
public "onAttached"(itemStack: $ItemStack$Type, player: $ServerPlayer$Type): void
public "setRedstoneSignalOutput"(redstoneSignalOutput: integer): void
public "getCoverRenderer"(): $ICoverRenderer
public "getPickItem"(): $ItemStack
public "getAdditionalDrops"(): $List<($ItemStack)>
public "shouldRenderPlate"(): boolean
public "getAttachItem"(): $ItemStack
public "scheduleRenderUpdate"(): void
public "canPipePassThrough"(): boolean
public "getFieldHolder"(): $ManagedFieldHolder
public "onScrewdriverClick"(playerIn: $Player$Type, hand: $InteractionHand$Type, hitResult: $BlockHitResult$Type): $InteractionResult
public "onSoftMalletClick"(playerIn: $Player$Type, hand: $InteractionHand$Type, hitResult: $BlockHitResult$Type): $InteractionResult
public "shouldRenderGrid"(player: $Player$Type, held: $ItemStack$Type, toolTypes: $Set$Type<($GTToolType$Type)>): boolean
public "sideTips"(player: $Player$Type, toolTypes: $Set$Type<($GTToolType$Type)>, side: $Direction$Type): $ResourceTexture
public "getItemTransferCap"(defaultValue: $IItemTransfer$Type): $IItemTransfer
public "getRedstoneSignalOutput"(): integer
public "getFluidTransferCap"(defaultValue: $IFluidTransfer$Type): $IFluidTransfer
public "scheduleRender"(fieldName: string, newValue: any, oldValue: any): void
public "markDirty"(name: string): void
public "onPersistedChanged"(ref: $IRef$Type, isDirty: boolean): void
public "onSyncChanged"(ref: $IRef$Type, isDirty: boolean): void
public "addSyncUpdateListener"<T>(name: string, listener: $IFieldUpdateListener$Type<(T)>): $ISubscription
set "redstoneSignalOutput"(value: integer)
get "coverRenderer"(): $ICoverRenderer
get "pickItem"(): $ItemStack
get "additionalDrops"(): $List<($ItemStack)>
get "attachItem"(): $ItemStack
get "fieldHolder"(): $ManagedFieldHolder
get "redstoneSignalOutput"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoverBehavior$Type = ($CoverBehavior);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CoverBehavior_ = $CoverBehavior$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/$DimensionMarker" {
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $DimensionMarker {
static readonly "MAX_TIER": integer
readonly "tier": integer

constructor(tier: integer, resourceLocation: $ResourceLocation$Type, overrideName: string)
constructor(tier: integer, supplier: $Supplier$Type<(any)>, overrideName: string)

public "register"(id: $ResourceLocation$Type): void
public "getMarker"(): $ItemStack
public "getTier"(): integer
get "marker"(): $ItemStack
get "tier"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DimensionMarker$Type = ($DimensionMarker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DimensionMarker_ = $DimensionMarker$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pattern/$Predicates" {
import {$GTRecipeType, $GTRecipeType$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipeType"
import {$MultiblockState, $MultiblockState$Type} from "packages/com/gregtechceu/gtceu/api/pattern/$MultiblockState"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$PartAbility, $PartAbility$Type} from "packages/com/gregtechceu/gtceu/api/machine/multiblock/$PartAbility"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$BlockInfo, $BlockInfo$Type} from "packages/com/lowdragmc/lowdraglib/utils/$BlockInfo"
import {$TraceabilityPredicate, $TraceabilityPredicate$Type} from "packages/com/gregtechceu/gtceu/api/pattern/$TraceabilityPredicate"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$IMachineBlock, $IMachineBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$IMachineBlock"

export class $Predicates {

constructor()

public static "frames"(...frameMaterials: ($Material$Type)[]): $TraceabilityPredicate
public static "any"(): $TraceabilityPredicate
public static "states"(...allowedStates: ($BlockState$Type)[]): $TraceabilityPredicate
public static "blocks"(...blocks: ($IMachineBlock$Type)[]): $TraceabilityPredicate
public static "blocks"(...blocks: ($Block$Type)[]): $TraceabilityPredicate
public static "custom"(predicate: $Predicate$Type<($MultiblockState$Type)>, candidates: $Supplier$Type<(($BlockInfo$Type)[])>): $TraceabilityPredicate
public static "fluids"(...fluids: ($Fluid$Type)[]): $TraceabilityPredicate
public static "fluidTag"(tag: $TagKey$Type<($Fluid$Type)>): $TraceabilityPredicate
public static "blockTag"(tag: $TagKey$Type<($Block$Type)>): $TraceabilityPredicate
public static "controller"(predicate: $TraceabilityPredicate$Type): $TraceabilityPredicate
public static "air"(): $TraceabilityPredicate
public static "abilities"(...abilities: ($PartAbility$Type)[]): $TraceabilityPredicate
public static "powerSubstationBatteries"(): $TraceabilityPredicate
public static "cleanroomFilters"(): $TraceabilityPredicate
public static "ability"(ability: $PartAbility$Type, ...tiers: (integer)[]): $TraceabilityPredicate
public static "autoAbilities"(checkMaintenance: boolean, checkMuffler: boolean, checkParallel: boolean): $TraceabilityPredicate
public static "autoAbilities"(recipeType: ($GTRecipeType$Type)[], checkEnergyIn: boolean, checkEnergyOut: boolean, checkItemIn: boolean, checkItemOut: boolean, checkFluidIn: boolean, checkFluidOut: boolean): $TraceabilityPredicate
public static "autoAbilities"(...recipeType: ($GTRecipeType$Type)[]): $TraceabilityPredicate
public static "heatingCoils"(): $TraceabilityPredicate
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Predicates$Type = ($Predicates);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Predicates_ = $Predicates$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/ingredient/$FluidIngredient" {
import {$FluidStack, $FluidStack$Type} from "packages/com/lowdragmc/lowdraglib/side/fluid/$FluidStack"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$FluidIngredient$Value, $FluidIngredient$Value$Type} from "packages/com/gregtechceu/gtceu/api/recipe/ingredient/$FluidIngredient$Value"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export class $FluidIngredient implements $Predicate<($FluidStack)> {
static readonly "EMPTY": $FluidIngredient
 "values": ($FluidIngredient$Value)[]
 "stacks": ($FluidStack)[]

constructor(empty: $Stream$Type<(any)>, amount: long, nbt: $CompoundTag$Type)

public "equals"(obj: any): boolean
public "hashCode"(): integer
public "test"(stack: $FluidStack$Type): boolean
public "isEmpty"(): boolean
public static "of"(...stacks: ($FluidStack$Type)[]): $FluidIngredient
public static "of"(): $FluidIngredient
public static "of"(amount: long, ...items: ($Fluid$Type)[]): $FluidIngredient
public static "of"(tag: $TagKey$Type<($Fluid$Type)>, amount: long): $FluidIngredient
public static "of"(stacks: $Stream$Type<($Fluid$Type)>, amount: long, nbt: $CompoundTag$Type): $FluidIngredient
public static "of"(tag: $TagKey$Type<($Fluid$Type)>, amount: long, nbt: $CompoundTag$Type): $FluidIngredient
public "copy"(): $FluidIngredient
public static "fromValues"(stream: $Stream$Type<(any)>, amount: long, nbt: $CompoundTag$Type): $FluidIngredient
public static "fromJson"(json: $JsonElement$Type, allowAir: boolean): $FluidIngredient
public static "fromJson"(json: $JsonElement$Type): $FluidIngredient
public "toJson"(): $JsonElement
public "setAmount"(amount: long): void
public "getAmount"(): long
public static "fromNetwork"(buffer: $FriendlyByteBuf$Type): $FluidIngredient
public "toNetwork"(buffer: $FriendlyByteBuf$Type): void
public "setNbt"(nbt: $CompoundTag$Type): void
public "getNbt"(): $CompoundTag
public "getStacks"(): ($FluidStack)[]
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($FluidStack)>
public "negate"(): $Predicate<($FluidStack)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($FluidStack)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($FluidStack)>
public static "isEqual"<T>(arg0: any): $Predicate<($FluidStack)>
get "empty"(): boolean
set "amount"(value: long)
get "amount"(): long
set "nbt"(value: $CompoundTag$Type)
get "nbt"(): $CompoundTag
get "stacks"(): ($FluidStack)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidIngredient$Type = ($FluidIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidIngredient_ = $FluidIngredient$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/optical/$OpticalPipeProperties" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $OpticalPipeProperties {
static readonly "INSTANCE": $OpticalPipeProperties

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OpticalPipeProperties$Type = ($OpticalPipeProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OpticalPipeProperties_ = $OpticalPipeProperties$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/registry/$MaterialRegistry" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$GTRegistrate, $GTRegistrate$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$GTRegistrate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$GTRegistry$String, $GTRegistry$String$Type} from "packages/com/gregtechceu/gtceu/api/registry/$GTRegistry$String"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GTRegistry, $GTRegistry$Type} from "packages/com/gregtechceu/gtceu/api/registry/$GTRegistry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MaterialRegistry extends $GTRegistry$String<($Material)> {
static readonly "REGISTERED": $Map<($ResourceLocation), ($GTRegistry<(any), (any)>)>

constructor(modId: string)

public "register"(arg0: $Material$Type): void
public "getNetworkId"(): integer
public "getModid"(): string
public "getRegistrate"(): $GTRegistrate
public "getAllMaterials"(): $Collection<($Material)>
public "setFallbackMaterial"(arg0: $Material$Type): void
public "getFallbackMaterial"(): $Material
get "networkId"(): integer
get "modid"(): string
get "registrate"(): $GTRegistrate
get "allMaterials"(): $Collection<($Material)>
set "fallbackMaterial"(value: $Material$Type)
get "fallbackMaterial"(): $Material
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialRegistry$Type = ($MaterialRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialRegistry_ = $MaterialRegistry$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTLayerPattern$Layer$Builder" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$GTLayerPattern$Layer, $GTLayerPattern$Layer$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTLayerPattern$Layer"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $GTLayerPattern$Layer$Builder {


public "size"(min: integer, max: integer): $GTLayerPattern$Layer$Builder
public "state"(state: $BlockState$Type): $GTLayerPattern$Layer$Builder
public "state"(state: $Supplier$Type<(any)>): $GTLayerPattern$Layer$Builder
public "block"(block: $Supplier$Type<(any)>): $GTLayerPattern$Layer$Builder
public "build"(): $GTLayerPattern$Layer
public "mat"(material: $Material$Type): $GTLayerPattern$Layer$Builder
public "weight"(weight: integer): $GTLayerPattern$Layer$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTLayerPattern$Layer$Builder$Type = ($GTLayerPattern$Layer$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTLayerPattern$Layer$Builder_ = $GTLayerPattern$Layer$Builder$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/cover/filter/$FilterHandler" {
import {$ManagedFieldHolder, $ManagedFieldHolder$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/field/$ManagedFieldHolder"
import {$ISubscription, $ISubscription$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$ISubscription"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IFieldUpdateListener, $IFieldUpdateListener$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$IFieldUpdateListener"
import {$IEnhancedManaged, $IEnhancedManaged$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$IEnhancedManaged"
import {$Filter, $Filter$Type} from "packages/com/gregtechceu/gtceu/api/cover/filter/$Filter"
import {$Widget, $Widget$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$Widget"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IRef, $IRef$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/managed/$IRef"
import {$FieldManagedStorage, $FieldManagedStorage$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/field/$FieldManagedStorage"

export class $FilterHandler<T, F extends $Filter<(T), (F)>> implements $IEnhancedManaged {
static readonly "MANAGED_FIELD_HOLDER": $ManagedFieldHolder

constructor(container: $IEnhancedManaged$Type)

public "test"(resource: T): boolean
public "getFilter"(): F
public "getSyncStorage"(): $FieldManagedStorage
public "onChanged"(): void
public "getFilterItem"(): $ItemStack
public "onFilterUpdated"(onFilterUpdated: $Consumer$Type<(F)>): $FilterHandler<(T), (F)>
public "onFilterRemoved"(onFilterRemoved: $Consumer$Type<(F)>): $FilterHandler<(T), (F)>
public "onFilterLoaded"(onFilterLoaded: $Consumer$Type<(F)>): $FilterHandler<(T), (F)>
public "createFilterSlotUI"(xPos: integer, yPos: integer): $Widget
public "isFilterPresent"(): boolean
public "scheduleRenderUpdate"(): void
public "getFieldHolder"(): $ManagedFieldHolder
public "createFilterConfigUI"(xPos: integer, yPos: integer, width: integer, height: integer): $Widget
public "scheduleRender"(fieldName: string, newValue: any, oldValue: any): void
public "markDirty"(name: string): void
public "onPersistedChanged"(ref: $IRef$Type, isDirty: boolean): void
public "onSyncChanged"(ref: $IRef$Type, isDirty: boolean): void
public "addSyncUpdateListener"<T>(name: string, listener: $IFieldUpdateListener$Type<(T)>): $ISubscription
get "filter"(): F
get "syncStorage"(): $FieldManagedStorage
get "filterItem"(): $ItemStack
get "filterPresent"(): boolean
get "fieldHolder"(): $ManagedFieldHolder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilterHandler$Type<T, F> = ($FilterHandler<(T), (F)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilterHandler_<T, F> = $FilterHandler$Type<(T), (F)>;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/$OverclockingLogic" {
import {$OverclockingLogic$Logic, $OverclockingLogic$Logic$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$OverclockingLogic$Logic"
import {$LongIntPair, $LongIntPair$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIntPair"
import {$ImmutableTriple, $ImmutableTriple$Type} from "packages/org/apache/commons/lang3/tuple/$ImmutableTriple"

export class $OverclockingLogic {
static readonly "STANDARD_OVERCLOCK_VOLTAGE_MULTIPLIER": double
static readonly "STANDARD_OVERCLOCK_DURATION_DIVISOR": double
static readonly "PERFECT_OVERCLOCK_DURATION_DIVISOR": double
static readonly "PERFECT_OVERCLOCK": $OverclockingLogic
static readonly "NON_PERFECT_OVERCLOCK": $OverclockingLogic

constructor(logic: $OverclockingLogic$Logic$Type)
constructor(durationDivisor: double, voltageMultiplier: double)

public "getLogic"(): $OverclockingLogic$Logic
public static "standardOverclockingLogic"(recipeEUt: long, maxVoltage: long, recipeDuration: integer, numberOfOCs: integer, durationDivisor: double, voltageMultiplier: double): $LongIntPair
public static "heatingCoilOverclockingLogic"(recipeEUt: long, maximumVoltage: long, recipeDuration: integer, maxOverclocks: integer, currentTemp: integer, recipeRequiredTemp: integer): $LongIntPair
public static "standardOverclockingLogicWithSubTickParallelCount"(recipeEUt: long, maxVoltage: long, recipeDuration: integer, numberOfOCs: integer, durationDivisor: double, voltageMultiplier: double): $ImmutableTriple<(long), (integer), (integer)>
get "logic"(): $OverclockingLogic$Logic
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OverclockingLogic$Type = ($OverclockingLogic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OverclockingLogic_ = $OverclockingLogic$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/lookup/$GTRecipeLookup" {
import {$GTRecipeType, $GTRecipeType$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipeType"
import {$Branch, $Branch$Type} from "packages/com/gregtechceu/gtceu/api/recipe/lookup/$Branch"
import {$RecipeIterator, $RecipeIterator$Type} from "packages/com/gregtechceu/gtceu/api/recipe/lookup/$RecipeIterator"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$GTRecipe, $GTRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe"
import {$AbstractMapIngredient, $AbstractMapIngredient$Type} from "packages/com/gregtechceu/gtceu/api/recipe/lookup/$AbstractMapIngredient"
import {$IRecipeCapabilityHolder, $IRecipeCapabilityHolder$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IRecipeCapabilityHolder"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $GTRecipeLookup {

constructor(recipeType: $GTRecipeType$Type)

public "find"(holder: $IRecipeCapabilityHolder$Type, canHandle: $Predicate$Type<($GTRecipe$Type)>): $GTRecipe
public "getLookup"(): $Branch
public "findRecipe"(holder: $IRecipeCapabilityHolder$Type): $GTRecipe
public "getRecipeIterator"(holder: $IRecipeCapabilityHolder$Type, canHandle: $Predicate$Type<($GTRecipe$Type)>): $RecipeIterator
public static "uniqueItems"(inputs: $Collection$Type<($ItemStack$Type)>): ($ItemStack)[]
public "addRecipe"(recipe: $GTRecipe$Type): boolean
public "removeAllRecipes"(): void
public "recurseIngredientTreeFindRecipe"(ingredients: $List$Type<($List$Type<($AbstractMapIngredient$Type)>)>, branchMap: $Branch$Type, canHandle: $Predicate$Type<($GTRecipe$Type)>, index: integer, count: integer, skip: long): $GTRecipe
public "findRecipeCollisions"(holder: $IRecipeCapabilityHolder$Type): $Set<($GTRecipe)>
get "lookup"(): $Branch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTRecipeLookup$Type = ($GTRecipeLookup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTRecipeLookup_ = $GTRecipeLookup$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/laser/$LaserPipeProperties" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $LaserPipeProperties {
static readonly "INSTANCE": $LaserPipeProperties

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LaserPipeProperties$Type = ($LaserPipeProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LaserPipeProperties_ = $LaserPipeProperties$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/$RecipeCondition" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$GTRecipe, $GTRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe"
import {$RecipeLogic, $RecipeLogic$Type} from "packages/com/gregtechceu/gtceu/api/machine/trait/$RecipeLogic"
import {$IGuiTexture, $IGuiTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$IGuiTexture"

export class $RecipeCondition {

constructor()

public "test"(arg0: $GTRecipe$Type, arg1: $RecipeLogic$Type): boolean
public "getType"(): string
public static "create"(clazz: $Class$Type<(any)>): $RecipeCondition
public "deserialize"(config: $JsonObject$Type): $RecipeCondition
public "serialize"(): $JsonObject
public "getTranslationKey"(): string
public "fromNetwork"(buf: $FriendlyByteBuf$Type): $RecipeCondition
public "isReverse"(): boolean
public "toNetwork"(buf: $FriendlyByteBuf$Type): void
public "isOr"(): boolean
public "createTemplate"(): $RecipeCondition
public "getTooltips"(): $Component
public "setReverse"(reverse: boolean): $RecipeCondition
public "getInValidTexture"(): $IGuiTexture
public "getValidTexture"(): $IGuiTexture
get "type"(): string
get "translationKey"(): string
get "reverse"(): boolean
get "or"(): boolean
get "tooltips"(): $Component
set "reverse"(value: boolean)
get "inValidTexture"(): $IGuiTexture
get "validTexture"(): $IGuiTexture
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeCondition$Type = ($RecipeCondition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeCondition_ = $RecipeCondition$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/optical/$OpticalPipeNet" {
import {$PipeNet, $PipeNet$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$PipeNet"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$OpticalPipeProperties, $OpticalPipeProperties$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/optical/$OpticalPipeProperties"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$LevelPipeNet, $LevelPipeNet$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$LevelPipeNet"
import {$OpticalRoutePath, $OpticalRoutePath$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/optical/$OpticalRoutePath"

export class $OpticalPipeNet extends $PipeNet<($OpticalPipeProperties)> {

constructor(world: $LevelPipeNet$Type<($OpticalPipeProperties$Type), (any)>)

public "getNetData"(pipePos: $BlockPos$Type, facing: $Direction$Type): $OpticalRoutePath
public "onPipeConnectionsUpdate"(): void
public "onNeighbourUpdate"(fromPos: $BlockPos$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OpticalPipeNet$Type = ($OpticalPipeNet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OpticalPipeNet_ = $OpticalPipeNet$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/registry/registrate/$BuilderBase" {
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $BuilderBase<T> implements $Supplier<(T)> {
 "id": $ResourceLocation

constructor(id: $ResourceLocation$Type, ...args: (any)[])

public "get"(): T
public "register"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuilderBase$Type<T> = ($BuilderBase<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BuilderBase_<T> = $BuilderBase$Type<(T)>;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTLayerPattern$Layer" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$OreConfiguration$TargetBlockState, $OreConfiguration$TargetBlockState$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$OreConfiguration$TargetBlockState"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $GTLayerPattern$Layer {
static readonly "CODEC": $Codec<($GTLayerPattern$Layer)>
readonly "targets": $List<($Either<($List<($OreConfiguration$TargetBlockState)>), ($Material)>)>
readonly "minSize": integer
readonly "maxSize": integer
readonly "weight": integer

constructor(targets: $List$Type<($Either$Type<($List$Type<($OreConfiguration$TargetBlockState$Type)>), ($Material$Type)>)>, minSize: integer, maxSize: integer, weight: integer)

public "rollBlock"(random: $RandomSource$Type): $Either<($List<($OreConfiguration$TargetBlockState)>), ($Material)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTLayerPattern$Layer$Type = ($GTLayerPattern$Layer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTLayerPattern$Layer_ = $GTLayerPattern$Layer$Type;
}}
declare module "packages/com/gregtechceu/gtceu/integration/kjs/events/$MaterialModificationEventJS" {
import {$StartupEventJS, $StartupEventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$StartupEventJS"

export class $MaterialModificationEventJS extends $StartupEventJS {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialModificationEventJS$Type = ($MaterialModificationEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialModificationEventJS_ = $MaterialModificationEventJS$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/duct/$DuctNetHandler" {
import {$IHazardParticleContainer, $IHazardParticleContainer$Type} from "packages/com/gregtechceu/gtceu/api/capability/$IHazardParticleContainer"
import {$DuctPipeBlockEntity, $DuctPipeBlockEntity$Type} from "packages/com/gregtechceu/gtceu/common/blockentity/$DuctPipeBlockEntity"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$DuctPipeNet, $DuctPipeNet$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/duct/$DuctPipeNet"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$MedicalCondition, $MedicalCondition$Type} from "packages/com/gregtechceu/gtceu/api/data/medicalcondition/$MedicalCondition"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $DuctNetHandler implements $IHazardParticleContainer {

constructor(net: $DuctPipeNet$Type, pipe: $DuctPipeBlockEntity$Type, facing: $Direction$Type)

public "updateNetwork"(net: $DuctPipeNet$Type): void
public static "emitPollutionParticles"(level: $ServerLevel$Type, pos: $BlockPos$Type, frontFacing: $Direction$Type): void
public "getNet"(): $DuctPipeNet
public "inputsHazard"(side: $Direction$Type, condition: $MedicalCondition$Type): boolean
public "changeHazard"(condition: $MedicalCondition$Type, differenceAmount: float): float
public "outputsHazard"(side: $Direction$Type, condition: $MedicalCondition$Type): boolean
public "getHazardCapacity"(condition: $MedicalCondition$Type): float
public "getHazardStored"(condition: $MedicalCondition$Type): float
public "removeHazard"(condition: $MedicalCondition$Type, particlesToRemove: float): float
public "addHazard"(condition: $MedicalCondition$Type, particlesToAdd: float): float
public "getHazardCanBeInserted"(condition: $MedicalCondition$Type): float
get "net"(): $DuctPipeNet
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DuctNetHandler$Type = ($DuctNetHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DuctNetHandler_ = $DuctNetHandler$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/feature/$IInteractedMachine" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$IMachineFeature, $IMachineFeature$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/$IMachineFeature"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$MetaMachine, $MetaMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MetaMachine"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $IInteractedMachine extends $IMachineFeature {

 "onLeftClick"(player: $Player$Type, world: $Level$Type, hand: $InteractionHand$Type, pos: $BlockPos$Type, direction: $Direction$Type): boolean
 "onUse"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
 "self"(): $MetaMachine
}

export namespace $IInteractedMachine {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IInteractedMachine$Type = ($IInteractedMachine);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IInteractedMachine_ = $IInteractedMachine$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/fluidpipe/$LevelFluidPipeNet" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$FluidPipeNet, $FluidPipeNet$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/fluidpipe/$FluidPipeNet"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$LevelPipeNet, $LevelPipeNet$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$LevelPipeNet"
import {$FluidPipeProperties, $FluidPipeProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$FluidPipeProperties"

export class $LevelFluidPipeNet extends $LevelPipeNet<($FluidPipeProperties), ($FluidPipeNet)> {

constructor(serverLevel: $ServerLevel$Type, tag: $CompoundTag$Type)
constructor(serverLevel: $ServerLevel$Type)

public static "getOrCreate"(serverLevel: $ServerLevel$Type): $LevelFluidPipeNet
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelFluidPipeNet$Type = ($LevelFluidPipeNet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LevelFluidPipeNet_ = $LevelFluidPipeNet$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/tool/$GTSwordItem" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$FoodProperties, $FoodProperties$Type} from "packages/net/minecraft/world/food/$FoodProperties"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IGTTool, $IGTTool$Type} from "packages/com/gregtechceu/gtceu/api/item/$IGTTool"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$SwordItem, $SwordItem$Type} from "packages/net/minecraft/world/item/$SwordItem"
import {$DustProperty, $DustProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$DustProperty"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$IGTToolDefinition, $IGTToolDefinition$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$IGTToolDefinition"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$HeldItemUIFactory$HeldItemHolder, $HeldItemUIFactory$HeldItemHolder$Type} from "packages/com/lowdragmc/lowdraglib/gui/factory/$HeldItemUIFactory$HeldItemHolder"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$ItemColor, $ItemColor$Type} from "packages/net/minecraft/client/color/item/$ItemColor"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$GTToolType, $GTToolType$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$MaterialToolTier, $MaterialToolTier$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$MaterialToolTier"
import {$ModularUI, $ModularUI$Type} from "packages/com/lowdragmc/lowdraglib/gui/modular/$ModularUI"
import {$ToolProperty, $ToolProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$ToolProperty"
import {$SoundEntry, $SoundEntry$Type} from "packages/com/gregtechceu/gtceu/api/sound/$SoundEntry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GTSwordItem extends $SwordItem implements $IGTTool {
 "defaultModifiers": $Multimap<($Attribute), ($AttributeModifier)>
 "tier": $Tier
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "descriptionId": string
 "foodProperties": $FoodProperties
readonly "canRepair": boolean
 "renderProperties": any
 "moonlight$clientAnimationProvider": any


public static "create"(toolType: $GTToolType$Type, tier: $MaterialToolTier$Type, material: $Material$Type, toolStats: $IGTToolDefinition$Type, properties: $Item$Properties$Type): $GTSwordItem
public "getDamage"(stack: $ItemStack$Type): integer
public "appendHoverText"(stack: $ItemStack$Type, level: $Level$Type, tooltipComponents: $List$Type<($Component$Type)>, isAdvanced: $TooltipFlag$Type): void
public "getName"(stack: $ItemStack$Type): $Component
public "shouldCauseReequipAnimation"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type, slotChanged: boolean): boolean
public "isCorrectToolForDrops"(stack: $ItemStack$Type, state: $BlockState$Type): boolean
public "getCraftingRemainingItem"(itemStack: $ItemStack$Type): $ItemStack
public "hasCraftingRemainingItem"(stack: $ItemStack$Type): boolean
public "getAttributeModifiers"(slot: $EquipmentSlot$Type, stack: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "use"(level: $Level$Type, player: $Player$Type, usedHand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "useOn"(context: $UseOnContext$Type): $InteractionResult
public "getDestroySpeed"(stack: $ItemStack$Type, state: $BlockState$Type): float
public "hurtEnemy"(stack: $ItemStack$Type, target: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
public "getMaxDamage"(stack: $ItemStack$Type): integer
public "mineBlock"(stack: $ItemStack$Type, level: $Level$Type, state: $BlockState$Type, pos: $BlockPos$Type, miningEntity: $LivingEntity$Type): boolean
public "getDescription"(): $Component
public "hasCraftingRemainingItem"(): boolean
public "isValidRepairItem"(stack: $ItemStack$Type, repairCandidate: $ItemStack$Type): boolean
public "doesSneakBypassUse"(stack: $ItemStack$Type, level: $LevelReader$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "onItemUseFirst"(itemStack: $ItemStack$Type, context: $UseOnContext$Type): $InteractionResult
public "onBlockStartBreak"(stack: $ItemStack$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "isDamaged"(stack: $ItemStack$Type): boolean
public "setDamage"(stack: $ItemStack$Type, damage: integer): void
public "getSound"(): $SoundEntry
public "canDisableShield"(stack: $ItemStack$Type, shield: $ItemStack$Type, entity: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
public "getEnchantmentValue"(stack: $ItemStack$Type): integer
public "shouldCauseBlockBreakReset"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type): boolean
public "canApplyAtEnchantingTable"(stack: $ItemStack$Type, enchantment: $Enchantment$Type): boolean
public "getDescriptionId"(): string
public "getDefaultInstance"(): $ItemStack
public "initCapabilities"(stack: $ItemStack$Type, nbt: $CompoundTag$Type): $ICapabilityProvider
public "isElectric"(): boolean
public "getMaterial"(): $Material
public "playSoundOnBlockDestroy"(): boolean
public "getToolStats"(): $IGTToolDefinition
public "getElectricTier"(): integer
public "getToolType"(): $GTToolType
public "get"(defaultMaxCharge: long): $ItemStack
public "get"(): $ItemStack
public "get"(defaultCharge: long, defaultMaxCharge: long): $ItemStack
public "getRaw"(): $ItemStack
public "getColor"(stack: $ItemStack$Type, tintIndex: integer): integer
public "createUI"(entityPlayer: $Player$Type, holder: $HeldItemUIFactory$HeldItemHolder$Type): $ModularUI
public static "tintColor"(): $ItemColor
public "definition$canApplyAtEnchantingTable"(stack: $ItemStack$Type, enchantment: $Enchantment$Type): boolean
public "definition$shouldCauseReequipAnimation"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type, slotChanged: boolean): boolean
public "definition$getDefaultAttributeModifiers"(equipmentSlot: $EquipmentSlot$Type, stack: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "definition$shouldCauseBlockBreakReset"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type): boolean
public "definition$getCraftingRemainingItem"(stack: $ItemStack$Type): $ItemStack
public "definition$hasCraftingRemainingItem"(stack: $ItemStack$Type): boolean
public "definition$canDestroyBlockInCreative"(world: $Level$Type, pos: $BlockPos$Type, stack: $ItemStack$Type, player: $Player$Type): boolean
public "getCharge"(stack: $ItemStack$Type): long
public "playSound"(player: $Player$Type): void
public "asItem"(): $Item
public "definition$isDamaged"(stack: $ItemStack$Type): boolean
public "getToolMaterial"(stack: $ItemStack$Type): $Material
public "getMaxCharge"(stack: $ItemStack$Type): long
public "getToolClasses"(stack: $ItemStack$Type): $Set<($GTToolType)>
public "getTotalToolSpeed"(stack: $ItemStack$Type): float
public "getToolProperty"(stack: $ItemStack$Type): $ToolProperty
public "getDustProperty"(stack: $ItemStack$Type): $DustProperty
public "playCraftingSound"(player: $Player$Type, stack: $ItemStack$Type): void
public "definition$use"(world: $Level$Type, player: $Player$Type, hand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "definition$init"(): void
public "canPlaySound"(stack: $ItemStack$Type): boolean
public "getToolClassNames"(stack: $ItemStack$Type): $Set<(string)>
public "definition$getDestroySpeed"(stack: $ItemStack$Type, state: $BlockState$Type): float
public "getTotalAttackDamage"(stack: $ItemStack$Type): float
public "getTotalAttackSpeed"(stack: $ItemStack$Type): float
public "definition$hurtEnemy"(stack: $ItemStack$Type, target: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
public "getTotalHarvestLevel"(stack: $ItemStack$Type): integer
public "getMaterialAttackSpeed"(stack: $ItemStack$Type): float
public "definition$onBlockStartBreak"(stack: $ItemStack$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "definition$mineBlock"(stack: $ItemStack$Type, worldIn: $Level$Type, state: $BlockState$Type, pos: $BlockPos$Type, entityLiving: $LivingEntity$Type): boolean
public "definition$isValidRepairItem"(toRepair: $ItemStack$Type, repair: $ItemStack$Type): boolean
public "definition$getHarvestLevel"(stack: $ItemStack$Type, toolClass: $GTToolType$Type, player: $Player$Type, blockState: $BlockState$Type): integer
public "getMaterialAttackDamage"(stack: $ItemStack$Type): float
public "definition$canDisableShield"(stack: $ItemStack$Type, shield: $ItemStack$Type, entity: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
public "definition$doesSneakBypassUse"(stack: $ItemStack$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "getMaterialEnchantability"(stack: $ItemStack$Type): integer
public "definition$onEntitySwing"(entityLiving: $LivingEntity$Type, stack: $ItemStack$Type): boolean
public "getTotalEnchantability"(stack: $ItemStack$Type): integer
public "getMaterialDurability"(stack: $ItemStack$Type): integer
public "definition$getDamage"(stack: $ItemStack$Type): integer
public "getTotalMaxDurability"(stack: $ItemStack$Type): integer
public "getMaterialToolSpeed"(stack: $ItemStack$Type): float
public "getMaterialHarvestLevel"(stack: $ItemStack$Type): integer
public "definition$getMaxDamage"(stack: $ItemStack$Type): integer
public "definition$setDamage"(stack: $ItemStack$Type, durability: integer): void
public "definition$getDurabilityForDisplay"(stack: $ItemStack$Type): double
public "definition$onItemUse"(context: $UseOnContext$Type): $InteractionResult
public "setLastCraftingSoundTime"(stack: $ItemStack$Type): void
public "definition$initCapabilities"(stack: $ItemStack$Type, nbt: $CompoundTag$Type): $ICapabilityProvider
public "definition$appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "definition$shouldOpenUIAfterUse"(context: $UseOnContext$Type): boolean
public "definition$fillItemCategory"(category: $CreativeModeTab$Type, items: $NonNullList$Type<($ItemStack$Type)>): void
public "definition$onItemUseFirst"(stack: $ItemStack$Type, context: $UseOnContext$Type): $InteractionResult
public "definition$isCorrectToolForDrops"(stack: $ItemStack$Type, state: $BlockState$Type): boolean
get "description"(): $Component
get "sound"(): $SoundEntry
get "descriptionId"(): string
get "defaultInstance"(): $ItemStack
get "electric"(): boolean
get "material"(): $Material
get "toolStats"(): $IGTToolDefinition
get "electricTier"(): integer
get "toolType"(): $GTToolType
get "raw"(): $ItemStack
set "lastCraftingSoundTime"(value: $ItemStack$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTSwordItem$Type = ($GTSwordItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTSwordItem_ = $GTSwordItem$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/cable/$Insulation" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$IMaterialPipeType, $IMaterialPipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IMaterialPipeType"
import {$WireProperties, $WireProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$WireProperties"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$PipeModel, $PipeModel$Type} from "packages/com/gregtechceu/gtceu/client/model/$PipeModel"
import {$TagPrefix, $TagPrefix$Type} from "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $Insulation extends $Enum<($Insulation)> implements $IMaterialPipeType<($WireProperties)> {
static readonly "WIRE_SINGLE": $Insulation
static readonly "WIRE_DOUBLE": $Insulation
static readonly "WIRE_QUADRUPLE": $Insulation
static readonly "WIRE_OCTAL": $Insulation
static readonly "WIRE_HEX": $Insulation
static readonly "CABLE_SINGLE": $Insulation
static readonly "CABLE_DOUBLE": $Insulation
static readonly "CABLE_QUADRUPLE": $Insulation
static readonly "CABLE_OCTAL": $Insulation
static readonly "CABLE_HEX": $Insulation
static readonly "TYPE_ID": $ResourceLocation
readonly "name": string
readonly "thickness": float
readonly "amperage": integer
readonly "lossMultiplier": integer
readonly "tagPrefix": $TagPrefix
readonly "insulationLevel": integer
readonly "isCable": boolean


public "type"(): $ResourceLocation
public static "values"(): ($Insulation)[]
public static "valueOf"(name: string): $Insulation
public "getThickness"(): float
public "isCable"(): boolean
public "getTagPrefix"(): $TagPrefix
public "modifyProperties"(baseProperties: $WireProperties$Type): $WireProperties
public "isPaintable"(): boolean
public "createPipeModel"(material: $Material$Type): $PipeModel
get "thickness"(): float
get "cable"(): boolean
get "tagPrefix"(): $TagPrefix
get "paintable"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Insulation$Type = (("wire_single") | ("wire_octal") | ("cable_double") | ("cable_octal") | ("cable_hex") | ("cable_quadruple") | ("cable_single") | ("wire_double") | ("wire_quadruple") | ("wire_hex")) | ($Insulation);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Insulation_ = $Insulation$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/worldgen/feature/configurations/$StoneBlobConfiguration" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ConfiguredFeature, $ConfiguredFeature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$ConfiguredFeature"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$IntProvider, $IntProvider$Type} from "packages/net/minecraft/util/valueproviders/$IntProvider"
import {$OreConfiguration$TargetBlockState, $OreConfiguration$TargetBlockState$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$OreConfiguration$TargetBlockState"
import {$FeatureConfiguration, $FeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$FeatureConfiguration"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $StoneBlobConfiguration extends $Record implements $FeatureConfiguration {
static readonly "CODEC": $Codec<($StoneBlobConfiguration)>

constructor(state: $OreConfiguration$TargetBlockState$Type, size: $IntProvider$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "size"(): $IntProvider
public "state"(): $OreConfiguration$TargetBlockState
public "getFeatures"(): $Stream<($ConfiguredFeature<(any), (any)>)>
get "features"(): $Stream<($ConfiguredFeature<(any), (any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StoneBlobConfiguration$Type = ($StoneBlobConfiguration);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StoneBlobConfiguration_ = $StoneBlobConfiguration$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/$RubberLogBlock" {
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$RotatedPillarBlock, $RotatedPillarBlock$Type} from "packages/net/minecraft/world/level/block/$RotatedPillarBlock"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$Direction$Axis, $Direction$Axis$Type} from "packages/net/minecraft/core/$Direction$Axis"

export class $RubberLogBlock extends $RotatedPillarBlock {
static readonly "NATURAL": $BooleanProperty
static readonly "AXIS": $EnumProperty<($Direction$Axis)>
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type)

public "isNatural"(state: $BlockState$Type): boolean
public "changeNatural"(state: $BlockState$Type, natural: boolean): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RubberLogBlock$Type = ($RubberLogBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RubberLogBlock_ = $RubberLogBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material$MaterialInfo" {
import {$MaterialStack, $MaterialStack$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/stack/$MaterialStack"
import {$ImmutableList, $ImmutableList$Type} from "packages/com/google/common/collect/$ImmutableList"
import {$IntList, $IntList$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntList"
import {$Element, $Element$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/$Element"
import {$MaterialIconSet, $MaterialIconSet$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/info/$MaterialIconSet"

export class $Material$MaterialInfo {


public "getElement"(): $Element
public "setElement"(element: $Element$Type): $Material$MaterialInfo
public "setComponents"(...components: ($MaterialStack$Type)[]): $Material$MaterialInfo
public "getColors"(): $IntList
public "setColors"(colors: $IntList$Type): $Material$MaterialInfo
public "setIconSet"(iconSet: $MaterialIconSet$Type): $Material$MaterialInfo
public "getComponentList"(): $ImmutableList<($MaterialStack)>
public "setComponentList"(componentList: $ImmutableList$Type<($MaterialStack$Type)>): $Material$MaterialInfo
public "setHasFluidColor"(hasFluidColor: boolean): $Material$MaterialInfo
public "isHasFluidColor"(): boolean
public "getIconSet"(): $MaterialIconSet
get "element"(): $Element
set "element"(value: $Element$Type)
set "components"(value: ($MaterialStack$Type)[])
get "colors"(): $IntList
set "colors"(value: $IntList$Type)
set "iconSet"(value: $MaterialIconSet$Type)
get "componentList"(): $ImmutableList<($MaterialStack)>
set "componentList"(value: $ImmutableList$Type<($MaterialStack$Type)>)
set "hasFluidColor"(value: boolean)
get "hasFluidColor"(): boolean
get "iconSet"(): $MaterialIconSet
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Material$MaterialInfo$Type = ($Material$MaterialInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Material$MaterialInfo_ = $Material$MaterialInfo$Type;
}}
declare module "packages/com/gregtechceu/gtceu/integration/kjs/$GTRegistryInfo$BuilderFactory" {
import {$BuilderBase, $BuilderBase$Type} from "packages/com/gregtechceu/gtceu/api/registry/registrate/$BuilderBase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $GTRegistryInfo$BuilderFactory<T> {

 "createBuilder"(arg0: $ResourceLocation$Type, ...arg1: (any)[]): $BuilderBase<(any)>

(arg0: $ResourceLocation$Type, ...arg1: (any)[]): $BuilderBase<(any)>
}

export namespace $GTRegistryInfo$BuilderFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTRegistryInfo$BuilderFactory$Type<T> = ($GTRegistryInfo$BuilderFactory<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTRegistryInfo$BuilderFactory_<T> = $GTRegistryInfo$BuilderFactory$Type<(T)>;
}}
declare module "packages/com/gregtechceu/gtceu/api/block/$RendererGlassBlock" {
import {$RendererBlock, $RendererBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$RendererBlock"
import {$IRenderer, $IRenderer$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IRenderer"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $RendererGlassBlock extends $RendererBlock {
readonly "renderer": $IRenderer
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, renderer: $IRenderer$Type)

public "skipRendering"(state: $BlockState$Type, adjacentBlockState: $BlockState$Type, direction: $Direction$Type): boolean
public "getShadeBrightness"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type): float
public "getVisualShape"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type, context: $CollisionContext$Type): $VoxelShape
public "propagatesSkylightDown"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RendererGlassBlock$Type = ($RendererGlassBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RendererGlassBlock_ = $RendererGlassBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/indicators/$SurfaceIndicatorGenerator" {
import {$GTOreDefinition, $GTOreDefinition$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTOreDefinition"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$IntProvider, $IntProvider$Type} from "packages/net/minecraft/util/valueproviders/$IntProvider"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$SurfaceIndicatorGenerator$IndicatorPlacement, $SurfaceIndicatorGenerator$IndicatorPlacement$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/indicators/$SurfaceIndicatorGenerator$IndicatorPlacement"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$IndicatorGenerator, $IndicatorGenerator$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/$IndicatorGenerator"
import {$FloatProvider, $FloatProvider$Type} from "packages/net/minecraft/util/valueproviders/$FloatProvider"

export class $SurfaceIndicatorGenerator extends $IndicatorGenerator {
static readonly "CODEC": $Codec<($SurfaceIndicatorGenerator)>
static readonly "REGISTRY_CODEC": $Codec<($Codec<(any)>)>
static readonly "DIRECT_CODEC": $Codec<($IndicatorGenerator)>

constructor(entry: $GTOreDefinition$Type)
constructor(block: $Either$Type<($BlockState$Type), ($Material$Type)>, radius: $IntProvider$Type, density: $FloatProvider$Type, placement: $SurfaceIndicatorGenerator$IndicatorPlacement$Type)

public "state"(state: $BlockState$Type): $SurfaceIndicatorGenerator
public "block"(block: $Block$Type): $SurfaceIndicatorGenerator
public "codec"(): $Codec<(any)>
public "radius"(radius: integer): $SurfaceIndicatorGenerator
public "radius"(provider: $IntProvider$Type): $SurfaceIndicatorGenerator
public "density"(provider: $FloatProvider$Type): $SurfaceIndicatorGenerator
public "density"(density: float): $SurfaceIndicatorGenerator
public "placement"(placement: $SurfaceIndicatorGenerator$IndicatorPlacement$Type): $SurfaceIndicatorGenerator
public "surfaceRock"(material: $Material$Type): $SurfaceIndicatorGenerator
public "getSearchRadiusModifier"(veinRadius: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SurfaceIndicatorGenerator$Type = ($SurfaceIndicatorGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SurfaceIndicatorGenerator_ = $SurfaceIndicatorGenerator$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipeSerializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$GTRecipe, $GTRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$RecipeCapability, $RecipeCapability$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$RecipeCapability"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$Content, $Content$Type} from "packages/com/gregtechceu/gtceu/api/recipe/content/$Content"
import {$RecipeCondition, $RecipeCondition$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$RecipeCondition"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Tuple, $Tuple$Type} from "packages/net/minecraft/util/$Tuple"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $GTRecipeSerializer implements $RecipeSerializer<($GTRecipe)> {
static readonly "SERIALIZER": $GTRecipeSerializer

constructor()

public "fromJson"(id: $ResourceLocation$Type, json: $JsonObject$Type): $GTRecipe
public "fromNetwork"(id: $ResourceLocation$Type, buf: $FriendlyByteBuf$Type): $GTRecipe
public "toNetwork"(buf: $FriendlyByteBuf$Type, recipe: $GTRecipe$Type): void
public "capabilitiesFromJson"(json: $JsonObject$Type): $Map<($RecipeCapability<(any)>), ($List<($Content)>)>
public static "conditionReader"(buf: $FriendlyByteBuf$Type): $RecipeCondition
public static "entryWriter"(buf: $FriendlyByteBuf$Type, entry: $Map$Entry$Type<($RecipeCapability$Type<(any)>), (any)>): void
public static "conditionWriter"(buf: $FriendlyByteBuf$Type, condition: $RecipeCondition$Type): void
public static "tuplesToMap"(entries: $List$Type<($Tuple$Type<($RecipeCapability$Type<(any)>), ($List$Type<($Content$Type)>)>)>): $Map<($RecipeCapability<(any)>), ($List<($Content)>)>
public static "entryReader"(buf: $FriendlyByteBuf$Type): $Tuple<($RecipeCapability<(any)>), ($List<($Content)>)>
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $GTRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTRecipeSerializer$Type = ($GTRecipeSerializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTRecipeSerializer_ = $GTRecipeSerializer$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/optical/$OpticalPipeType" {
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$Type} from "packages/net/minecraft/util/$StringRepresentable$EnumCodec"
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$OpticalPipeProperties, $OpticalPipeProperties$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/optical/$OpticalPipeProperties"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IPipeType, $IPipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeType"

export class $OpticalPipeType extends $Enum<($OpticalPipeType)> implements $IPipeType<($OpticalPipeProperties)>, $StringRepresentable {
static readonly "NORMAL": $OpticalPipeType
static readonly "TYPE": $ResourceLocation


public "type"(): $ResourceLocation
public static "values"(): ($OpticalPipeType)[]
public static "valueOf"(name: string): $OpticalPipeType
public "getSerializedName"(): string
public "getThickness"(): float
public "modifyProperties"(baseProperties: $OpticalPipeProperties$Type): $OpticalPipeProperties
public "isPaintable"(): boolean
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>, arg1: $Function$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$Type)[]): $Keyable
get "serializedName"(): string
get "thickness"(): float
get "paintable"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OpticalPipeType$Type = (("normal")) | ($OpticalPipeType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OpticalPipeType_ = $OpticalPipeType$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/$IMaterialRegistryManager" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$MaterialRegistry, $MaterialRegistry$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/registry/$MaterialRegistry"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IMaterialRegistryManager$Phase, $IMaterialRegistryManager$Phase$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$IMaterialRegistryManager$Phase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export interface $IMaterialRegistryManager {

 "getKey"(arg0: $Material$Type): $ResourceLocation
 "getPhase"(): $IMaterialRegistryManager$Phase
 "codec"(): $Codec<($Material)>
 "getRegisteredMaterials"(): $Collection<($Material)>
 "getRegistry"(arg0: string): $MaterialRegistry
 "getRegistry"(arg0: integer): $MaterialRegistry
 "getRegistries"(): $Collection<($MaterialRegistry)>
 "createRegistry"(arg0: string): $MaterialRegistry
 "canModifyMaterials"(): boolean
 "getMaterial"(arg0: string): $Material
}

export namespace $IMaterialRegistryManager {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMaterialRegistryManager$Type = ($IMaterialRegistryManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMaterialRegistryManager_ = $IMaterialRegistryManager$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pipenet/longdistance/$LongDistanceNetwork$WorldData" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$SavedData, $SavedData$Type} from "packages/net/minecraft/world/level/saveddata/$SavedData"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$LongDistanceNetwork, $LongDistanceNetwork$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/longdistance/$LongDistanceNetwork"

export class $LongDistanceNetwork$WorldData extends $SavedData {

constructor()

public static "get"(level: $LevelAccessor$Type): $LongDistanceNetwork$WorldData
public static "load"(nbtTagCompound: $CompoundTag$Type, level: $ServerLevel$Type): $LongDistanceNetwork$WorldData
public static "create"(level: $ServerLevel$Type): $LongDistanceNetwork$WorldData
public "save"(nbtTagCompound: $CompoundTag$Type): $CompoundTag
public "getNetwork"(pos: $BlockPos$Type): $LongDistanceNetwork
public "getWorld"(): $LevelAccessor
get "world"(): $LevelAccessor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongDistanceNetwork$WorldData$Type = ($LongDistanceNetwork$WorldData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongDistanceNetwork$WorldData_ = $LongDistanceNetwork$WorldData$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/trait/$IRecipeHandlerTrait" {
import {$ISubscription, $ISubscription$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$ISubscription"
import {$IRecipeHandler, $IRecipeHandler$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IRecipeHandler"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$GTRecipe, $GTRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe"
import {$RecipeCapability, $RecipeCapability$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$RecipeCapability"
import {$IO, $IO$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IO"
import {$IRecipeCapabilityHolder, $IRecipeCapabilityHolder$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IRecipeCapabilityHolder"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export interface $IRecipeHandlerTrait<K> extends $IRecipeHandler<(K)> {

 "addChangedListener"(arg0: $Runnable$Type): $ISubscription
 "getHandlerIO"(): $IO
 "getSize"(): integer
 "getContents"(): $List<(any)>
 "isProxy"(): boolean
 "getCapability"(): $RecipeCapability<(K)>
 "handleRecipe"(io: $IO$Type, recipe: $GTRecipe$Type, left: $List$Type<(any)>, slotName: string, simulate: boolean): $List<(K)>
 "preWorking"(holder: $IRecipeCapabilityHolder$Type, io: $IO$Type, recipe: $GTRecipe$Type): void
 "postWorking"(holder: $IRecipeCapabilityHolder$Type, io: $IO$Type, recipe: $GTRecipe$Type): void
 "copyContent"(content: any): K
 "isDistinct"(): boolean
 "getTotalContentAmount"(): double
 "getSlotNames"(): $Set<(string)>
 "handleRecipeInner"(arg0: $IO$Type, arg1: $GTRecipe$Type, arg2: $List$Type<(K)>, arg3: string, arg4: boolean): $List<(K)>
 "test"(ingredient: K): boolean
 "getPriority"(): integer
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
 "negate"(): $Predicate<(K)>
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
}

export namespace $IRecipeHandlerTrait {
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
function isEqual<T>(arg0: any): $Predicate<(K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRecipeHandlerTrait$Type<K> = ($IRecipeHandlerTrait<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRecipeHandlerTrait_<K> = $IRecipeHandlerTrait$Type<(K)>;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$ClassicVeinGenerator" {
import {$GTOreDefinition, $GTOreDefinition$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTOreDefinition"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ClassicVeinGenerator$Layer$Builder, $ClassicVeinGenerator$Layer$Builder$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$ClassicVeinGenerator$Layer$Builder"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$RuleTest, $RuleTest$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$RuleTest"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ClassicVeinGenerator$Layer, $ClassicVeinGenerator$Layer$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$ClassicVeinGenerator$Layer"
import {$VeinGenerator, $VeinGenerator$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/$VeinGenerator"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $ClassicVeinGenerator extends $VeinGenerator {
static readonly "CODEC": $Codec<($ClassicVeinGenerator)>
static readonly "REGISTRY_CODEC": $Codec<($Codec<(any)>)>
static readonly "DIRECT_CODEC": $Codec<($VeinGenerator)>

constructor(entry: $GTOreDefinition$Type)
constructor(primary: $ClassicVeinGenerator$Layer$Type, secondary: $ClassicVeinGenerator$Layer$Type, between: $ClassicVeinGenerator$Layer$Type, sporadic: $ClassicVeinGenerator$Layer$Type, yRadius: integer)

public "copy"(): $VeinGenerator
public "between"(builder: $Consumer$Type<($ClassicVeinGenerator$Layer$Builder$Type)>): $ClassicVeinGenerator
public "rules"(rules: ($RuleTest$Type)[]): $ClassicVeinGenerator
public "primary"(builder: $Consumer$Type<($ClassicVeinGenerator$Layer$Builder$Type)>): $ClassicVeinGenerator
public "codec"(): $Codec<(any)>
public "getAllEntries"(): $List<($Map$Entry<($Either<($BlockState), ($Material)>), (integer)>)>
public "secondary"(builder: $Consumer$Type<($ClassicVeinGenerator$Layer$Builder$Type)>): $ClassicVeinGenerator
public "sporadic"(builder: $Consumer$Type<($ClassicVeinGenerator$Layer$Builder$Type)>): $ClassicVeinGenerator
get "allEntries"(): $List<($Map$Entry<($Either<($BlockState), ($Material)>), (integer)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassicVeinGenerator$Type = ($ClassicVeinGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassicVeinGenerator_ = $ClassicVeinGenerator$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/cover/data/$TransferMode" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$EnumSelectorWidget$SelectableEnum, $EnumSelectorWidget$SelectableEnum$Type} from "packages/com/gregtechceu/gtceu/api/gui/widget/$EnumSelectorWidget$SelectableEnum"
import {$IGuiTexture, $IGuiTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$IGuiTexture"

export class $TransferMode extends $Enum<($TransferMode)> implements $EnumSelectorWidget$SelectableEnum {
static readonly "TRANSFER_ANY": $TransferMode
static readonly "TRANSFER_EXACT": $TransferMode
static readonly "KEEP_EXACT": $TransferMode
readonly "tooltip": string
readonly "icon": $IGuiTexture
readonly "maxStackSize": integer


public static "values"(): ($TransferMode)[]
public static "valueOf"(name: string): $TransferMode
public "getIcon"(): $IGuiTexture
public "getTooltip"(): string
get "icon"(): $IGuiTexture
get "tooltip"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransferMode$Type = (("keep_exact") | ("transfer_exact") | ("transfer_any")) | ($TransferMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransferMode_ = $TransferMode$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/stack/$UnificationEntry" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$TagPrefix, $TagPrefix$Type} from "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix"

export class $UnificationEntry {
readonly "tagPrefix": $TagPrefix
readonly "material": $Material
static readonly "EmptyMapMarkerEntry": $UnificationEntry

constructor(tagPrefix: $TagPrefix$Type, material: $Material$Type)
constructor(tagPrefix: $TagPrefix$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnificationEntry$Type = ($UnificationEntry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnificationEntry_ = $UnificationEntry$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/capability/recipe/$IFilteredHandler" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"

export interface $IFilteredHandler<K> extends $Predicate<(K)> {

 "test"(ingredient: K): boolean
 "getPriority"(): integer
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
 "negate"(): $Predicate<(K)>
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
}

export namespace $IFilteredHandler {
const PRIORITY_COMPARATOR: $Comparator<($IFilteredHandler<(any)>)>
const HIGHEST: integer
const HIGH: integer
const NORMAL: integer
const LOW: integer
const LOWEST: integer
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
function isEqual<T>(arg0: any): $Predicate<(K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFilteredHandler$Type<K> = ($IFilteredHandler<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFilteredHandler_<K> = $IFilteredHandler$Type<(K)>;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/tool/$IGTToolDefinition" {
import {$AoESymmetrical, $AoESymmetrical$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/aoe/$AoESymmetrical"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$IToolBehavior, $IToolBehavior$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/behavior/$IToolBehavior"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Object2IntMap, $Object2IntMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntMap"

export interface $IGTToolDefinition {

 "isEnchantable"(stack: $ItemStack$Type): boolean
 "doesSneakBypassUse"(): boolean
 "getAoEDefinition"(stack: $ItemStack$Type): $AoESymmetrical
 "getAttackSpeed"(stack: $ItemStack$Type): float
 "canApplyEnchantment"(arg0: $ItemStack$Type, arg1: $Enchantment$Type): boolean
 "getDurabilityMultiplier"(stack: $ItemStack$Type): float
 "getBrokenStack"(): $ItemStack
 "isToolEffective"(arg0: $BlockState$Type): boolean
 "getBaseDamage"(stack: $ItemStack$Type): float
 "getBaseDurability"(stack: $ItemStack$Type): integer
 "getBaseQuality"(stack: $ItemStack$Type): integer
 "getDamagePerAction"(arg0: $ItemStack$Type): integer
 "getBaseEfficiency"(stack: $ItemStack$Type): float
 "getBehaviors"(): $List<($IToolBehavior)>
 "getEfficiencyMultiplier"(stack: $ItemStack$Type): float
 "getToolDamagePerAttack"(stack: $ItemStack$Type): integer
 "isSuitableForAttacking"(arg0: $ItemStack$Type): boolean
 "getDefaultEnchantments"(arg0: $ItemStack$Type): $Object2IntMap<($Enchantment)>
 "getToolDamagePerBlockBreak"(stack: $ItemStack$Type): integer
 "isSuitableForCrafting"(arg0: $ItemStack$Type): boolean
 "isSuitableForBlockBreak"(arg0: $ItemStack$Type): boolean
 "getToolDamagePerCraft"(stack: $ItemStack$Type): integer
 "getDamagePerCraftingAction"(arg0: $ItemStack$Type): integer
}

export namespace $IGTToolDefinition {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IGTToolDefinition$Type = ($IGTToolDefinition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IGTToolDefinition_ = $IGTToolDefinition$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pipenet/$IMaterialPipeType" {
import {$TagPrefix, $TagPrefix$Type} from "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IPipeType, $IPipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeType"

export interface $IMaterialPipeType<NodeDataType> extends $IPipeType<(NodeDataType)> {

 "getTagPrefix"(): $TagPrefix
 "type"(): $ResourceLocation
 "getThickness"(): float
 "modifyProperties"(arg0: NodeDataType): NodeDataType
 "isPaintable"(): boolean
}

export namespace $IMaterialPipeType {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMaterialPipeType$Type<NodeDataType> = ($IMaterialPipeType<(NodeDataType)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMaterialPipeType_<NodeDataType> = $IMaterialPipeType$Type<(NodeDataType)>;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/component/$IItemComponent" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"

export interface $IItemComponent {

 "onAttached"(item: $Item$Type): void
}

export namespace $IItemComponent {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IItemComponent$Type = ($IItemComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IItemComponent_ = $IItemComponent$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/block/$StoneTypes" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$Type} from "packages/net/minecraft/util/$StringRepresentable$EnumCodec"
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$MapColor, $MapColor$Type} from "packages/net/minecraft/world/level/material/$MapColor"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$TagPrefix, $TagPrefix$Type} from "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix"

export class $StoneTypes extends $Enum<($StoneTypes)> implements $StringRepresentable {
static readonly "STONE": $StoneTypes
static readonly "DEEPSLATE": $StoneTypes
static readonly "RED_GRANITE": $StoneTypes
static readonly "MARBLE": $StoneTypes
static readonly "ANDESITE": $StoneTypes
static readonly "GRANITE": $StoneTypes
static readonly "DIORITE": $StoneTypes
static readonly "BASALT": $StoneTypes
static readonly "CONCRETE_LIGHT": $StoneTypes
static readonly "CONCRETE_DARK": $StoneTypes
readonly "mapColor": $MapColor
readonly "natural": boolean
readonly "state": $Supplier<($Supplier<($BlockState)>)>
readonly "material": $Material
readonly "generateBlocks": boolean


public static "values"(): ($StoneTypes)[]
public static "valueOf"(name: string): $StoneTypes
public static "init"(): void
public "getState"(): $Supplier<($Supplier<($BlockState)>)>
public "getSerializedName"(): string
public "getMaterial"(): $Material
public "isNatural"(): boolean
public "getTagPrefix"(): $TagPrefix
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>, arg1: $Function$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$Type)[]): $Keyable
get "state"(): $Supplier<($Supplier<($BlockState)>)>
get "serializedName"(): string
get "material"(): $Material
get "natural"(): boolean
get "tagPrefix"(): $TagPrefix
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StoneTypes$Type = (("deepslate") | ("concrete_light") | ("marble") | ("basalt") | ("concrete_dark") | ("red_granite") | ("granite") | ("andesite") | ("stone") | ("diorite")) | ($StoneTypes);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StoneTypes_ = $StoneTypes$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$LayeredVeinGenerator" {
import {$GTOreDefinition, $GTOreDefinition$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTOreDefinition"
import {$GTLayerPattern$Builder, $GTLayerPattern$Builder$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTLayerPattern$Builder"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$GTLayerPattern, $GTLayerPattern$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTLayerPattern"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NonNullSupplier, $NonNullSupplier$Type} from "packages/com/tterrag/registrate/util/nullness/$NonNullSupplier"
import {$VeinGenerator, $VeinGenerator$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/$VeinGenerator"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $LayeredVeinGenerator extends $VeinGenerator {
static readonly "CODEC": $Codec<($LayeredVeinGenerator)>
 "layerPatterns": $List<($GTLayerPattern)>
static readonly "REGISTRY_CODEC": $Codec<($Codec<(any)>)>
static readonly "DIRECT_CODEC": $Codec<($VeinGenerator)>

constructor(entry: $GTOreDefinition$Type)
constructor(layerPatterns: $List$Type<($GTLayerPattern$Type)>)

public "copy"(): $VeinGenerator
public "codec"(): $Codec<(any)>
public "getAllEntries"(): $List<($Map$Entry<($Either<($BlockState), ($Material)>), (integer)>)>
public "buildLayerPattern"(config: $Consumer$Type<($GTLayerPattern$Builder$Type)>): $LayeredVeinGenerator
public "getLayerPatterns"(): $List<($GTLayerPattern)>
public "withLayerPattern"(pattern: $NonNullSupplier$Type<($GTLayerPattern$Type)>): $LayeredVeinGenerator
get "allEntries"(): $List<($Map$Entry<($Either<($BlockState), ($Material)>), (integer)>)>
get "layerPatterns"(): $List<($GTLayerPattern)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LayeredVeinGenerator$Type = ($LayeredVeinGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LayeredVeinGenerator_ = $LayeredVeinGenerator$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/cable/$EnergyRoutePath" {
import {$IEnergyContainer, $IEnergyContainer$Type} from "packages/com/gregtechceu/gtceu/api/capability/$IEnergyContainer"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$IRoutePath, $IRoutePath$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IRoutePath"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$CableBlockEntity, $CableBlockEntity$Type} from "packages/com/gregtechceu/gtceu/common/blockentity/$CableBlockEntity"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $EnergyRoutePath implements $IRoutePath<($IEnergyContainer)> {

constructor(targetPipePos: $BlockPos$Type, targetFacing: $Direction$Type, path: ($CableBlockEntity$Type)[], distance: integer, maxLoss: long)

public "getPath"(): ($CableBlockEntity)[]
public "getDistance"(): integer
public "getTargetPipePos"(): $BlockPos
public "getTargetFacing"(): $Direction
public "getMaxLoss"(): long
public "getTargetBlockEntity"(level: $Level$Type): $BlockEntity
public "getTargetCapability"<I>(capability: $Capability$Type<(I)>, level: $Level$Type): I
get "path"(): ($CableBlockEntity)[]
get "distance"(): integer
get "targetPipePos"(): $BlockPos
get "targetFacing"(): $Direction
get "maxLoss"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyRoutePath$Type = ($EnergyRoutePath);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyRoutePath_ = $EnergyRoutePath$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeType" {
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $IPipeType<NodeDataType> {

 "type"(): $ResourceLocation
 "getThickness"(): float
 "modifyProperties"(arg0: NodeDataType): NodeDataType
 "isPaintable"(): boolean
}

export namespace $IPipeType {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IPipeType$Type<NodeDataType> = ($IPipeType<(NodeDataType)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IPipeType_<NodeDataType> = $IPipeType$Type<(NodeDataType)>;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$Content, $Content$Type} from "packages/com/gregtechceu/gtceu/api/recipe/content/$Content"
import {$RecipeCondition, $RecipeCondition$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$RecipeCondition"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RecipeLogic, $RecipeLogic$Type} from "packages/com/gregtechceu/gtceu/api/machine/trait/$RecipeLogic"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$GTRecipeType, $GTRecipeType$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipeType"
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ContentModifier, $ContentModifier$Type} from "packages/com/gregtechceu/gtceu/api/recipe/content/$ContentModifier"
import {$RecipeCapability, $RecipeCapability$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$RecipeCapability"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IO, $IO$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IO"
import {$IRecipeCapabilityHolder, $IRecipeCapabilityHolder$Type} from "packages/com/gregtechceu/gtceu/api/capability/recipe/$IRecipeCapabilityHolder"
import {$GTRecipe$ActionResult, $GTRecipe$ActionResult$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe$ActionResult"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GTRecipe implements $Recipe<($Container)> {
readonly "recipeType": $GTRecipeType
readonly "id": $ResourceLocation
readonly "inputs": $Map<($RecipeCapability<(any)>), ($List<($Content)>)>
readonly "outputs": $Map<($RecipeCapability<(any)>), ($List<($Content)>)>
readonly "tickInputs": $Map<($RecipeCapability<(any)>), ($List<($Content)>)>
readonly "tickOutputs": $Map<($RecipeCapability<(any)>), ($List<($Content)>)>
readonly "conditions": $List<($RecipeCondition)>
readonly "ingredientActions": $List<(any)>
 "data": $CompoundTag
 "duration": integer
 "parallels": integer
 "isFuel": boolean

constructor(recipeType: $GTRecipeType$Type, id: $ResourceLocation$Type, inputs: $Map$Type<($RecipeCapability$Type<(any)>), ($List$Type<($Content$Type)>)>, outputs: $Map$Type<($RecipeCapability$Type<(any)>), ($List$Type<($Content$Type)>)>, tickInputs: $Map$Type<($RecipeCapability$Type<(any)>), ($List$Type<($Content$Type)>)>, tickOutputs: $Map$Type<($RecipeCapability$Type<(any)>), ($List$Type<($Content$Type)>)>, conditions: $List$Type<($RecipeCondition$Type)>, ingredientActions: $List$Type<(any)>, data: $CompoundTag$Type, duration: integer, isFuel: boolean)

public "equals"(obj: any): boolean
public "hashCode"(): integer
public "getType"(): $GTRecipeType
public "copy"(): $GTRecipe
public "copy"(modifier: $ContentModifier$Type): $GTRecipe
public "copy"(modifier: $ContentModifier$Type, modifyDuration: boolean): $GTRecipe
public "getId"(): $ResourceLocation
public "assemble"(inventory: $Container$Type, registryManager: $RegistryAccess$Type): $ItemStack
public "matches"(pContainer: $Container$Type, pLevel: $Level$Type): boolean
public "canCraftInDimensions"(pWidth: integer, pHeight: integer): boolean
public "getSerializer"(): $RecipeSerializer<(any)>
public "isFuel"(): boolean
public "copyContents"(contents: $Map$Type<($RecipeCapability$Type<(any)>), ($List$Type<($Content$Type)>)>, modifier: $ContentModifier$Type): $Map<($RecipeCapability<(any)>), ($List<($Content)>)>
public "handleRecipe"(io: $IO$Type, holder: $IRecipeCapabilityHolder$Type, contents: $Map$Type<($RecipeCapability$Type<(any)>), ($List$Type<($Content$Type)>)>): boolean
public "matchTickRecipe"(holder: $IRecipeCapabilityHolder$Type): $GTRecipe$ActionResult
public "handlePost"(contents: $Map$Type<($RecipeCapability$Type<(any)>), ($List$Type<($Content$Type)>)>, holder: $IRecipeCapabilityHolder$Type, io: $IO$Type): void
public "hasTick"(): boolean
public "getOutputContents"(capability: $RecipeCapability$Type<(any)>): $List<($Content)>
public "handleTickRecipeIO"(io: $IO$Type, holder: $IRecipeCapabilityHolder$Type): boolean
public "handlePre"(contents: $Map$Type<($RecipeCapability$Type<(any)>), ($List$Type<($Content$Type)>)>, holder: $IRecipeCapabilityHolder$Type, io: $IO$Type): void
public "getInputContents"(capability: $RecipeCapability$Type<(any)>): $List<($Content)>
public "matchRecipe"(holder: $IRecipeCapabilityHolder$Type): $GTRecipe$ActionResult
public "preWorking"(holder: $IRecipeCapabilityHolder$Type): void
public "handleRecipeIO"(io: $IO$Type, holder: $IRecipeCapabilityHolder$Type): boolean
public "postWorking"(holder: $IRecipeCapabilityHolder$Type): void
public "checkConditions"(recipeLogic: $RecipeLogic$Type): $GTRecipe$ActionResult
public "getResultItem"(registryManager: $RegistryAccess$Type): $ItemStack
public "trimRecipeOutputs"(trimLimits: $Map$Type<($RecipeCapability$Type<(any)>), (integer)>): $GTRecipe
public "checkRecipeValid"(): boolean
public "doTrim"(current: $Map$Type<($RecipeCapability$Type<(any)>), ($List$Type<($Content$Type)>)>, trimLimits: $Map$Type<($RecipeCapability$Type<(any)>), (integer)>): $Map<($RecipeCapability<(any)>), ($List<($Content)>)>
public "getTickOutputContents"(capability: $RecipeCapability$Type<(any)>): $List<($Content)>
public "matchRecipeContents"(io: $IO$Type, holder: $IRecipeCapabilityHolder$Type, contents: $Map$Type<($RecipeCapability$Type<(any)>), ($List$Type<($Content$Type)>)>): $GTRecipe$ActionResult
public "getTickInputContents"(capability: $RecipeCapability$Type<(any)>): $List<($Content)>
public "isSpecial"(): boolean
public "getIngredients"(): $NonNullList<($Ingredient)>
public "getToastSymbol"(): $ItemStack
public "showNotification"(): boolean
public "getRemainingItems"(arg0: $Container$Type): $NonNullList<($ItemStack)>
public "isIncomplete"(): boolean
public "getType"(): $ResourceLocation
public "getMod"(): string
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "getGroup"(): string
public "setGroup"(group: string): void
public "hasOutput"(match: $ReplacementMatch$Type): boolean
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "getOrCreateId"(): $ResourceLocation
public "getSchema"(): $RecipeSchema
public "hasInput"(match: $ReplacementMatch$Type): boolean
get "type"(): $GTRecipeType
get "id"(): $ResourceLocation
get "serializer"(): $RecipeSerializer<(any)>
get "fuel"(): boolean
get "special"(): boolean
get "ingredients"(): $NonNullList<($Ingredient)>
get "toastSymbol"(): $ItemStack
get "incomplete"(): boolean
get "type"(): $ResourceLocation
get "mod"(): string
get "group"(): string
set "group"(value: string)
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTRecipe$Type = ($GTRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTRecipe_ = $GTRecipe$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/info/$MaterialIconSet" {
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MaterialIconSet {
static readonly "ICON_SETS": $Map<(string), ($MaterialIconSet)>
static readonly "DULL": $MaterialIconSet
static readonly "METALLIC": $MaterialIconSet
static readonly "MAGNETIC": $MaterialIconSet
static readonly "SHINY": $MaterialIconSet
static readonly "BRIGHT": $MaterialIconSet
static readonly "DIAMOND": $MaterialIconSet
static readonly "EMERALD": $MaterialIconSet
static readonly "GEM_HORIZONTAL": $MaterialIconSet
static readonly "GEM_VERTICAL": $MaterialIconSet
static readonly "RUBY": $MaterialIconSet
static readonly "OPAL": $MaterialIconSet
static readonly "GLASS": $MaterialIconSet
static readonly "NETHERSTAR": $MaterialIconSet
static readonly "FINE": $MaterialIconSet
static readonly "SAND": $MaterialIconSet
static readonly "WOOD": $MaterialIconSet
static readonly "ROUGH": $MaterialIconSet
static readonly "FLINT": $MaterialIconSet
static readonly "LIGNITE": $MaterialIconSet
static readonly "QUARTZ": $MaterialIconSet
static readonly "CERTUS": $MaterialIconSet
static readonly "LAPIS": $MaterialIconSet
static readonly "FLUID": $MaterialIconSet
static readonly "RADIOACTIVE": $MaterialIconSet
readonly "name": string
readonly "id": integer
readonly "isRootIconset": boolean
readonly "parentIconset": $MaterialIconSet

constructor(name: string, parentIconset: $MaterialIconSet$Type, isRootIconset: boolean)
constructor(name: string, parentIconset: $MaterialIconSet$Type)
constructor(name: string)

public "toString"(): string
public static "init"(): void
public static "getByName"(name: string): $MaterialIconSet
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialIconSet$Type = ($MaterialIconSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaterialIconSet_ = $MaterialIconSet$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/machine/feature/$IUIMachine" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$IMachineFeature, $IMachineFeature$Type} from "packages/com/gregtechceu/gtceu/api/machine/feature/$IMachineFeature"
import {$IUIHolder, $IUIHolder$Type} from "packages/com/lowdragmc/lowdraglib/gui/modular/$IUIHolder"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$ModularUI, $ModularUI$Type} from "packages/com/lowdragmc/lowdraglib/gui/modular/$ModularUI"
import {$MetaMachine, $MetaMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MetaMachine"

export interface $IUIMachine extends $IUIHolder, $IMachineFeature {

 "isInvalid"(): boolean
 "markAsDirty"(): void
 "isRemote"(): boolean
 "shouldOpenUI"(player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): boolean
 "tryToOpenUI"(player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
 "createUI"(arg0: $Player$Type): $ModularUI
 "self"(): $MetaMachine

(): boolean
}

export namespace $IUIMachine {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IUIMachine$Type = ($IUIMachine);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IUIMachine_ = $IUIMachine$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/pipenet/longdistance/$LongDistancePipeBlock" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$LongDistanceNetwork, $LongDistanceNetwork$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/longdistance/$LongDistanceNetwork"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$ILDNetworkPart, $ILDNetworkPart$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/longdistance/$ILDNetworkPart"
import {$List, $List$Type} from "packages/java/util/$List"
import {$LongDistancePipeType, $LongDistancePipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/longdistance/$LongDistancePipeType"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $LongDistancePipeBlock extends $Block implements $ILDNetworkPart {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, pipeType: $LongDistancePipeType$Type)

public "destroy"(level: $LevelAccessor$Type, pos: $BlockPos$Type, state: $BlockState$Type): void
public "setPlacedBy"(level: $Level$Type, pos: $BlockPos$Type, state: $BlockState$Type, placer: $LivingEntity$Type, stack: $ItemStack$Type): void
public "getPipeType"(): $LongDistancePipeType
public "findNetworks"(level: $Level$Type, pos: $BlockPos$Type): $List<($LongDistanceNetwork)>
public static "tryGet"(world: $LevelAccessor$Type, pos: $BlockPos$Type): $ILDNetworkPart
public static "tryGet"(world: $LevelAccessor$Type, pos: $BlockPos$Type, blockState: $BlockState$Type): $ILDNetworkPart
get "pipeType"(): $LongDistancePipeType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongDistancePipeBlock$Type = ($LongDistancePipeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongDistancePipeBlock_ = $LongDistancePipeBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/duct/$LevelDuctPipeNet" {
import {$DuctPipeProperties, $DuctPipeProperties$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/duct/$DuctPipeProperties"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$DuctPipeNet, $DuctPipeNet$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/duct/$DuctPipeNet"
import {$LevelPipeNet, $LevelPipeNet$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$LevelPipeNet"

export class $LevelDuctPipeNet extends $LevelPipeNet<($DuctPipeProperties), ($DuctPipeNet)> {

constructor(serverLevel: $ServerLevel$Type, tag: $CompoundTag$Type)
constructor(serverLevel: $ServerLevel$Type)

public static "getOrCreate"(serverLevel: $ServerLevel$Type): $LevelDuctPipeNet
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelDuctPipeNet$Type = ($LevelDuctPipeNet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LevelDuctPipeNet_ = $LevelDuctPipeNet$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix$Conditions" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"

export class $TagPrefix$Conditions {
static readonly "hasToolProperty": $Predicate<($Material)>
static readonly "hasNoCraftingToolProperty": $Predicate<($Material)>
static readonly "hasOreProperty": $Predicate<($Material)>
static readonly "hasGemProperty": $Predicate<($Material)>
static readonly "hasDustProperty": $Predicate<($Material)>
static readonly "hasIngotProperty": $Predicate<($Material)>
static readonly "hasBlastProperty": $Predicate<($Material)>
static readonly "hasRotorProperty": $Predicate<($Material)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagPrefix$Conditions$Type = ($TagPrefix$Conditions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TagPrefix$Conditions_ = $TagPrefix$Conditions$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/recipe/content/$IContentSerializer" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Content, $Content$Type} from "packages/com/gregtechceu/gtceu/api/recipe/content/$Content"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"

export interface $IContentSerializer<T> {

 "of"(arg0: any): T
 "defaultValue"(): T
 "fromJson"(arg0: $JsonElement$Type): T
 "toJson"(arg0: T): $JsonElement
 "fromNetwork"(buf: $FriendlyByteBuf$Type): T
 "toNetwork"(buf: $FriendlyByteBuf$Type, content: T): void
 "fromJsonContent"(json: $JsonElement$Type): $Content
 "toJsonContent"(content: $Content$Type): $JsonElement
 "toNetworkContent"(buf: $FriendlyByteBuf$Type, content: $Content$Type): void
 "fromNetworkContent"(buf: $FriendlyByteBuf$Type): $Content
}

export namespace $IContentSerializer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IContentSerializer$Type<T> = ($IContentSerializer<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IContentSerializer_<T> = $IContentSerializer$Type<(T)>;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$OreProperty" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$IMaterialProperty, $IMaterialProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IMaterialProperty"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MaterialProperties, $MaterialProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$MaterialProperties"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"

export class $OreProperty implements $IMaterialProperty<($OreProperty)> {

constructor()
constructor(oreMultiplier: integer, byProductMultiplier: integer, emissive: boolean)
constructor(oreMultiplier: integer, byProductMultiplier: integer)

public "isEmissive"(): boolean
public "verifyProperty"(properties: $MaterialProperties$Type): void
public "setWashedIn"(washedIn: $Material$Type): void
public "setWashedIn"(m: $Material$Type, washedAmount: integer): void
public "setSeparatedInto"(...materials: ($Material$Type)[]): void
public "setOreByProducts"(...materials: ($Material$Type)[]): void
public "setDirectSmeltResult"(directSmeltResult: $Material$Type): void
public "getWashedIn"(): $Pair<($Material), (integer)>
public "getOreByProduct"(index: integer): $Material
public "getOreByProduct"(index: integer, fallback: $Material$Type): $Material
public "getOreByProducts"(): $List<($Material)>
public "getOreMultiplier"(): integer
public "setOreMultiplier"(oreMultiplier: integer): void
public "setEmissive"(emissive: boolean): void
public "getSeparatedInto"(): $List<($Material)>
public "getDirectSmeltResult"(): $Material
public "getByProductMultiplier"(): integer
public "setByProductMultiplier"(byProductMultiplier: integer): void
get "emissive"(): boolean
set "washedIn"(value: $Material$Type)
set "separatedInto"(value: ($Material$Type)[])
set "oreByProducts"(value: ($Material$Type)[])
set "directSmeltResult"(value: $Material$Type)
get "washedIn"(): $Pair<($Material), (integer)>
get "oreByProducts"(): $List<($Material)>
get "oreMultiplier"(): integer
set "oreMultiplier"(value: integer)
set "emissive"(value: boolean)
get "separatedInto"(): $List<($Material)>
get "directSmeltResult"(): $Material
get "byProductMultiplier"(): integer
set "byProductMultiplier"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OreProperty$Type = ($OreProperty);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OreProperty_ = $OreProperty$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/$IComponentItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"
import {$IItemComponent, $IItemComponent$Type} from "packages/com/gregtechceu/gtceu/api/item/component/$IItemComponent"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export interface $IComponentItem extends $ItemLike {

 "getCapability"<T>(itemStack: $ItemStack$Type, cap: $Capability$Type<(T)>): $LazyOptional<(T)>
 "getComponents"(): $List<($IItemComponent)>
 "fillItemCategory"(category: $CreativeModeTab$Type, items: $NonNullList$Type<($ItemStack$Type)>): void
 "attachComponents"(...arg0: ($IItemComponent$Type)[]): void
 "asItem"(): $Item
}

export namespace $IComponentItem {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IComponentItem$Type = ($IComponentItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IComponentItem_ = $IComponentItem$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$DikeVeinGenerator" {
import {$GTOreDefinition, $GTOreDefinition$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTOreDefinition"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$List, $List$Type} from "packages/java/util/$List"
import {$DikeVeinGenerator$DikeBlockDefinition, $DikeVeinGenerator$DikeBlockDefinition$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$DikeVeinGenerator$DikeBlockDefinition"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$VeinGenerator, $VeinGenerator$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/$VeinGenerator"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $DikeVeinGenerator extends $VeinGenerator {
static readonly "CODEC": $Codec<($DikeVeinGenerator)>
 "blocks": $List<($DikeVeinGenerator$DikeBlockDefinition)>
 "minYLevel": integer
 "maxYLevel": integer
static readonly "REGISTRY_CODEC": $Codec<($Codec<(any)>)>
static readonly "DIRECT_CODEC": $Codec<($VeinGenerator)>

constructor(entry: $GTOreDefinition$Type)
constructor(blocks: $List$Type<($DikeVeinGenerator$DikeBlockDefinition$Type)>, minYLevel: integer, maxYLevel: integer)

public "copy"(): $VeinGenerator
public "codec"(): $Codec<(any)>
public "getAllEntries"(): $List<($Map$Entry<($Either<($BlockState), ($Material)>), (integer)>)>
public "minYLevel"(minYLevel: integer): $DikeVeinGenerator
public "maxYLevel"(maxYLevel: integer): $DikeVeinGenerator
public "withBlock"(block: $Material$Type, weight: integer, minY: integer, maxY: integer): $DikeVeinGenerator
public "withBlock"(blockState: $BlockState$Type, weight: integer, minY: integer, maxY: integer): $DikeVeinGenerator
public "withBlock"(block: $DikeVeinGenerator$DikeBlockDefinition$Type): $DikeVeinGenerator
get "allEntries"(): $List<($Map$Entry<($Either<($BlockState), ($Material)>), (integer)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DikeVeinGenerator$Type = ($DikeVeinGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DikeVeinGenerator_ = $DikeVeinGenerator$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTLayerPattern" {
import {$GTLayerPattern$Layer, $GTLayerPattern$Layer$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTLayerPattern$Layer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RuleTest, $RuleTest$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$RuleTest"
import {$GTLayerPattern$Builder, $GTLayerPattern$Builder$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/$GTLayerPattern$Builder"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $GTLayerPattern {
static readonly "CODEC": $Codec<($GTLayerPattern)>
readonly "layers": $List<($GTLayerPattern$Layer)>

constructor(layers: $List$Type<($GTLayerPattern$Layer$Type)>)

public static "builder"(...rules: ($RuleTest$Type)[]): $GTLayerPattern$Builder
public "rollNext"(previous: $GTLayerPattern$Layer$Type, random: $RandomSource$Type): $GTLayerPattern$Layer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTLayerPattern$Type = ($GTLayerPattern);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTLayerPattern_ = $GTLayerPattern$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/block/$AppearanceBlock" {
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IAppearance, $IAppearance$Type} from "packages/com/gregtechceu/gtceu/api/block/$IAppearance"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export class $AppearanceBlock extends $Block implements $IAppearance {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type)

public "getAppearance"(state: $BlockState$Type, level: $BlockAndTintGetter$Type, pos: $BlockPos$Type, side: $Direction$Type, queryState: $BlockState$Type, queryPos: $BlockPos$Type): $BlockState
public "getBlockAppearance"(state: $BlockState$Type, level: $BlockAndTintGetter$Type, pos: $BlockPos$Type, side: $Direction$Type, sourceState: $BlockState$Type, sourcePos: $BlockPos$Type): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AppearanceBlock$Type = ($AppearanceBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AppearanceBlock_ = $AppearanceBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$ClassicVeinGenerator$Layer$Builder" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$ClassicVeinGenerator$Layer, $ClassicVeinGenerator$Layer$Type} from "packages/com/gregtechceu/gtceu/api/data/worldgen/generator/veins/$ClassicVeinGenerator$Layer"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $ClassicVeinGenerator$Layer$Builder {


public "size"(size: integer): $ClassicVeinGenerator$Layer$Builder
public "state"(state: $BlockState$Type): $ClassicVeinGenerator$Layer$Builder
public "state"(state: $Supplier$Type<(any)>): $ClassicVeinGenerator$Layer$Builder
public "block"(block: $Supplier$Type<(any)>): $ClassicVeinGenerator$Layer$Builder
public "build"(): $ClassicVeinGenerator$Layer
public "mat"(material: $Material$Type): $ClassicVeinGenerator$Layer$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassicVeinGenerator$Layer$Builder$Type = ($ClassicVeinGenerator$Layer$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassicVeinGenerator$Layer$Builder_ = $ClassicVeinGenerator$Layer$Builder$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/capability/$IDataAccessHatch" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$GTRecipe, $GTRecipe$Type} from "packages/com/gregtechceu/gtceu/api/recipe/$GTRecipe"

export interface $IDataAccessHatch {

 "isCreative"(): boolean
 "isRecipeAvailable"(recipe: $GTRecipe$Type): boolean
 "isRecipeAvailable"(arg0: $GTRecipe$Type, arg1: $Collection$Type<($IDataAccessHatch$Type)>): boolean
 "modifyRecipe"(recipe: $GTRecipe$Type): $GTRecipe
}

export namespace $IDataAccessHatch {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IDataAccessHatch$Type = ($IDataAccessHatch);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IDataAccessHatch_ = $IDataAccessHatch$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/effect/$GTPoisonEffect" {
import {$MobEffectCategory, $MobEffectCategory$Type} from "packages/net/minecraft/world/effect/$MobEffectCategory"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $GTPoisonEffect extends $MobEffect {

constructor(category: $MobEffectCategory$Type, color: integer)

public "isDurationEffectTick"(duration: integer, amplifier: integer): boolean
public "applyEffectTick"(livingEntity: $LivingEntity$Type, amplifier: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTPoisonEffect$Type = ($GTPoisonEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTPoisonEffect_ = $GTPoisonEffect$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/block/$MetaMachineBlock" {
import {$AppearanceBlock, $AppearanceBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$AppearanceBlock"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$MachineDefinition, $MachineDefinition$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MachineDefinition"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$MetaMachine, $MetaMachine$Type} from "packages/com/gregtechceu/gtceu/api/machine/$MetaMachine"
import {$RotationState, $RotationState$Type} from "packages/com/gregtechceu/gtceu/api/data/$RotationState"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$IMachineBlock, $IMachineBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$IMachineBlock"
import {$IRenderer, $IRenderer$Type} from "packages/com/lowdragmc/lowdraglib/client/renderer/$IRenderer"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$StateDefinition, $StateDefinition$Type} from "packages/net/minecraft/world/level/block/state/$StateDefinition"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$LootParams$Builder, $LootParams$Builder$Type} from "packages/net/minecraft/world/level/storage/loot/$LootParams$Builder"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export class $MetaMachineBlock extends $AppearanceBlock implements $IMachineBlock {
readonly "definition": $MachineDefinition
readonly "rotationState": $RotationState
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
 "descriptionId": string
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "isRandomlyTicking": boolean
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
readonly "requiredFeatures": $FeatureFlagSet
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(properties: $BlockBehaviour$Properties$Type, definition: $MachineDefinition$Type)

public "getDefinition"(): $MachineDefinition
public "getStateForPlacement"(context: $BlockPlaceContext$Type): $BlockState
public "getCloneItemStack"(level: $BlockGetter$Type, pos: $BlockPos$Type, state: $BlockState$Type): $ItemStack
public "setPlacedBy"(pLevel: $Level$Type, pPos: $BlockPos$Type, pState: $BlockState$Type, player: $LivingEntity$Type, pStack: $ItemStack$Type): void
public "appendHoverText"(stack: $ItemStack$Type, level: $BlockGetter$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "canConnectRedstone"(level: $BlockGetter$Type, pos: $BlockPos$Type, side: $Direction$Type): boolean
public "neighborChanged"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, block: $Block$Type, fromPos: $BlockPos$Type, isMoving: boolean): void
public "onPlace"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, oldState: $BlockState$Type, movedByPiston: boolean): void
public "triggerEvent"(pState: $BlockState$Type, pLevel: $Level$Type, pPos: $BlockPos$Type, pId: integer, pParam: integer): boolean
public "use"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
public "onRemove"(pState: $BlockState$Type, pLevel: $Level$Type, pPos: $BlockPos$Type, pNewState: $BlockState$Type, pIsMoving: boolean): void
public "rotate"(pState: $BlockState$Type, pRotation: $Rotation$Type): $BlockState
public "getDrops"(state: $BlockState$Type, builder: $LootParams$Builder$Type): $List<($ItemStack)>
public "getShape"(pState: $BlockState$Type, pLevel: $BlockGetter$Type, pPos: $BlockPos$Type, pContext: $CollisionContext$Type): $VoxelShape
public "getAnalogOutputSignal"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type): integer
public "getDirectSignal"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type, direction: $Direction$Type): integer
public "getSignal"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type, direction: $Direction$Type): integer
public "getRenderer"(state: $BlockState$Type): $IRenderer
public "getRotationState"(): $RotationState
public "animateTick"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, random: $RandomSource$Type): void
public "getMachine"(level: $BlockGetter$Type, pos: $BlockPos$Type): $MetaMachine
public "getBlockAppearance"(state: $BlockState$Type, level: $BlockAndTintGetter$Type, pos: $BlockPos$Type, side: $Direction$Type, sourceState: $BlockState$Type, sourcePos: $BlockPos$Type): $BlockState
public "getFrontFacing"(state: $BlockState$Type): $Direction
public "self"(): $Block
public "getTicker"<T extends $BlockEntity>(level: $Level$Type, state: $BlockState$Type, blockEntityType: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(pos: $BlockPos$Type, state: $BlockState$Type): $BlockEntity
public static "colorTinted"(blockState: $BlockState$Type, level: $BlockAndTintGetter$Type, pos: $BlockPos$Type, index: integer): integer
public "getLightMap"(world: $BlockAndTintGetter$Type, state: $BlockState$Type, pos: $BlockPos$Type): integer
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
get "definition"(): $MachineDefinition
get "rotationState"(): $RotationState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MetaMachineBlock$Type = ($MetaMachineBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MetaMachineBlock_ = $MetaMachineBlock$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix$BlockProperties" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$RenderType, $RenderType$Type} from "packages/net/minecraft/client/renderer/$RenderType"

export class $TagPrefix$BlockProperties extends $Record {

constructor(renderType: $Supplier$Type<($Supplier$Type<($RenderType$Type)>)>, properties: $UnaryOperator$Type<($BlockBehaviour$Properties$Type)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "properties"(): $UnaryOperator<($BlockBehaviour$Properties)>
public "renderType"(): $Supplier<($Supplier<($RenderType)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagPrefix$BlockProperties$Type = ($TagPrefix$BlockProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TagPrefix$BlockProperties_ = $TagPrefix$BlockProperties$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/block/$IFusionCasingType" {
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$Type} from "packages/net/minecraft/util/$StringRepresentable$EnumCodec"
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $IFusionCasingType extends $StringRepresentable {

 "getTexture"(): $ResourceLocation
 "getHarvestLevel"(): integer
 "getSerializedName"(): string
}

export namespace $IFusionCasingType {
function fromEnum<E>(arg0: $Supplier$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
function fromEnumWithMapping<E>(arg0: $Supplier$Type<((E)[])>, arg1: $Function$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
function keys(arg0: ($StringRepresentable$Type)[]): $Keyable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFusionCasingType$Type = ($IFusionCasingType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFusionCasingType_ = $IFusionCasingType$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/registry/registrate/$SoundEntryBuilder" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$SoundEntry, $SoundEntry$Type} from "packages/com/gregtechceu/gtceu/api/sound/$SoundEntry"
import {$SoundSource, $SoundSource$Type} from "packages/net/minecraft/sounds/$SoundSource"

export class $SoundEntryBuilder {

constructor(id: $ResourceLocation$Type)

public "build"(): $SoundEntry
public "category"(category: $SoundSource$Type): $SoundEntryBuilder
public "attenuationDistance"(distance: integer): $SoundEntryBuilder
public "subtitle"(subtitle: string): $SoundEntryBuilder
public "addVariant"(id: $ResourceLocation$Type): $SoundEntryBuilder
public "addVariant"(name: string): $SoundEntryBuilder
public "noSubtitle"(): $SoundEntryBuilder
public "playExisting"(event: $SoundEvent$Type, volume: float, pitch: float): $SoundEntryBuilder
public "playExisting"(event: $SoundEvent$Type): $SoundEntryBuilder
public "playExisting"(event: $Supplier$Type<($SoundEvent$Type)>, volume: float, pitch: float): $SoundEntryBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundEntryBuilder$Type = ($SoundEntryBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SoundEntryBuilder_ = $SoundEntryBuilder$Type;
}}
declare module "packages/com/gregtechceu/gtceu/$GTCEu" {
import {$Logger, $Logger$Type} from "packages/org/slf4j/$Logger"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $GTCEu {
static readonly "MOD_ID": string
static readonly "NAME": string
static readonly "LOGGER": $Logger

constructor()

public static "id"(path: string): $ResourceLocation
public static "init"(): void
public static "appendIdString"(id: string): string
public static "isKubeJSLoaded"(): boolean
public static "appendId"(id: string): $ResourceLocation
public static "isAE2Loaded"(): boolean
public static "isShimmerLoaded"(): boolean
public static "isIrisOculusLoaded"(): boolean
public static "isCreateLoaded"(): boolean
/**
 * 
 * @deprecated
 */
public static "isHighTier"(): boolean
public static "isAlmostUnifiedLoaded"(): boolean
public static "isSodiumRubidiumEmbeddiumLoaded"(): boolean
public static "isRebornEnergyLoaded"(): boolean
get "kubeJSLoaded"(): boolean
get "aE2Loaded"(): boolean
get "shimmerLoaded"(): boolean
get "irisOculusLoaded"(): boolean
get "createLoaded"(): boolean
get "highTier"(): boolean
get "almostUnifiedLoaded"(): boolean
get "sodiumRubidiumEmbeddiumLoaded"(): boolean
get "rebornEnergyLoaded"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GTCEu$Type = ($GTCEu);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GTCEu_ = $GTCEu$Type;
}}
declare module "packages/com/gregtechceu/gtceu/utils/$SupplierMemoizer$MemoizedSupplier" {
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $SupplierMemoizer$MemoizedSupplier<T> implements $Supplier<(T)> {


public "get"(): T
public "toString"(): string
public "forget"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SupplierMemoizer$MemoizedSupplier$Type<T> = ($SupplierMemoizer$MemoizedSupplier<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SupplierMemoizer$MemoizedSupplier_<T> = $SupplierMemoizer$MemoizedSupplier$Type<(T)>;
}}
declare module "packages/com/gregtechceu/gtceu/api/blockentity/$PipeBlockEntity" {
import {$IAsyncAutoSyncBlockEntity, $IAsyncAutoSyncBlockEntity$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/blockentity/$IAsyncAutoSyncBlockEntity"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IToolable, $IToolable$Type} from "packages/com/gregtechceu/gtceu/api/capability/$IToolable"
import {$IFieldUpdateListener, $IFieldUpdateListener$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$IFieldUpdateListener"
import {$PipeNet, $PipeNet$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$PipeNet"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IAutoPersistBlockEntity, $IAutoPersistBlockEntity$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/blockentity/$IAutoPersistBlockEntity"
import {$ResourceTexture, $ResourceTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$ResourceTexture"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$PipeCoverContainer, $PipeCoverContainer$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$PipeCoverContainer"
import {$TickableSubscription, $TickableSubscription$Type} from "packages/com/gregtechceu/gtceu/api/machine/$TickableSubscription"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$AttachmentTarget, $AttachmentTarget$Type} from "packages/net/fabricmc/fabric/api/attachment/v1/$AttachmentTarget"
import {$IPipeNode, $IPipeNode$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeNode"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IPipeType, $IPipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IPipeType"
import {$ISubscription, $ISubscription$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$ISubscription"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IRef, $IRef$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/managed/$IRef"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$ManagedFieldHolder, $ManagedFieldHolder$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/field/$ManagedFieldHolder"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$IToolGridHighLight, $IToolGridHighLight$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$IToolGridHighLight"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$IEnhancedManaged, $IEnhancedManaged$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$IEnhancedManaged"
import {$GTToolType, $GTToolType$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType"
import {$PipeBlock, $PipeBlock$Type} from "packages/com/gregtechceu/gtceu/api/block/$PipeBlock"
import {$Pair, $Pair$Type} from "packages/com/mojang/datafixers/util/$Pair"
import {$IManagedStorage, $IManagedStorage$Type} from "packages/com/lowdragmc/lowdraglib/syncdata/$IManagedStorage"

export class $PipeBlockEntity<PipeType extends ($Enum<(PipeType)>) & ($IPipeType<(NodeDataType)>), NodeDataType> extends $BlockEntity implements $IPipeNode<(PipeType), (NodeDataType)>, $IEnhancedManaged, $IAsyncAutoSyncBlockEntity, $IAutoPersistBlockEntity, $IToolGridHighLight, $IToolable {
static readonly "MANAGED_FIELD_HOLDER": $ManagedFieldHolder
 "level": $Level
 "worldPosition": $BlockPos
 "remove": boolean
 "hasComparators": byte

constructor(type: $BlockEntityType$Type<(any)>, pos: $BlockPos$Type, blockState: $BlockState$Type)

public "unsubscribe"(current: $TickableSubscription$Type): void
public static "isConnected"(connections: integer, side: $Direction$Type): boolean
public "setChanged"(): void
public "setConnections"(connections: integer): void
public "triggerEvent"(id: integer, para: integer): boolean
public "serverTick"(): void
public "getConnections"(): integer
public "setRemoved"(): void
public "clearRemoved"(): void
public "getRootStorage"(): $IManagedStorage
public "onChanged"(): void
public "setConnection"(side: $Direction$Type, connected: boolean, fromNeighbor: boolean): void
public "notifyBlockUpdate"(): void
public "getDefaultPaintingColor"(): integer
public "setBlocked"(side: $Direction$Type, isBlocked: boolean): void
public "setBlockedConnections"(blockedConnections: integer): void
public "getBlockedConnections"(): integer
public "scheduleRenderUpdate"(): void
public "subscribeServerTick"(runnable: $Runnable$Type): $TickableSubscription
public "getVisualConnections"(): integer
public "getNumConnections"(): integer
public static "isFaceBlocked"(blockedConnections: integer, side: $Direction$Type): boolean
public "getPipeTexture"(isBlock: boolean): $ResourceTexture
public "setFrameMaterial"(frameMaterial: $Material$Type): void
public "getFrameMaterial"(): $Material
public "getCoverContainer"(): $PipeCoverContainer
public "getPipeTuneTool"(): $GTToolType
public "onToolClick"(toolTypes: $Set$Type<($GTToolType$Type)>, itemStack: $ItemStack$Type, context: $UseOnContext$Type): $Pair<($GTToolType), ($InteractionResult)>
public "getOffsetTimer"(): long
public "getNodeData"(): NodeDataType
public "getFieldHolder"(): $ManagedFieldHolder
public "shouldRenderGrid"(player: $Player$Type, held: $ItemStack$Type, toolTypes: $Set$Type<($GTToolType$Type)>): boolean
public "sideTips"(player: $Player$Type, toolTypes: $Set$Type<($GTToolType$Type)>, side: $Direction$Type): $ResourceTexture
public "getPaintingColor"(): integer
public "setPaintingColor"(paintingColor: integer): void
public "doExplosion"(explosionPower: float): void
public "self"(): $BlockEntity
public "isConnected"(side: $Direction$Type): boolean
public "markAsDirty"(): void
public "isRemote"(): boolean
public "isBlocked"(side: $Direction$Type): boolean
public "canAttachTo"(arg0: $Direction$Type): boolean
public "canHaveBlockedFaces"(): boolean
public "scheduleNeighborShapeUpdate"(): void
public "getPipeType"(): PipeType
public "getPipeLevel"(): $Level
public "getPipeNet"(): $PipeNet<(NodeDataType)>
public "getPipePos"(): $BlockPos
public "getNeighbor"(direction: $Direction$Type): $BlockEntity
public "getPipeBlock"(): $PipeBlock<(PipeType), (NodeDataType), (any)>
public "isInValid"(): boolean
public "scheduleRender"(fieldName: string, newValue: any, oldValue: any): void
public "onInValid"(): void
public "onValid"(): void
public "useAsyncThread"(): boolean
public "asyncTick"(periodID: long): void
public "saveManagedPersistentData"(tag: $CompoundTag$Type, forDrop: boolean): void
public "loadManagedPersistentData"(tag: $CompoundTag$Type): void
public "loadCustomPersistedData"(tag: $CompoundTag$Type): void
public "saveCustomPersistedData"(tag: $CompoundTag$Type, forDrop: boolean): void
public "subscribeServerTick"(last: $TickableSubscription$Type, runnable: $Runnable$Type): $TickableSubscription
public "isPainted"(): boolean
public "getRealColor"(): integer
public "markDirty"(name: string): void
public "onPersistedChanged"(ref: $IRef$Type, isDirty: boolean): void
public "onSyncChanged"(ref: $IRef$Type, isDirty: boolean): void
public "addSyncUpdateListener"<T>(name: string, listener: $IFieldUpdateListener$Type<(T)>): $ISubscription
public "readCustomSyncData"(tag: $CompoundTag$Type): void
public "writeCustomSyncData"(tag: $CompoundTag$Type): void
public "getSyncTag"(): string
public "defaultServerTick"(): void
public "syncNow"(force: boolean): void
public "getBlockEntityType"(): $BlockEntityType<(any)>
public "getCurrentPos"(): $BlockPos
public "getSelf"(): $BlockEntity
public "getNonLazyFields"(): ($IRef)[]
public static "transfer"(original: $AttachmentTarget$Type, target: $AttachmentTarget$Type, isDeath: boolean): void
set "connections"(value: integer)
get "connections"(): integer
get "rootStorage"(): $IManagedStorage
get "defaultPaintingColor"(): integer
set "blockedConnections"(value: integer)
get "blockedConnections"(): integer
get "visualConnections"(): integer
get "numConnections"(): integer
set "frameMaterial"(value: $Material$Type)
get "frameMaterial"(): $Material
get "coverContainer"(): $PipeCoverContainer
get "pipeTuneTool"(): $GTToolType
get "offsetTimer"(): long
get "nodeData"(): NodeDataType
get "fieldHolder"(): $ManagedFieldHolder
get "paintingColor"(): integer
set "paintingColor"(value: integer)
get "remote"(): boolean
get "pipeType"(): PipeType
get "pipeLevel"(): $Level
get "pipeNet"(): $PipeNet<(NodeDataType)>
get "pipePos"(): $BlockPos
get "pipeBlock"(): $PipeBlock<(PipeType), (NodeDataType), (any)>
get "inValid"(): boolean
get "painted"(): boolean
get "realColor"(): integer
get "syncTag"(): string
get "blockEntityType"(): $BlockEntityType<(any)>
get "currentPos"(): $BlockPos
get "nonLazyFields"(): ($IRef)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PipeBlockEntity$Type<PipeType, NodeDataType> = ($PipeBlockEntity<(PipeType), (NodeDataType)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PipeBlockEntity_<PipeType, NodeDataType> = $PipeBlockEntity$Type<(PipeType), (NodeDataType)>;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/laser/$LaserPipeNet" {
import {$LaserRoutePath, $LaserRoutePath$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/laser/$LaserRoutePath"
import {$PipeNet, $PipeNet$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$PipeNet"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$LevelLaserPipeNet, $LevelLaserPipeNet$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/laser/$LevelLaserPipeNet"
import {$LaserPipeProperties, $LaserPipeProperties$Type} from "packages/com/gregtechceu/gtceu/common/pipelike/laser/$LaserPipeProperties"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $LaserPipeNet extends $PipeNet<($LaserPipeProperties)> {

constructor(world: $LevelLaserPipeNet$Type)

public "getNetData"(pipePos: $BlockPos$Type, facing: $Direction$Type): $LaserRoutePath
public "onPipeConnectionsUpdate"(): void
public "onNeighbourUpdate"(fromPos: $BlockPos$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LaserPipeNet$Type = ($LaserPipeNet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LaserPipeNet_ = $LaserPipeNet$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/gui/$GuiTextures" {
import {$ResourceBorderTexture, $ResourceBorderTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$ResourceBorderTexture"
import {$ResourceTexture, $ResourceTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$ResourceTexture"
import {$SteamTexture, $SteamTexture$Type} from "packages/com/gregtechceu/gtceu/api/gui/$SteamTexture"

export class $GuiTextures {
static readonly "GREGTECH_LOGO": $ResourceTexture
static readonly "GREGTECH_LOGO_XMAS": $ResourceTexture
static readonly "TOOL_FRONT_FACING_ROTATION": $ResourceTexture
static readonly "TOOL_IO_FACING_ROTATION": $ResourceTexture
static readonly "TOOL_PAUSE": $ResourceTexture
static readonly "TOOL_START": $ResourceTexture
static readonly "TOOL_COVER_SETTINGS": $ResourceTexture
static readonly "TOOL_MUTE": $ResourceTexture
static readonly "TOOL_SOUND": $ResourceTexture
static readonly "TOOL_ALLOW_INPUT": $ResourceTexture
static readonly "TOOL_ATTACH_COVER": $ResourceTexture
static readonly "TOOL_REMOVE_COVER": $ResourceTexture
static readonly "TOOL_PIPE_BLOCK": $ResourceTexture
static readonly "TOOL_PIPE_CONNECT": $ResourceTexture
static readonly "TOOL_WIRE_BLOCK": $ResourceTexture
static readonly "TOOL_WIRE_CONNECT": $ResourceTexture
static readonly "TOOL_AUTO_OUTPUT": $ResourceTexture
static readonly "TOOL_DISABLE_AUTO_OUTPUT": $ResourceTexture
static readonly "TOOL_SWITCH_CONVERTER_NATIVE": $ResourceTexture
static readonly "TOOL_SWITCH_CONVERTER_EU": $ResourceTexture
static readonly "BACKGROUND": $ResourceBorderTexture
static readonly "BACKGROUND_INVERSE": $ResourceBorderTexture
static readonly "BACKGROUND_STEAM": $SteamTexture
static readonly "CLIPBOARD_BACKGROUND": $ResourceTexture
static readonly "CLIPBOARD_PAPER_BACKGROUND": $ResourceTexture
static readonly "TITLE_BAR_BACKGROUND": $ResourceBorderTexture
static readonly "DISPLAY": $ResourceTexture
static readonly "DISPLAY_STEAM": $SteamTexture
static readonly "BLANK": $ResourceTexture
static readonly "BLANK_TRANSPARENT": $ResourceTexture
static readonly "FLUID_SLOT": $ResourceBorderTexture
static readonly "FLUID_TANK_BACKGROUND": $ResourceTexture
static readonly "FLUID_TANK_OVERLAY": $ResourceTexture
static readonly "SLOT": $ResourceBorderTexture
static readonly "SLOT_DARKENED": $ResourceTexture
static readonly "SLOT_STEAM": $SteamTexture
static readonly "TOGGLE_BUTTON_BACK": $ResourceTexture
static readonly "CLOSE_ICON": $ResourceTexture
static readonly "BLOCKS_INPUT": $ResourceTexture
static readonly "BUTTON": $ResourceBorderTexture
static readonly "BUTTON_ALLOW_IMPORT_EXPORT": $ResourceTexture
static readonly "BUTTON_BLACKLIST": $ResourceTexture
static readonly "BUTTON_CHUNK_MODE": $ResourceTexture
static readonly "BUTTON_CLEAR_GRID": $ResourceTexture
static readonly "BUTTON_FILTER_DAMAGE": $ResourceTexture
static readonly "BUTTON_DISTINCT_BUSES": $ResourceTexture
static readonly "BUTTON_POWER": $ResourceTexture
static readonly "BUTTON_FILTER_NBT": $ResourceTexture
static readonly "BUTTON_FLUID_OUTPUT": $ResourceTexture
static readonly "BUTTON_ITEM_OUTPUT": $ResourceTexture
static readonly "BUTTON_LOCK": $ResourceTexture
static readonly "BUTTON_VOID": $ResourceTexture
static readonly "BUTTON_VOID_PARTIAL": $ResourceTexture
static readonly "BUTTON_VOID_MULTIBLOCK": $ResourceTexture
static readonly "BUTTON_LEFT": $ResourceTexture
static readonly "BUTTON_PUBLIC_PRIVATE": $ResourceTexture
static readonly "BUTTON_RIGHT": $ResourceTexture
static readonly "BUTTON_SILK_TOUCH_MODE": $ResourceTexture
static readonly "BUTTON_SWITCH_VIEW": $ResourceTexture
static readonly "BUTTON_WORKING_ENABLE": $ResourceTexture
static readonly "BUTTON_INT_CIRCUIT_PLUS": $ResourceTexture
static readonly "BUTTON_INT_CIRCUIT_MINUS": $ResourceTexture
static readonly "CLIPBOARD_BUTTON": $ResourceTexture
static readonly "CLIPBOARD_TEXT_BOX": $ResourceBorderTexture
static readonly "DISTRIBUTION_MODE": $ResourceTexture
static readonly "LOCK": $ResourceTexture
static readonly "LOCK_WHITE": $ResourceTexture
static readonly "SWITCH": $ResourceTexture
static readonly "SWITCH_HORIZONTAL": $ResourceTexture
static readonly "VANILLA_BUTTON": $ResourceTexture
static readonly "ENERGY_DETECTOR_COVER_MODE_BUTTON": $ResourceTexture
static readonly "INVERT_REDSTONE_BUTTON": $ResourceTexture
static readonly "IO_CONFIG_FLUID_MODES_BUTTON": $ResourceTexture
static readonly "IO_CONFIG_ITEM_MODES_BUTTON": $ResourceTexture
static readonly "IO_CONFIG_COVER_SLOT_OVERLAY": $ResourceTexture
static readonly "IO_CONFIG_COVER_SETTINGS": $ResourceTexture
static readonly "INDICATOR_NO_ENERGY": $ResourceTexture
static readonly "INDICATOR_NO_STEAM": $SteamTexture
static readonly "TANK_ICON": $ResourceTexture
static readonly "SLIDER_BACKGROUND": $ResourceTexture
static readonly "SLIDER_BACKGROUND_VERTICAL": $ResourceTexture
static readonly "SLIDER_ICON": $ResourceTexture
static readonly "MAINTENANCE_BUTTON": $ResourceTexture
static readonly "MAINTENANCE_ICON": $ResourceTexture
static readonly "BUTTON_MINER_MODES": $ResourceTexture
static readonly "OREBY_BASE": $ResourceTexture
static readonly "OREBY_CHEM": $ResourceTexture
static readonly "OREBY_SEP": $ResourceTexture
static readonly "OREBY_SIFT": $ResourceTexture
static readonly "OREBY_SMELT": $ResourceTexture
static readonly "PRIMITIVE_BACKGROUND": $ResourceBorderTexture
static readonly "PRIMITIVE_SLOT": $ResourceBorderTexture
static readonly "PRIMITIVE_FURNACE_OVERLAY": $ResourceTexture
static readonly "PRIMITIVE_DUST_OVERLAY": $ResourceTexture
static readonly "PRIMITIVE_INGOT_OVERLAY": $ResourceTexture
static readonly "PRIMITIVE_LARGE_FLUID_TANK": $ResourceTexture
static readonly "PRIMITIVE_LARGE_FLUID_TANK_OVERLAY": $ResourceTexture
static readonly "PRIMITIVE_BLAST_FURNACE_PROGRESS_BAR": $ResourceTexture
static readonly "ATOMIC_OVERLAY_1": $ResourceTexture
static readonly "ATOMIC_OVERLAY_2": $ResourceTexture
static readonly "ARROW_INPUT_OVERLAY": $ResourceTexture
static readonly "ARROW_OUTPUT_OVERLAY": $ResourceTexture
static readonly "BATTERY_OVERLAY": $ResourceTexture
static readonly "BEAKER_OVERLAY_1": $ResourceTexture
static readonly "BEAKER_OVERLAY_2": $ResourceTexture
static readonly "BEAKER_OVERLAY_3": $ResourceTexture
static readonly "BEAKER_OVERLAY_4": $ResourceTexture
static readonly "BENDER_OVERLAY": $ResourceTexture
static readonly "BOX_OVERLAY": $ResourceTexture
static readonly "BOXED_OVERLAY": $ResourceTexture
static readonly "BREWER_OVERLAY": $ResourceTexture
static readonly "CANNER_OVERLAY": $ResourceTexture
static readonly "CHARGER_OVERLAY": $ResourceTexture
static readonly "CANISTER_OVERLAY": $ResourceTexture
static readonly "CANISTER_OVERLAY_STEAM": $SteamTexture
static readonly "CENTRIFUGE_OVERLAY": $ResourceTexture
static readonly "CIRCUIT_OVERLAY": $ResourceTexture
static readonly "COAL_OVERLAY_STEAM": $SteamTexture
static readonly "COMPRESSOR_OVERLAY": $ResourceTexture
static readonly "COMPRESSOR_OVERLAY_STEAM": $SteamTexture
static readonly "CRACKING_OVERLAY_1": $ResourceTexture
static readonly "CRACKING_OVERLAY_2": $ResourceTexture
static readonly "CRUSHED_ORE_OVERLAY": $ResourceTexture
static readonly "CRUSHED_ORE_OVERLAY_STEAM": $SteamTexture
static readonly "CRYSTAL_OVERLAY": $ResourceTexture
static readonly "CUTTER_OVERLAY": $ResourceTexture
static readonly "DARK_CANISTER_OVERLAY": $ResourceTexture
static readonly "DUST_OVERLAY": $ResourceTexture
static readonly "DUST_OVERLAY_STEAM": $SteamTexture
static readonly "EXTRACTOR_OVERLAY": $ResourceTexture
static readonly "EXTRACTOR_OVERLAY_STEAM": $SteamTexture
static readonly "FILTER_SLOT_OVERLAY": $ResourceTexture
static readonly "FURNACE_OVERLAY_1": $ResourceTexture
static readonly "FURNACE_OVERLAY_2": $ResourceTexture
static readonly "FURNACE_OVERLAY_STEAM": $SteamTexture
static readonly "HAMMER_OVERLAY": $ResourceTexture
static readonly "HAMMER_OVERLAY_STEAM": $SteamTexture
static readonly "HEATING_OVERLAY_1": $ResourceTexture
static readonly "HEATING_OVERLAY_2": $ResourceTexture
static readonly "IMPLOSION_OVERLAY_1": $ResourceTexture
static readonly "IMPLOSION_OVERLAY_2": $ResourceTexture
static readonly "IN_SLOT_OVERLAY": $ResourceTexture
static readonly "IN_SLOT_OVERLAY_STEAM": $SteamTexture
static readonly "INGOT_OVERLAY": $ResourceTexture
static readonly "INT_CIRCUIT_OVERLAY": $ResourceTexture
static readonly "LENS_OVERLAY": $ResourceTexture
static readonly "LIGHTNING_OVERLAY_1": $ResourceTexture
static readonly "LIGHTNING_OVERLAY_2": $ResourceTexture
static readonly "MOLD_OVERLAY": $ResourceTexture
static readonly "MOLECULAR_OVERLAY_1": $ResourceTexture
static readonly "MOLECULAR_OVERLAY_2": $ResourceTexture
static readonly "MOLECULAR_OVERLAY_3": $ResourceTexture
static readonly "MOLECULAR_OVERLAY_4": $ResourceTexture
static readonly "OUT_SLOT_OVERLAY": $ResourceTexture
static readonly "OUT_SLOT_OVERLAY_STEAM": $SteamTexture
static readonly "PAPER_OVERLAY": $ResourceTexture
static readonly "PRINTED_PAPER_OVERLAY": $ResourceTexture
static readonly "PIPE_OVERLAY_2": $ResourceTexture
static readonly "PIPE_OVERLAY_1": $ResourceTexture
static readonly "PRESS_OVERLAY_1": $ResourceTexture
static readonly "PRESS_OVERLAY_2": $ResourceTexture
static readonly "PRESS_OVERLAY_3": $ResourceTexture
static readonly "PRESS_OVERLAY_4": $ResourceTexture
static readonly "SAWBLADE_OVERLAY": $ResourceTexture
static readonly "SOLIDIFIER_OVERLAY": $ResourceTexture
static readonly "STRING_SLOT_OVERLAY": $ResourceTexture
static readonly "TOOL_SLOT_OVERLAY": $ResourceTexture
static readonly "TURBINE_OVERLAY": $ResourceTexture
static readonly "VIAL_OVERLAY_1": $ResourceTexture
static readonly "VIAL_OVERLAY_2": $ResourceTexture
static readonly "WIREMILL_OVERLAY": $ResourceTexture
static readonly "POSITIVE_MATTER_OVERLAY": $ResourceTexture
static readonly "NEUTRAL_MATTER_OVERLAY": $ResourceTexture
static readonly "DATA_ORB_OVERLAY": $ResourceTexture
static readonly "SCANNER_OVERLAY": $ResourceTexture
static readonly "DUCT_TAPE_OVERLAY": $ResourceTexture
static readonly "RESEARCH_STATION_OVERLAY": $ResourceTexture
static readonly "PROGRESS_BAR_ARC_FURNACE": $ResourceTexture
static readonly "PROGRESS_BAR_ARROW": $ResourceTexture
static readonly "PROGRESS_BAR_ARROW_STEAM": $SteamTexture
static readonly "PROGRESS_BAR_ARROW_MULTIPLE": $ResourceTexture
static readonly "PROGRESS_BAR_ASSEMBLY_LINE": $ResourceTexture
static readonly "PROGRESS_BAR_ASSEMBLY_LINE_ARROW": $ResourceTexture
static readonly "PROGRESS_BAR_BATH": $ResourceTexture
static readonly "PROGRESS_BAR_BENDING": $ResourceTexture
static readonly "PROGRESS_BAR_BOILER_EMPTY": $SteamTexture
static readonly "PROGRESS_BAR_BOILER_FUEL": $SteamTexture
static readonly "PROGRESS_BAR_BOILER_HEAT": $ResourceTexture
static readonly "PROGRESS_BAR_CANNER": $ResourceTexture
static readonly "PROGRESS_BAR_CIRCUIT": $ResourceTexture
static readonly "PROGRESS_BAR_CIRCUIT_ASSEMBLER": $ResourceTexture
static readonly "PROGRESS_BAR_COKE_OVEN": $ResourceTexture
static readonly "PROGRESS_BAR_COMPRESS": $ResourceTexture
static readonly "PROGRESS_BAR_COMPRESS_STEAM": $SteamTexture
static readonly "PROGRESS_BAR_CRACKING": $ResourceTexture
static readonly "PROGRESS_BAR_CRACKING_INPUT": $ResourceTexture
static readonly "PROGRESS_BAR_CRYSTALLIZATION": $ResourceTexture
static readonly "PROGRESS_BAR_DISTILLATION_TOWER": $ResourceTexture
static readonly "PROGRESS_BAR_EXTRACT": $ResourceTexture
static readonly "PROGRESS_BAR_EXTRACT_STEAM": $SteamTexture
static readonly "PROGRESS_BAR_EXTRUDER": $ResourceTexture
static readonly "PROGRESS_BAR_FUSION": $ResourceTexture
static readonly "PROGRESS_BAR_GAS_COLLECTOR": $ResourceTexture
static readonly "PROGRESS_BAR_HAMMER": $ResourceTexture
static readonly "PROGRESS_BAR_HAMMER_STEAM": $SteamTexture
static readonly "PROGRESS_BAR_HAMMER_BASE": $ResourceTexture
static readonly "PROGRESS_BAR_HAMMER_BASE_STEAM": $SteamTexture
static readonly "PROGRESS_BAR_LATHE": $ResourceTexture
static readonly "PROGRESS_BAR_LATHE_BASE": $ResourceTexture
static readonly "PROGRESS_BAR_MACERATE": $ResourceTexture
static readonly "PROGRESS_BAR_MACERATE_STEAM": $SteamTexture
static readonly "PROGRESS_BAR_MAGNET": $ResourceTexture
static readonly "PROGRESS_BAR_MASS_FAB": $ResourceTexture
static readonly "PROGRESS_BAR_MIXER": $ResourceTexture
static readonly "PROGRESS_BAR_PACKER": $ResourceTexture
static readonly "PROGRESS_BAR_RECYCLER": $ResourceTexture
static readonly "PROGRESS_BAR_REPLICATOR": $ResourceTexture
static readonly "PROGRESS_BAR_SIFT": $ResourceTexture
static readonly "PROGRESS_BAR_SLICE": $ResourceTexture
static readonly "PROGRESS_BAR_SOLAR_STEAM": $SteamTexture
static readonly "PROGRESS_BAR_UNLOCK": $ResourceTexture
static readonly "PROGRESS_BAR_UNPACKER": $ResourceTexture
static readonly "PROGRESS_BAR_WIREMILL": $ResourceTexture
static readonly "PROGRESS_BAR_RESEARCH_STATION_1": $ResourceTexture
static readonly "PROGRESS_BAR_RESEARCH_STATION_2": $ResourceTexture
static readonly "PROGRESS_BAR_RESEARCH_STATION_BASE": $ResourceTexture
static readonly "INFO_ICON": $ResourceTexture
static readonly "MULTIBLOCK_CATEGORY": $ResourceTexture
static readonly "COVER_MACHINE_CONTROLLER": $ResourceTexture
static readonly "ICON_REMOVE": $ResourceTexture
static readonly "ICON_UP": $ResourceTexture
static readonly "ICON_DOWN": $ResourceTexture
static readonly "ICON_RIGHT": $ResourceTexture
static readonly "ICON_LEFT": $ResourceTexture
static readonly "ICON_ADD": $ResourceTexture
static readonly "ICON_NEW_PAGE": $ResourceTexture
static readonly "ICON_LOAD": $ResourceTexture
static readonly "ICON_SAVE": $ResourceTexture
static readonly "ICON_LOCATION": $ResourceTexture
static readonly "ICON_VISIBLE": $ResourceTexture
static readonly "ICON_CALCULATOR": $ResourceTexture
static readonly "UI_FRAME_SIDE_UP": $ResourceTexture
static readonly "UI_FRAME_SIDE_DOWN": $ResourceTexture
static readonly "BUTTON_FLUID": $ResourceTexture
static readonly "BUTTON_ITEM": $ResourceTexture
static readonly "BUTTON_ENERGY": $ResourceTexture
static readonly "BUTTON_MACHINE": $ResourceTexture
static readonly "BUTTON_INTERFACE": $ResourceTexture
static readonly "COVER_INTERFACE_MACHINE_ON_PROXY": $ResourceTexture
static readonly "COVER_INTERFACE_MACHINE_OFF_PROXY": $ResourceTexture
static readonly "SCENE": $ResourceTexture
static readonly "DISPLAY_FRAME": $ResourceBorderTexture
static readonly "INSUFFICIENT_INPUT": $ResourceTexture
static readonly "ENERGY_BAR_BACKGROUND": $ResourceBorderTexture
static readonly "ENERGY_BAR_BASE": $ResourceBorderTexture
static readonly "LIGHT_ON": $ResourceTexture
static readonly "LIGHT_OFF": $ResourceTexture
static readonly "UP": $ResourceTexture
static readonly "TIER": ($ResourceTexture)[]
static readonly "NUMBER_BACKGROUND": $ResourceTexture
static readonly "CONFIG_ARROW": $ResourceTexture
static readonly "CONFIG_ARROW_DARK": $ResourceTexture
static readonly "SELECT_BOX": $ResourceTexture
static readonly "HPCA_COMPONENT_OUTLINE": $ResourceTexture
static readonly "HPCA_ICON_EMPTY_COMPONENT": $ResourceTexture
static readonly "HPCA_ICON_ADVANCED_COMPUTATION_COMPONENT": $ResourceTexture
static readonly "HPCA_ICON_BRIDGE_COMPONENT": $ResourceTexture
static readonly "HPCA_ICON_COMPUTATION_COMPONENT": $ResourceTexture
static readonly "HPCA_ICON_ACTIVE_COOLER_COMPONENT": $ResourceTexture
static readonly "HPCA_ICON_HEAT_SINK_COMPONENT": $ResourceTexture
static readonly "HPCA_ICON_DAMAGED_ADVANCED_COMPUTATION_COMPONENT": $ResourceTexture
static readonly "HPCA_ICON_DAMAGED_COMPUTATION_COMPONENT": $ResourceTexture

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiTextures$Type = ($GuiTextures);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiTextures_ = $GuiTextures$Type;
}}
declare module "packages/com/gregtechceu/gtceu/core/$IFireImmuneEntity" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IFireImmuneEntity {

 "gtceu$setFireImmune"(arg0: boolean): void

(arg0: boolean): void
}

export namespace $IFireImmuneEntity {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFireImmuneEntity$Type = ($IFireImmuneEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFireImmuneEntity_ = $IFireImmuneEntity$Type;
}}
declare module "packages/com/gregtechceu/gtceu/core/mixins/$IngredientAccessor" {
import {$Ingredient$Value, $Ingredient$Value$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient$Value"

export interface $IngredientAccessor {

 "getValues"(): ($Ingredient$Value)[]

(): ($Ingredient$Value)[]
}

export namespace $IngredientAccessor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientAccessor$Type = ($IngredientAccessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IngredientAccessor_ = $IngredientAccessor$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/item/$IGTTool" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$HeldItemUIFactory$IHeldItemUIHolder, $HeldItemUIFactory$IHeldItemUIHolder$Type} from "packages/com/lowdragmc/lowdraglib/gui/factory/$HeldItemUIFactory$IHeldItemUIHolder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$DustProperty, $DustProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$DustProperty"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$IGTToolDefinition, $IGTToolDefinition$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$IGTToolDefinition"
import {$HeldItemUIFactory$HeldItemHolder, $HeldItemUIFactory$HeldItemHolder$Type} from "packages/com/lowdragmc/lowdraglib/gui/factory/$HeldItemUIFactory$HeldItemHolder"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemColor, $ItemColor$Type} from "packages/net/minecraft/client/color/item/$ItemColor"
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$GTToolType, $GTToolType$Type} from "packages/com/gregtechceu/gtceu/api/item/tool/$GTToolType"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$ModularUI, $ModularUI$Type} from "packages/com/lowdragmc/lowdraglib/gui/modular/$ModularUI"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$ToolProperty, $ToolProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$ToolProperty"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"
import {$SoundEntry, $SoundEntry$Type} from "packages/com/gregtechceu/gtceu/api/sound/$SoundEntry"

export interface $IGTTool extends $HeldItemUIFactory$IHeldItemUIHolder, $ItemLike {

 "get"(defaultMaxCharge: long): $ItemStack
 "get"(): $ItemStack
 "get"(defaultCharge: long, defaultMaxCharge: long): $ItemStack
 "getRaw"(): $ItemStack
 "getColor"(stack: $ItemStack$Type, tintIndex: integer): integer
 "createUI"(entityPlayer: $Player$Type, holder: $HeldItemUIFactory$HeldItemHolder$Type): $ModularUI
 "definition$canApplyAtEnchantingTable"(stack: $ItemStack$Type, enchantment: $Enchantment$Type): boolean
 "definition$shouldCauseReequipAnimation"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type, slotChanged: boolean): boolean
 "definition$getDefaultAttributeModifiers"(equipmentSlot: $EquipmentSlot$Type, stack: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
 "definition$shouldCauseBlockBreakReset"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type): boolean
 "definition$getCraftingRemainingItem"(stack: $ItemStack$Type): $ItemStack
 "definition$hasCraftingRemainingItem"(stack: $ItemStack$Type): boolean
 "definition$canDestroyBlockInCreative"(world: $Level$Type, pos: $BlockPos$Type, stack: $ItemStack$Type, player: $Player$Type): boolean
 "getCharge"(stack: $ItemStack$Type): long
 "getSound"(): $SoundEntry
 "playSound"(player: $Player$Type): void
 "isElectric"(): boolean
 "getMaterial"(): $Material
 "asItem"(): $Item
 "definition$isDamaged"(stack: $ItemStack$Type): boolean
 "playSoundOnBlockDestroy"(): boolean
 "getToolMaterial"(stack: $ItemStack$Type): $Material
 "getToolStats"(): $IGTToolDefinition
 "getMaxCharge"(stack: $ItemStack$Type): long
 "getElectricTier"(): integer
 "getToolType"(): $GTToolType
 "getToolClasses"(stack: $ItemStack$Type): $Set<($GTToolType)>
 "getTotalToolSpeed"(stack: $ItemStack$Type): float
 "getToolProperty"(stack: $ItemStack$Type): $ToolProperty
 "getDustProperty"(stack: $ItemStack$Type): $DustProperty
 "playCraftingSound"(player: $Player$Type, stack: $ItemStack$Type): void
 "definition$use"(world: $Level$Type, player: $Player$Type, hand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
 "definition$init"(): void
 "canPlaySound"(stack: $ItemStack$Type): boolean
 "getToolClassNames"(stack: $ItemStack$Type): $Set<(string)>
 "definition$getDestroySpeed"(stack: $ItemStack$Type, state: $BlockState$Type): float
 "getTotalAttackDamage"(stack: $ItemStack$Type): float
 "getTotalAttackSpeed"(stack: $ItemStack$Type): float
 "definition$hurtEnemy"(stack: $ItemStack$Type, target: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
 "getTotalHarvestLevel"(stack: $ItemStack$Type): integer
 "getMaterialAttackSpeed"(stack: $ItemStack$Type): float
 "definition$onBlockStartBreak"(stack: $ItemStack$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
 "definition$mineBlock"(stack: $ItemStack$Type, worldIn: $Level$Type, state: $BlockState$Type, pos: $BlockPos$Type, entityLiving: $LivingEntity$Type): boolean
 "definition$isValidRepairItem"(toRepair: $ItemStack$Type, repair: $ItemStack$Type): boolean
 "definition$getHarvestLevel"(stack: $ItemStack$Type, toolClass: $GTToolType$Type, player: $Player$Type, blockState: $BlockState$Type): integer
 "getMaterialAttackDamage"(stack: $ItemStack$Type): float
 "definition$canDisableShield"(stack: $ItemStack$Type, shield: $ItemStack$Type, entity: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
 "definition$doesSneakBypassUse"(stack: $ItemStack$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
 "getMaterialEnchantability"(stack: $ItemStack$Type): integer
 "definition$onEntitySwing"(entityLiving: $LivingEntity$Type, stack: $ItemStack$Type): boolean
 "getTotalEnchantability"(stack: $ItemStack$Type): integer
 "getMaterialDurability"(stack: $ItemStack$Type): integer
 "definition$getDamage"(stack: $ItemStack$Type): integer
 "getTotalMaxDurability"(stack: $ItemStack$Type): integer
 "getMaterialToolSpeed"(stack: $ItemStack$Type): float
 "getMaterialHarvestLevel"(stack: $ItemStack$Type): integer
 "definition$getMaxDamage"(stack: $ItemStack$Type): integer
 "definition$setDamage"(stack: $ItemStack$Type, durability: integer): void
 "definition$getDurabilityForDisplay"(stack: $ItemStack$Type): double
 "definition$onItemUse"(context: $UseOnContext$Type): $InteractionResult
 "setLastCraftingSoundTime"(stack: $ItemStack$Type): void
 "definition$initCapabilities"(stack: $ItemStack$Type, nbt: $CompoundTag$Type): $ICapabilityProvider
 "definition$appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
 "definition$shouldOpenUIAfterUse"(context: $UseOnContext$Type): boolean
 "definition$fillItemCategory"(category: $CreativeModeTab$Type, items: $NonNullList$Type<($ItemStack$Type)>): void
 "definition$onItemUseFirst"(stack: $ItemStack$Type, context: $UseOnContext$Type): $InteractionResult
 "definition$isCorrectToolForDrops"(stack: $ItemStack$Type, state: $BlockState$Type): boolean
}

export namespace $IGTTool {
function tintColor(): $ItemColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IGTTool$Type = ($IGTTool);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IGTTool_ = $IGTTool$Type;
}}
declare module "packages/com/gregtechceu/gtceu/common/pipelike/item/$ItemPipeType" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$IMaterialPipeType, $IMaterialPipeType$Type} from "packages/com/gregtechceu/gtceu/api/pipenet/$IMaterialPipeType"
import {$ItemPipeProperties, $ItemPipeProperties$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$ItemPipeProperties"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$PipeModel, $PipeModel$Type} from "packages/com/gregtechceu/gtceu/client/model/$PipeModel"
import {$TagPrefix, $TagPrefix$Type} from "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ItemPipeType extends $Enum<($ItemPipeType)> implements $IMaterialPipeType<($ItemPipeProperties)> {
static readonly "SMALL": $ItemPipeType
static readonly "NORMAL": $ItemPipeType
static readonly "LARGE": $ItemPipeType
static readonly "HUGE": $ItemPipeType
static readonly "RESTRICTIVE_SMALL": $ItemPipeType
static readonly "RESTRICTIVE_NORMAL": $ItemPipeType
static readonly "RESTRICTIVE_LARGE": $ItemPipeType
static readonly "RESTRICTIVE_HUGE": $ItemPipeType
static readonly "TYPE_ID": $ResourceLocation
static readonly "VALUES": ($ItemPipeType)[]
readonly "name": string


public "getName"(): string
public "type"(): $ResourceLocation
public static "values"(): ($ItemPipeType)[]
public static "valueOf"(name: string): $ItemPipeType
public "getThickness"(): float
public "getTagPrefix"(): $TagPrefix
public "modifyProperties"(baseProperties: $ItemPipeProperties$Type): $ItemPipeProperties
public "isPaintable"(): boolean
public "createPipeModel"(material: $Material$Type): $PipeModel
public "isRestrictive"(): boolean
public "getRateMultiplier"(): float
public "getSizeForTexture"(): string
get "name"(): string
get "thickness"(): float
get "tagPrefix"(): $TagPrefix
get "paintable"(): boolean
get "restrictive"(): boolean
get "rateMultiplier"(): float
get "sizeForTexture"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPipeType$Type = (("small") | ("normal") | ("restrictive_small") | ("restrictive_normal") | ("large") | ("restrictive_large") | ("restrictive_huge") | ("huge")) | ($ItemPipeType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemPipeType_ = $ItemPipeType$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/gui/fancy/$IFancyTooltip" {
import {$TooltipComponent, $TooltipComponent$Type} from "packages/net/minecraft/world/inventory/tooltip/$TooltipComponent"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IGuiTexture, $IGuiTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$IGuiTexture"

export interface $IFancyTooltip {

 "showFancyTooltip"(): boolean
 "getFancyTooltip"(): $List<($Component)>
 "getFancyComponent"(): $TooltipComponent
 "getFancyTooltipIcon"(): $IGuiTexture
}

export namespace $IFancyTooltip {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFancyTooltip$Type = ($IFancyTooltip);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFancyTooltip_ = $IFancyTooltip$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/gui/fancy/$IFancyUIProvider" {
import {$TooltipComponent, $TooltipComponent$Type} from "packages/net/minecraft/world/inventory/tooltip/$TooltipComponent"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Widget, $Widget$Type} from "packages/com/lowdragmc/lowdraglib/gui/widget/$Widget"
import {$FancyMachineUIWidget, $FancyMachineUIWidget$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$FancyMachineUIWidget"
import {$IFancyUIProvider$PageGroupingData, $IFancyUIProvider$PageGroupingData$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$IFancyUIProvider$PageGroupingData"
import {$ConfiguratorPanel, $ConfiguratorPanel$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$ConfiguratorPanel"
import {$IGuiTexture, $IGuiTexture$Type} from "packages/com/lowdragmc/lowdraglib/gui/texture/$IGuiTexture"
import {$TabsWidget, $TabsWidget$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$TabsWidget"
import {$TooltipsPanel, $TooltipsPanel$Type} from "packages/com/gregtechceu/gtceu/api/gui/fancy/$TooltipsPanel"

export interface $IFancyUIProvider {

 "getTitle"(): $Component
 "createMainPage"(arg0: $FancyMachineUIWidget$Type): $Widget
 "getTabTooltips"(): $List<($Component)>
 "attachTooltips"(tooltipsPanel: $TooltipsPanel$Type): void
 "attachSideTabs"(configuratorPanel: $TabsWidget$Type): void
 "getTabIcon"(): $IGuiTexture
 "hasPlayerInventory"(): boolean
 "getSubTabs"(): $List<($IFancyUIProvider)>
 "getTabTooltipComponent"(): $TooltipComponent
 "getPageGroupingData"(): $IFancyUIProvider$PageGroupingData
 "attachConfigurators"(configuratorPanel: $ConfiguratorPanel$Type): void
}

export namespace $IFancyUIProvider {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFancyUIProvider$Type = ($IFancyUIProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFancyUIProvider_ = $IFancyUIProvider$Type;
}}
declare module "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix$MaterialRecipeHandler" {
import {$Material, $Material$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/$Material"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IMaterialProperty, $IMaterialProperty$Type} from "packages/com/gregtechceu/gtceu/api/data/chemical/material/properties/$IMaterialProperty"
import {$TagPrefix, $TagPrefix$Type} from "packages/com/gregtechceu/gtceu/api/data/tag/$TagPrefix"
import {$FinishedRecipe, $FinishedRecipe$Type} from "packages/net/minecraft/data/recipes/$FinishedRecipe"

export interface $TagPrefix$MaterialRecipeHandler<T extends $IMaterialProperty<(T)>> {

 "accept"(arg0: $TagPrefix$Type, arg1: $Material$Type, arg2: T, arg3: $Consumer$Type<($FinishedRecipe$Type)>): void

(arg0: $TagPrefix$Type, arg1: $Material$Type, arg2: T, arg3: $Consumer$Type<($FinishedRecipe$Type)>): void
}

export namespace $TagPrefix$MaterialRecipeHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagPrefix$MaterialRecipeHandler$Type<T> = ($TagPrefix$MaterialRecipeHandler<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TagPrefix$MaterialRecipeHandler_<T> = $TagPrefix$MaterialRecipeHandler$Type<(T)>;
}}
